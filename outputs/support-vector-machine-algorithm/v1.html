
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVM Visualizer</title>
    <style>
        /* Basic Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: #ffffff; /* GeeksforGeeks Background */
            color: #222222; /* GeeksforGeeks Text */
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            flex-direction: column;
            height: 100vh; /* Full viewport height */
        }

        #app-container {
            display: flex;
            flex: 1; /* Occupy space between header (if any) and footer */
        }

        #canvas-container {
            flex: 4; /* 80% width */
            position: relative;
            border-right: 1px solid #ccc; /* Separator */
            overflow: hidden; /* Ensure canvas doesn't overflow */
        }

        #svm-canvas {
            display: block; /* Remove extra space below canvas */
            background-color: #f8f8f8; /* Slightly off-white for canvas */
            width: 100%;
            height: 100%;
        }

        #sidebar {
            flex: 1; /* 20% width */
            padding: 15px;
            background-color: #ffffff; /* White background */
            overflow-y: auto; /* Allow sidebar to scroll if content overflows */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }

        .control-group:last-child {
             border-bottom: none;
             padding-bottom: 0;
        }

        h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #2f8d46; /* GeeksforGeeks Green */
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        button {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #2f8d46; /* GeeksforGeeks Green */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #287b3c; /* Darker green on hover */
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .button-group {
            display: flex;
            gap: 5px;
        }

        .button-group button {
            flex: 1;
            margin-bottom: 0; /* Remove bottom margin in groups */
        }

        #class-toggle-button {
             background-color: #007bff; /* Default blue */
             color: white;
        }

        #class-toggle-button.class1 {
             background-color: #dc3545; /* Red for class 1 */
        }


        #footer {
            background-color: #f0f0f0; /* Light grey footer */
            color: #555;
            text-align: center;
            padding: 10px;
            font-size: 0.8em;
            width: 100%;
            flex-shrink: 0; /* Prevent footer from shrinking */
        }

        #footer a {
            color: #2f8d46; /* GeeksforGeeks Green */
            text-decoration: none;
            margin: 0 10px;
        }

        #footer a:hover {
            text-decoration: underline;
        }

        /* Auxiliary Kernel Plot Placeholder (if needed later) */
        #auxiliary-plot {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            display: none; /* Hidden by default */
            z-index: 10;
        }

    </style>
</head>
<body>

    <div id="app-container">
        <div id="canvas-container">
            <canvas id="svm-canvas"></canvas>
            <!-- Auxiliary plot placeholder -->
            <!-- <div id="auxiliary-plot"></div> -->
        </div>

        <div id="sidebar">
            <div class="control-group">
                 <h3>Data</h3>
                 <button id="add-point-button">Add Point (Class <span id="current-class-text">0</span>)</button>
                 <div class="button-group">
                    <button id="load-linear-data">Linear Data</button>
                    <button id="load-nonlinear-data">Non-Linear Data</button>
                 </div>
                 <button id="reset-data">Reset Data</button>
            </div>

            <div class="control-group">
                 <h3>Parameters</h3>
                 <label for="kernel-select">Kernel Type:</label>
                 <select id="kernel-select">
                     <option value="linear">Linear</option>
                     <!-- Non-linear kernels are UI placeholders without a full algorithm -->
                     <!-- <option value="rbf">RBF</option> -->
                     <!-- <option value="poly">Polynomial</option> -->
                 </select>

                 <!-- C slider for Soft Margin (only visually impacts misclassified points) -->
                 <label for="c-slider">Regularization (C): <span id="c-value">1</span></label>
                 <input type="range" id="c-slider" min="0.1" max="100" value="1" step="0.1">
            </div>

            <div class="control-group">
                 <h3>Actions</h3>
                 <button id="train-svm-button">Train SVM</button>
            </div>
        </div>
    </div>

    <div id="footer">
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a> |
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </div>

    <script>
        // --- Canvas Setup ---
        const canvas = document.getElementById('svm-canvas');
        const ctx = canvas.getContext('2d');
        let canvasRect; // To store canvas position and size

        // --- Data State ---
        let dataPoints = []; // Array of { x, y, class: 0 or 1, isSupportVector: boolean, isMisclassified: boolean }
        let currentClass = 0; // 0 or 1
        let draggingPoint = null; // Index of point being dragged
        let dragStartX = 0;
        let dragStartY = 0;
        let pointDragOffset = { x: 0, y: 0 };

        // --- SVM State (Simplified) ---
        let kernelType = 'linear'; // 'linear', 'rbf', 'poly' (only linear is functional)
        let C = 1.0; // Regularization parameter (only affects misclassification visualization)

        // --- SVM Visualization State (Simplified) ---
        // For Linear SVM, we need a line: ax + by + c = 0, or y = mx + b
        // Simplification: We'll manually determine/simulate a line for perfectly separable data.
        // For non-separable or soft margin, we'll visually indicate points but the line isn't optimized.
        let hyperplane = { m: 0, b: 0 }; // y = m*x + b (simplified for non-vertical lines)
        let margin = 0; // Distance from hyperplane to margin lines
        let supportVectors = []; // Indices of simulated SVs
        let misclassifiedPoints = []; // Indices of points violating margin/wrong side

        // --- Configuration ---
        const pointRadius = 5;
        const classColors = ['#007bff', '#dc3545']; // Blue, Red
        const svHighlightColor = '#ffc107'; // Yellow
        const misclassifiedHighlightColor = '#ff4d4d'; // Brighter red

        // --- UI Elements ---
        const addPointButton = document.getElementById('add-point-button');
        const currentClassText = document.getElementById('current-class-text');
        const loadLinearDataButton = document.getElementById('load-linear-data');
        const loadNonlinearDataButton = document.getElementById('load-nonlinear-data');
        const resetDataButton = document.getElementById('reset-data');
        const kernelSelect = document.getElementById('kernel-select');
        const cSlider = document.getElementById('c-slider');
        const cValueSpan = document.getElementById('c-value');
        const trainSvmButton = document.getElementById('train-svm-button');

        // --- Event Handlers ---
        function handleCanvasClick(event) {
            if (draggingPoint !== null) return; // Don't add points if just finished dragging

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if click is on an existing point
            for (let i = 0; i < dataPoints.length; i++) {
                 const p = dataPoints[i];
                 const dist = Math.sqrt((x - toCanvasX(p.x))**2 + (y - toCanvasY(p.y))**2);
                 if (dist < pointRadius * 2) { // Clicked near a point
                     // Could implement selecting, deleting, etc. For now, only add if not clicking near existing
                     return;
                 }
            }

            // Add new point
            dataPoints.push({ x: toDataX(x), y: toDataY(y), class: currentClass, isSupportVector: false, isMisclassified: false });
            trainSVM(); // Retrain/update visualization
        }

        function handleCanvasMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if click is on an existing point
            for (let i = 0; i < dataPoints.length; i++) {
                 const p = dataPoints[i];
                 const canvasX = toCanvasX(p.x);
                 const canvasY = toCanvasY(p.y);
                 const dist = Math.sqrt((x - canvasX)**2 + (y - canvasY)**2);

                 if (dist < pointRadius * 2) { // Clicked near a point
                     draggingPoint = i;
                     dragStartX = event.clientX;
                     dragStartY = event.clientY;
                     pointDragOffset.x = canvasX - x;
                     pointDragOffset.y = canvasY - y;
                     break; // Found a point, stop checking
                 }
            }
        }

        function handleCanvasMouseMove(event) {
            if (draggingPoint === null) return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Update point position
            dataPoints[draggingPoint].x = toDataX(x + pointDragOffset.x);
            dataPoints[draggingPoint].y = toDataY(y + pointDragOffset.y);

            drawVisualization(); // Redraw constantly while dragging
        }

        function handleCanvasMouseUp(event) {
            if (draggingPoint !== null) {
                draggingPoint = null;
                trainSVM(); // Retrain after dropping point
            }
        }

         // Helper to toggle class for adding points
        addPointButton.addEventListener('click', () => {
             currentClass = currentClass === 0 ? 1 : 0;
             currentClassText.textContent = currentClass;
             addPointButton.classList.toggle('class1');
        });

        // Load predefined data
        loadLinearDataButton.addEventListener('click', () => {
            dataPoints = [
                { x: 0.2, y: 0.2, class: 0, isSupportVector: false, isMisclassified: false },
                { x: 0.3, y: 0.1, class: 0, isSupportVector: false, isMisclassified: false },
                { x: 0.1, y: 0.3, class: 0, isSupportVector: false, isMisclassified: false },
                { x: 0.4, y: 0.4, class: 0, isSupportVector: false, isMisclassified: false },
                { x: 0.7, y: 0.8, class: 1, isSupportVector: false, isMisclassified: false },
                { x: 0.8, y: 0.9, class: 1, isSupportVector: false, isMisclassified: false },
                { x: 0.9, y: 0.7, class: 1, isSupportVector: false, isMisclassified: false },
                { x: 0.6, y: 0.6, class: 1, isSupportVector: false, isMisclassified: false },
            ];
            trainSVM();
        });

         loadNonlinearDataButton.addEventListener('click', () => {
            dataPoints = [];
            // Concentric circles data (Linear kernel won't work well)
            const numPoints = 50;
            for (let i = 0; i < numPoints; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.3 + 0.1; // Inner circle
                dataPoints.push({
                    x: 0.5 + radius * Math.cos(angle),
                    y: 0.5 + radius * Math.sin(angle),
                    class: 0,
                    isSupportVector: false, isMisclassified: false
                });
                const angle2 = Math.random() * Math.PI * 2;
                const radius2 = Math.random() * 0.3 + 0.4; // Outer circle
                 dataPoints.push({
                    x: 0.5 + radius2 * Math.cos(angle2),
                    y: 0.5 + radius2 * Math.sin(angle2),
                    class: 1,
                    isSupportVector: false, isMisclassified: false
                });
            }
             // Disable nonlinear kernel option explanation since we only implement linear
             if (kernelSelect.value === 'linear') {
                 alert('Note: The current visualization only accurately depicts Linear SVMs. Non-linear data requires a different kernel.');
             }
             kernelSelect.value = 'linear'; // Force linear for visualization
             trainSVM();
         });

        resetDataButton.addEventListener('click', () => {
            dataPoints = [];
            trainSVM();
        });

        kernelSelect.addEventListener('change', (event) => {
            kernelType = event.target.value;
            // In a real app, selecting a non-linear kernel would trigger different logic.
            // Here, it just changes the state variable.
            if (kernelType !== 'linear') {
                 alert('Note: Only Linear kernel visualization is currently implemented. Selecting other kernels will not change the boundary.');
            }
            trainSVM(); // Update visualization based on kernel type (only linear works)
        });

        cSlider.addEventListener('input', (event) => {
            C = parseFloat(event.target.value);
            cValueSpan.textContent = C;
            trainSVM(); // Update visualization based on C (only affects misclassification highlights)
        });

        trainSvmButton.addEventListener('click', () => {
            trainSVM(); // Explicit train button
        });


        // --- Coordinate Transformations ---
        // Map data coordinates (0 to 1) to canvas pixel coordinates
        function toCanvasX(x) { return x * canvas.width; }
        function toCanvasY(y) { return (1 - y) * canvas.height; } // Invert Y axis for typical data plots

        // Map canvas pixel coordinates to data coordinates (0 to 1)
        function toDataX(px) { return px / canvas.width; }
        function toDataY(py) { return 1 - (py / canvas.height); } // Invert Y axis

        // --- Drawing Functions ---
        function drawPoint(point, isSupportVector, isMisclassified) {
            ctx.beginPath();
            ctx.arc(toCanvasX(point.x), toCanvasY(point.y), pointRadius, 0, Math.PI * 2);
            ctx.fillStyle = classColors[point.class];
            ctx.fill();

            if (isSupportVector) {
                ctx.strokeStyle = svHighlightColor;
                ctx.lineWidth = 3;
                ctx.stroke();
            } else if (isMisclassified) {
                 ctx.strokeStyle = misclassifiedHighlightColor;
                 ctx.lineWidth = 2;
                 ctx.stroke();
            }
        }

        function drawLine(m, b, style, width) {
             // Draw line y = m*x + b
             // Need to find start/end points within the canvas bounds (x=[0,1], y=[0,1] in data coords)
             let x1, y1, x2, y2;

             // Handle vertical lines (m is effectively infinite)
             if (Math.abs(m) > 1e6) { // Close to vertical
                 // This simplified y=mx+b form doesn't handle vertical lines well.
                 // A better form is ax+by+c=0. For y=mx+b, a=m, b=-1, c=b.
                 // If b=0 (line is vertical), a = large, c = ?... Need to rethink line representation if vertical lines are possible/needed.
                 // Assuming our simplified model won't produce perfectly vertical lines near canvas edges.
                 // If it did, we'd need to handle x = constant form.
             }

             // Find points where line intersects canvas edges [0,1]x[0,1] in data coords
             const points = [];
             // Left edge (x=0): y = m*0 + b = b
             if (b >= 0 && b <= 1) points.push({ x: 0, y: b });
             // Right edge (x=1): y = m*1 + b = m + b
             if (m + b >= 0 && m + b <= 1) points.push({ x: 1, y: m + b });
             // Bottom edge (y=0): 0 = m*x + b => x = -b/m (if m != 0)
             if (m !== 0) {
                 const x_bottom = -b / m;
                 if (x_bottom >= 0 && x_bottom <= 1) points.push({ x: x_bottom, y: 0 });
             }
              // Top edge (y=1): 1 = m*x + b => x = (1-b)/m (if m != 0)
             if (m !== 0) {
                 const x_top = (1 - b) / m;
                 if (x_top >= 0 && x_top <= 1) points.push({ x: x_top, y: 1 });
            }

            // Need at least two unique points
            if (points.length < 2) return; // Line doesn't intersect the visible data area significantly

            // Filter unique points (due to floating point, allow small tolerance)
            const uniquePoints = [];
            points.forEach(p1 => {
                 if (!uniquePoints.some(p2 => Math.abs(p1.x - p2.x) < 1e-4 && Math.abs(p1.y - p2.y) < 1e-4)) {
                     uniquePoints.push(p1);
                 }
            });

            if (uniquePoints.length < 2) return; // Still not enough unique points

            // Use the first two unique points found that are distinct enough
            x1 = uniquePoints[0].x;
            y1 = uniquePoints[0].y;
            x2 = uniquePoints[1].x;
            y2 = uniquePoints[1].y;


            ctx.beginPath();
            ctx.strokeStyle = style;
            ctx.lineWidth = width;
            // Convert data points to canvas points
            ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
            ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
            ctx.stroke();
        }


        function drawVisualization() {
            if (!canvasRect) return; // Wait for resize to set rect

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background (already set by CSS, but good practice)
            // ctx.fillStyle = '#f8f8f8';
            // ctx.fillRect(0, 0, canvas.width, canvas.height);

            // --- Draw SVM Components (Simplified Simulation) ---
            if (dataPoints.length > 1) {
                 // Simplistic linear boundary simulation: Find average position of each class
                 let avg0x = 0, avg0y = 0, count0 = 0;
                 let avg1x = 0, avg1y = 0, count1 = 0;

                 dataPoints.forEach(p => {
                     if (p.class === 0) { avg0x += p.x; avg0y += p.y; count0++; }
                     else { avg1x += p.x; avg1y += p.y; count1++; }
                 });

                 if (count0 > 0 && count1 > 0) {
                     avg0x /= count0; avg0y /= count0;
                     avg1x /= count1; avg1y /= count1;

                     // Vector from avg0 to avg1: (v_x, v_y) = (avg1x - avg0x, avg1y - avg0y)
                     const vx = avg1x - avg0x;
                     const vy = avg1y - avg0y;

                     // The hyperplane is perpendicular to this vector, passing through the midpoint
                     const midX = (avg0x + avg1x) / 2;
                     const midY = (avg0y + avg1y) / 2;

                     // Hyperplane normal vector (perp to (vx, vy)): (-vy, vx)
                     const normalX = -vy;
                     const normalY = vx;

                     // Equation of line: normalX * (x - midX) + normalY * (y - midY) = 0
                     // normalX * x + normalY * y - (normalX * midX + normalY * midY) = 0
                     // This is the ax + by + c = 0 form, where a=normalX, b=normalY, c=-(normalX*midX + normalY*midY)

                     // To convert to y = mx + b: normalY * y = -normalX * x + (normalX * midX + normalY * midY)
                     // If normalY is not zero: y = (-normalX / normalY) * x + (normalX * midX + normalY * midY) / normalY
                     if (Math.abs(normalY) > 1e-6) {
                         hyperplane.m = -normalX / normalY;
                         hyperplane.b = (normalX * midX + normalY * midY) / normalY;

                         // Draw Hyperplane
                         drawLine(hyperplane.m, hyperplane.b, '#2f8d46', 2); // GeeksforGeeks Green

                         // Find points closest to the hyperplane on each side (simplified SVs)
                         supportVectors = [];
                         let closest0 = null;
                         let minDist0 = Infinity;
                         let closest1 = null;
                         let minDist1 = Infinity;

                         dataPoints.forEach((p, index) => {
                            // Distance from point (px, py) to line ax + by + c = 0 is |a*px + b*py + c| / sqrt(a^2 + b^2)
                            // Our line is normalX * x + normalY * y + c_prime = 0, where c_prime = -(normalX*midX + normalY*midY)
                            const c_prime = -(normalX * midX + normalY * midY);
                            const distance = Math.abs(normalX * p.x + normalY * p.y + c_prime) / Math.sqrt(normalX**2 + normalY**2);

                             if (p.class === 0) {
                                if (distance < minDist0) {
                                    minDist0 = distance;
                                    closest0 = index;
                                }
                             } else { // class 1
                                if (distance < minDist1) {
                                    minDist1 = distance;
                                    closest1 = index;
                                }
                             }
                         });

                         if (closest0 !== null) supportVectors.push(closest0);
                         if (closest1 !== null && closest1 !== closest0) supportVectors.push(closest1); // Avoid duplicates

                         // Calculate margin distance based on simulated SVs
                         // The margin is half the distance between the two separating margin lines.
                         // The margin line passes through the SVs parallel to the hyperplane.
                         // The distance from origin to line ax+by+c=0 is |c|/sqrt(a^2+b^2).
                         // Distance between parallel lines ax+by+c1=0 and ax+by+c2=0 is |c1-c2|/sqrt(a^2+b^2).
                         // The margin lines pass through the support vectors.
                         // For a point (sv_x, sv_y) on the margin line, normalX * sv_x + normalY * sv_y + c_margin = 0
                         // So c_margin = -(normalX * sv_x + normalY * sv_y).
                         // The distance of the margin line from the origin is |-(normalX * sv_x + normalY * sv_y)| / sqrt(normalX^2 + normalY^2)
                         // This is the same as the distance of the SV from the hyperplane.
                         // So the distance of the SV from the hyperplane *is* the distance from the hyperplane to the margin line.
                         // This distance is half the total margin width.
                         // Let marginDistance = minDist0 (or minDist1, should be same in linearly separable case)
                         // Margin line 1 passes through closest0: normalX * x + normalY * y + c_margin0 = 0
                         // c_margin0 = -(normalX * dataPoints[closest0].x + normalY * dataPoints[closest0].y)
                         // Margin line 2 passes through closest1: normalX * x + normalY * y + c_margin1 = 0
                         // c_margin1 = -(normalX * dataPoints[closest1].x + normalY * dataPoints[closest1].y)

                         // Draw Margin Lines
                         // The bias 'b' for the y=mx+b form of the margin line is derived from ax+by+c=0: y = (-a/b)x + (-c/b).
                         // So margin line 1: y = (-normalX / normalY) * x + (-c_margin0 / normalY)
                         // margin line 2: y = (-normalX / normalY) * x + (-c_margin1 / normalY)
                         if (closest0 !== null) {
                            const c_margin0 = -(normalX * dataPoints[closest0].x + normalY * dataPoints[closest0].y);
                             drawLine(hyperplane.m, -c_margin0 / normalY, '#cccccc', 1); // Light grey
                         }
                          if (closest1 !== null && closest1 !== closest0) {
                            const c_margin1 = -(normalX * dataPoints[closest1].x + normalY * dataPoints[closest1].y);
                             drawLine(hyperplane.m, -c_margin1 / normalY, '#cccccc', 1); // Light grey
                         }

                         // Identify Misclassified/Margin-Violating Points (Soft Margin Simulation)
                         misclassifiedPoints = [];
                         dataPoints.forEach((p, index) => {
                            // For ax + by + c = 0, the signed distance is (a*px + b*py + c) / sqrt(a^2 + b^2)
                            // For class 0, the signed distance should be negative. For class 1, it should be positive.
                            // Using our normal vector (normalX, normalY) which points from class 0 towards class 1,
                            // and the bias c_prime, the signed distance is (normalX * p.x + normalY * p.y + c_prime) / norm.
                            // Where norm = sqrt(normalX^2 + normalY^2).
                            // The sign of (normalX * p.x + normalY * p.y + c_prime) determines which side the point is on.
                            // For class 0, this value should be <= 0 (ideally < 0 for hard margin outside margin).
                            // For class 1, this value should be >= 0 (ideally > 0).
                            // The margin boundaries are where this value is -marginDistance and +marginDistance.
                            // A point is misclassified/violates margin if for class 0, value > -marginDistance, or for class 1, value < marginDistance.
                            // In Soft Margin, points *within* the margin are violations too.
                            // Violation occurs if (value * sign_of_class) < marginDistance, where sign_of_class is -1 for class 0, +1 for class 1.
                            // Simpler check: violation if a point is on the wrong side of its margin line.
                            // Margin line for class 0: normalX * x + normalY * y + c_margin0 = 0 (should be on the side where this is < 0)
                            // Margin line for class 1: normalX * x + normalY * y + c_margin1 = 0 (should be on the side where this is > 0)

                             if (closest0 !== null && closest1 !== null) { // Need two SVs for margins
                                const c_margin0 = -(normalX * dataPoints[closest0].x + normalY * dataPoints[closest0].y);
                                const c_margin1 = -(normalX * dataPoints[closest1].x + normalY * dataPoints[closest1].y);

                                // Use average margin distance from hyperplane as threshold for violation
                                const avgMarginDist = (minDist0 + minDist1) / 2; // This assumes the margin lines are equidistant from the hyperplane, which is true for linear SVM.
                                const signedDist = (normalX * p.x + normalY * p.y + c_prime); // Numerator part, sign matters. norm = sqrt(normalX^2 + normalY^2)

                                // Check violation based on scaled signed distance vs margin distance threshold
                                // A point (px, py) is 'correctly' classified if signedDist has same sign as normal vector (or is zero).
                                // Normal points from class 0 side to class 1 side.
                                // If class 0: want signedDist <= 0. Violation if signedDist > -avgMarginDist * norm.
                                // If class 1: want signedDist >= 0. Violation if signedDist < avgMarginDist * norm.
                                // Note: Scaling signedDist by norm gives true distance, but the check relative to a scaled threshold is equivalent.
                                // Let's simplify: points that fall on the wrong side of the hyperplane OR within the margin region.
                                // The margin region for class 0 is between hyperplane and margin0. For class 1, between hyperplane and margin1.
                                // A point is a violation if:
                                // (p.class == 0 AND signedDist > -avgMarginDist * Math.sqrt(normalX**2 + normalY**2) ) OR
                                // (p.class == 1 AND signedDist < avgMarginDist * Math.sqrt(normalX**2 + normalY**2) )
                                // This check is related to the hinge loss (max(0, 1 - y*f(x))). Here, f(x) is the signed distance.
                                // Let's simulate based on side and margin.
                                // Is on Class 0 side if signedDist < 0
                                // Is on Class 1 side if signedDist > 0
                                // Point is within margin if |signedDist| < avgMarginDist * norm
                                // Point is misclassified if it's on the wrong side of the hyperplane (signedDist has wrong sign for class)
                                // Point is a margin violation if it's within the margin OR misclassified.

                                const side = signedDist >= 0 ? 1 : 0; // Which side of the hyperplane the point falls on

                                if (side !== p.class) {
                                     misclassifiedPoints.push(index); // Wrong side
                                } else {
                                    // Check if within margin on correct side
                                    const distNum = Math.abs(signedDist);
                                    const norm = Math.sqrt(normalX**2 + normalY**2);
                                     if (norm > 1e-6 && distNum / norm < avgMarginDist) {
                                         misclassifiedPoints.push(index); // Within margin
                                     }
                                }
                             }
                         });


                     } else {
                         // Not enough points in one or both classes to draw meaningful boundary
                         hyperplane = { m: 0, b: 0 };
                         supportVectors = [];
                         misclassifiedPoints = [];
                     }

                 } else {
                      // Not enough points in one or both classes
                     hyperplane = { m: 0, b: 0 };
                     supportVectors = [];
                     misclassifiedPoints = [];
                 }
            } else {
                // No points to draw anything
                 hyperplane = { m: 0, b: 0 };
                 supportVectors = [];
                 misclassifiedPoints = [];
            }


            // --- Draw Data Points (on top) ---
            // Draw SVs and misclassified points last so they are on top and highlighted
            const regularPoints = dataPoints.map((p, i) => ({ p, i })).filter(({ i }) => supportVectors.indexOf(i) === -1 && misclassifiedPoints.indexOf(i) === -1);
            const svs = dataPoints.map((p, i) => ({ p, i })).filter(({ i }) => supportVectors.indexOf(i) !== -1);
            const misclassified = dataPoints.map((p, i) => ({ p, i })).filter(({ i }) => misclassifiedPoints.indexOf(i) !== -1 && supportVectors.indexOf(i) === -1); // Misclassified but NOT SV

            regularPoints.forEach(({ p }) => drawPoint(p, false, false));
            misclassified.forEach(({ p }) => drawPoint(p, false, true)); // Draw misclassified (not SV)
            svs.forEach(({ p }) => drawPoint(p, true, false)); // Draw SVs (they might also be misclassified in soft margin, but SV highlight takes precedence)


             // --- Optional: Hover effects (Requires tracking mouse position and hit testing) ---
             // This adds complexity and is omitted for functional precision on core features.
             // A real implementation would add mousemove listener, check if mouse is over a line/point,
             // store the hovered element, and trigger a redraw with hover style.

        }

        // --- SVM Training Function (Simplified Simulation) ---
        // This function calculates the simplified boundary and highlights.
        function trainSVM() {
             // In a real app, this would run an optimization algorithm.
             // Here, it just triggers the drawing logic based on the current data and parameters (C affects misclassified highlight).
             // No actual SVM calculation happens here.
             drawVisualization();
        }


        // --- Resize Handler ---
        function resizeCanvas() {
            canvasRect = canvas.parentElement.getBoundingClientRect();
            canvas.width = canvasRect.width;
            canvas.height = canvasRect.height;
            drawVisualization(); // Redraw on resize
        }

        // Initial setup
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', handleCanvasMouseUp); // End drag if mouse leaves canvas

        // Initial draw
        resizeCanvas();


    </script>

</body>
</html>
