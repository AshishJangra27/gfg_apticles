
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVM Visual Explorer</title>
    <style>
        /* GeeksforGeeks Theme */
        :root {
            --gfg-green: #2f8d46;
            --dark-text: #222222;
            --white-bg: #ffffff;
            --light-gray: #f0f0f0;
            --border-color: #cccccc;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Prevent scrolling */
            background-color: var(--white-bg);
            color: var(--dark-text);
        }

        header {
            background-color: var(--gfg-green);
            color: var(--white-bg);
            padding: 10px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .container {
            display: flex;
            flex-grow: 1; /* Occupy remaining vertical space */
            overflow: hidden; /* Prevent container scrolling */
        }

        main {
            flex-grow: 1; /* Take up most space */
            flex-basis: 75%; /* Target ~75% width */
            position: relative; /* For canvas absolute positioning */
            overflow: hidden;
            background-color: var(--light-gray); /* Background for the plot area */
        }

        canvas {
            display: block;
            background-color: var(--white-bg);
            border: 1px solid var(--border-color);
            box-sizing: border-box;
        }

        aside {
            flex-basis: 25%; /* Target ~25% width */
            min-width: 250px; /* Minimum width for controls */
            max-width: 350px; /* Maximum width for controls */
            padding: 15px;
            background-color: var(--white-bg);
            border-left: 1px solid var(--border-color);
            overflow-y: auto; /* Allow scrolling if controls exceed height */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--light-gray);
        }

        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--gfg-green);
            font-size: 1.1em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        button, select, input[type="range"], input[type="radio"] {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--dark-text);
            background-color: var(--white-bg);
            cursor: pointer;
            width: 100%; /* Make controls full width */
            box-sizing: border-box;
            appearance: none; /* Reset default styles */
            -webkit-appearance: none;
        }

        button {
             background-color: var(--gfg-green);
             color: var(--white-bg);
             border-color: var(--gfg-green);
             font-weight: bold;
             transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #256f37; /* Darker green */
            border-color: #256f37;
        }

        button:active {
             background-color: #1a552a; /* Even darker green */
        }

        input[type="range"] {
            padding: 0;
            margin-bottom: 5px;
            height: 25px;
            background: transparent; /* Hide default track */
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: var(--light-gray);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid var(--gfg-green);
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--gfg-green);
            cursor: pointer;
            margin-top: -5.5px; /* Center thumb vertically */
        }

        input[type="range"]:disabled::-webkit-slider-thumb {
             background: var(--border-color);
             border-color: var(--border-color);
             cursor: not-allowed;
        }

        input[type="radio"] {
            width: auto; /* Auto width for radio buttons */
            margin-right: 5px;
            vertical-align: middle;
            margin-bottom: 5px; /* Adjust margin */
        }

        .radio-group label {
            display: inline-block; /* Arrange radio buttons inline */
            margin-right: 15px;
            font-weight: normal;
            font-size: 0.9em;
            margin-bottom: 5px; /* Match margin of radios */
        }

        .slider-value {
            font-size: 0.8em;
            text-align: right;
            margin-top: -5px;
            margin-bottom: 10px;
            color: #555;
        }

        footer {
            background-color: var(--dark-text);
            color: var(--white-bg);
            padding: 10px;
            text-align: center;
            font-size: 0.8em;
            flex-shrink: 0; /* Prevent shrinking */
        }

        footer a {
            color: var(--gfg-green);
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .metrics-area {
            position: fixed;
            bottom: 45px; /* Above the footer */
            right: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--border-color);
            padding: 10px;
            font-size: 0.9em;
            z-index: 100;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .metrics-area p {
            margin: 5px 0;
        }

         /* Style for class selection toggle for new points */
        #point-class-selector {
             margin-bottom: 15px;
             padding-bottom: 15px;
             border-bottom: 1px solid var(--light-gray);
        }
         #point-class-selector h3 {
             margin-bottom: 10px;
         }


    </style>
</head>
<body>
    <header>
        SVM Visual Explorer
    </header>

    <div class="container">
        <main id="visualization-area">
            <canvas id="svmCanvas"></canvas>
        </main>

        <aside id="control-panel">
            <div id="point-class-selector" class="control-group">
                <h3>Add Point Class</h3>
                 <div class="radio-group">
                    <label><input type="radio" name="addPointClass" value="1" checked> Class 1 </label>
                    <label><input type="radio" name="addPointClass" value="-1"> Class -1 </label>
                 </div>
                 <button id="clearDataBtn">Clear Data</button>
            </div>

            <div class="control-group">
                <h3>Generate Data</h3>
                <button id="generateLinearDataBtn">Linearly Separable</button>
                <button id="generateCircleDataBtn">Concentric Circles</button>
                 <button id="generateOverlapDataBtn">Overlapping Data</button>
            </div>

            <div class="control-group">
                <h3>SVM Mode</h3>
                 <div class="radio-group">
                    <label><input type="radio" name="svmMode" value="hard" checked> Hard Margin </label>
                    <label><input type="radio" name="svmMode" value="soft"> Soft Margin </label>
                 </div>
            </div>

            <div class="control-group">
                <h3>Kernel</h3>
                 <div class="radio-group">
                    <label><input type="radio" name="kernelType" value="linear" checked> Linear </label>
                    <!-- Placeholder UI for other kernels - implementation limited to Linear -->
                    <label><input type="radio" name="kernelType" value="rbf" disabled title="Linear kernel only in this version"> RBF </label>
                     <label><input type="radio" name="kernelType" value="poly" disabled title="Linear kernel only in this version"> Poly </label>
                 </div>
            </div>

            <div class="control-group">
                <h3>Parameters</h3>
                <label for="cSlider">C (Soft Margin only)</label>
                <input type="range" id="cSlider" min="0.1" max="10" value="1" step="0.1" disabled>
                 <div id="cValue" class="slider-value">Value: 1.0</div>

                 <!-- Placeholder UI for kernel parameters - implementation limited to Linear -->
                 <label for="gammaSlider">Gamma (RBF only)</label>
                <input type="range" id="gammaSlider" min="0.01" max="1" value="0.1" step="0.01" disabled>
                 <div id="gammaValue" class="slider-value">Value: 0.1</div>

                 <label for="degreeSlider">Degree (Poly only)</label>
                <input type="range" id="degreeSlider" min="1" max="5" value="2" step="1" disabled>
                 <div id="degreeValue" class="slider-value">Value: 2</div>
            </div>

            <button id="trainBtn">Train SVM</button>

        </aside>
    </div>

    <div class="metrics-area" id="metricsArea">
         <p><strong>Metrics</strong></p>
        <p>Margin Width: <span id="marginWidth">N/A</span></p>
        <p>Support Vectors: <span id="svCount">N/A</span></p>
        <p id="misclassificationMetric">Misclassifications: <span id="misclassificationCount">N/A</span></p>
    </div>

    <footer>
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        const canvas = document.getElementById('svmCanvas');
        const ctx = canvas.getContext('2d');
        const mainArea = document.getElementById('visualization-area');

        // Controls
        const trainBtn = document.getElementById('trainBtn');
        const clearDataBtn = document.getElementById('clearDataBtn');
        const generateLinearDataBtn = document.getElementById('generateLinearDataBtn');
        const generateCircleDataBtn = document.getElementById('generateCircleDataBtn');
         const generateOverlapDataBtn = document.getElementById('generateOverlapDataBtn');
        const addPointClassRadios = document.querySelectorAll('input[name="addPointClass"]');
        const svmModeRadios = document.querySelectorAll('input[name="svmMode"]');
        const kernelTypeRadios = document.querySelectorAll('input[name="kernelType"]');
        const cSlider = document.getElementById('cSlider');
        const cValueSpan = document.getElementById('cValue');
         const gammaSlider = document.getElementById('gammaSlider'); // UI only
         const gammaValueSpan = document.getElementById('gammaValue'); // UI only
         const degreeSlider = document.getElementById('degreeSlider'); // UI only
         const degreeValueSpan = document.getElementById('degreeValue'); // UI only

        // Metrics
        const marginWidthSpan = document.getElementById('marginWidth');
        const svCountSpan = document.getElementById('svCount');
        const misclassificationCountSpan = document.getElementById('misclassificationCount');
         const misclassificationMetricP = document.getElementById('misclassificationMetric');


        // State Variables
        let points = []; // Array of {x, y, class}
        let trainedSVM = null; // Stores {w, b, supportVectors, margin, misclassifications} after training
        let currentAddPointClass = 1; // Default class for points added by click

        // Canvas coordinate system setup
        const dataXMin = -10;
        const dataXMax = 10;
        const dataYMin = -10;
        const dataYMax = 10;
        let canvasWidth, canvasHeight;

        // SVM Parameters
        const svmParams = {
            mode: 'hard', // 'hard' or 'soft'
            kernel: 'linear', // 'linear', 'rbf', 'poly' (only 'linear' implemented)
            C: 1.0, // Soft margin penalty
            gamma: 0.1, // RBF parameter (UI only)
            degree: 2, // Poly parameter (UI only)
            iterations: 1000, // Iterations for the simplified training
            learningRate: 0.01, // Learning rate for the simplified training
             tolerance: 1e-3 // Tolerance for identifying support vectors
        };

        // --- Coordinate Transformations ---

        function dataToCanvas(dataX, dataY) {
            const canvasX = (dataX - dataXMin) / (dataXMax - dataXMin) * canvasWidth;
            const canvasY = canvasHeight - (dataY - dataYMin) / (dataYMax - dataYMin) * canvasHeight; // Y is inverted
            return { x: canvasX, y: canvasY };
        }

        function canvasToData(canvasX, canvasY) {
            const dataX = (canvasX / canvasWidth) * (dataXMax - dataXMin) + dataXMin;
            const dataY = (1 - canvasY / canvasHeight) * (dataYMax - dataYMin) + dataYMin; // Y is inverted
            return { x: dataX, y: dataY };
        }

        // --- Drawing Functions ---

        function resizeCanvas() {
            canvasWidth = mainArea.clientWidth;
            canvasHeight = mainArea.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            draw(); // Redraw content after resize
        }

        function drawPoint(point, isSV = false, isMisclassified = false) {
            const { x, y, class: pointClass } = point;
            const { x: cx, y: cy } = dataToCanvas(x, y);

            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);

            if (pointClass === 1) {
                ctx.fillStyle = 'blue';
            } else {
                ctx.fillStyle = 'red';
            }
            ctx.fill();

             // Draw border
            ctx.strokeStyle = var(--dark-text);
            ctx.lineWidth = isSV ? 3 : 1; // Thicker border for SVs
            ctx.stroke();

             // Visual cue for misclassification
            if (isMisclassified) {
                ctx.strokeStyle = 'orange'; // Highlight misclassified
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

         function fillClassificationRegion(w, b) {
             if (!w || w.length !== 2 || typeof b !== 'number') return; // Basic validation

             const step = 10; // Size of grid cells (pixels)
             for (let i = 0; i < canvasWidth; i += step) {
                 for (let j = 0; j < canvasHeight; j += step) {
                     const { x, y } = canvasToData(i + step/2, j + step/2);
                     const decision = w[0] * x + w[1] * y + b;

                     ctx.fillStyle = decision > 0 ? 'rgba(0, 0, 255, 0.05)' : 'rgba(255, 0, 0, 0.05)'; // Light translucent color
                     ctx.fillRect(i, j, step, step);
                 }
             }
         }


        function drawBoundary(w, b, type = 'decision') { // type: 'decision', 'margin1', 'margin-1'
            if (!w || w.length !== 2) return;

            // Equation of line: w[0]*x + w[1]*y + b = offset
            // offset is 0 for decision, 1 for margin1, -1 for margin-1
            const offset = type === 'decision' ? 0 : (type === 'margin1' ? 1 : -1);

            // Find two points on the line within canvas bounds
            let p1 = null, p2 = null;

            // Check intersection with vertical canvas edges (x = dataXMin, x = dataXMax)
            // w[0]*dataX + w[1]*y + b = offset  => y = (offset - b - w[0]*dataX) / w[1]
            if (Math.abs(w[1]) > 1e-6) { // Avoid division by zero
                let y1 = (offset - b - w[0] * dataXMin) / w[1];
                let y2 = (offset - b - w[0] * dataXMax) / w[1];
                if (y1 >= dataYMin && y1 <= dataYMax) p1 = dataToCanvas(dataXMin, y1);
                if (y2 >= dataYMin && y2 <= dataYMax) {
                    if (p1) p2 = dataToCanvas(dataXMax, y2); else p1 = dataToCanvas(dataXMax, y2);
                }
            }

            // Check intersection with horizontal canvas edges (y = dataYMin, y = dataYMax)
            // w[0]*x + w[1]*dataY + b = offset => x = (offset - b - w[1]*dataY) / w[0]
            if (Math.abs(w[0]) > 1e-6) { // Avoid division by zero
                let x1 = (offset - b - w[1] * dataYMin) / w[0];
                let x2 = (offset - b - w[1] * dataYMax) / w[0];
                 if (x1 >= dataXMin && x1 <= dataXMax) {
                     const p = dataToCanvas(x1, dataYMin);
                     if (!p1) p1 = p; else if (!p2 && (Math.abs(p.x - p1.x) > 1e-6 || Math.abs(p.y - p1.y) > 1e-6)) p2 = p;
                 }
                 if (x2 >= dataXMin && x2 <= dataXMax) {
                     const p = dataToCanvas(x2, dataYMax);
                     if (!p1) p1 = p; else if (!p2 && (Math.abs(p.x - p1.x) > 1e-6 || Math.abs(p.y - p1.y) > 1e-6)) p2 = p;
                 }
            }

            if (p1 && p2) {
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = type === 'decision' ? var(--gfg-green) : '#555'; // Green for decision, gray for margin
                ctx.lineWidth = type === 'decision' ? 2 : 1;
                ctx.setLineDash(type === 'decision' ? [] : [5, 5]); // Dashed for margin
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
            } else if (Math.abs(w[0]) < 1e-6 && Math.abs(w[1]) < 1e-6) {
                 // w is zero, boundary is undefined or covers everything. Don't draw.
            } else if (Math.abs(w[1]) < 1e-6) { // Vertical line: x = (offset - b) / w[0]
                 const dataX = (offset - b) / w[0];
                 if (dataX >= dataXMin && dataX <= dataXMax) {
                     const cp1 = dataToCanvas(dataX, dataYMin);
                     const cp2 = dataToCanvas(dataX, dataYMax);
                      ctx.beginPath();
                     ctx.moveTo(cp1.x, cp1.y);
                     ctx.lineTo(cp2.x, cp2.y);
                      ctx.strokeStyle = type === 'decision' ? var(--gfg-green) : '#555';
                     ctx.lineWidth = type === 'decision' ? 2 : 1;
                     ctx.setLineDash(type === 'decision' ? [] : [5, 5]);
                     ctx.stroke();
                     ctx.setLineDash([]);
                 }
            } else if (Math.abs(w[0]) < 1e-6) { // Horizontal line: y = (offset - b) / w[1]
                 const dataY = (offset - b) / w[1];
                 if (dataY >= dataYMin && dataY <= dataYMax) {
                      const cp1 = dataToCanvas(dataXMin, dataY);
                      const cp2 = dataToCanvas(dataXMax, dataY);
                      ctx.beginPath();
                     ctx.moveTo(cp1.x, cp1.y);
                     ctx.lineTo(cp2.x, cp2.y);
                      ctx.strokeStyle = type === 'decision' ? var(--gfg-green) : '#555';
                     ctx.lineWidth = type === 'decision' ? 2 : 1;
                     ctx.setLineDash(type === 'decision' ? [] : [5, 5]);
                     ctx.stroke();
                     ctx.setLineDash([]);
                 }
            }
             // Note: If p1 and p2 are the same point (boundary point), line won't draw. This is fine.
        }


        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas

            if (trainedSVM && trainedSVM.w && trainedSVM.b !== null) {
                // Draw classification regions
                 fillClassificationRegion(trainedSVM.w, trainedSVM.b);

                // Draw boundary and margins
                drawBoundary(trainedSVM.w, trainedSVM.b, 'decision');
                drawBoundary(trainedSVM.w, trainedSVM.b, 'margin1');
                drawBoundary(trainedSVM.w, trainedSVM.b, 'margin-1');
            }

            // Draw points
            points.forEach(point => {
                 const isSV = trainedSVM && trainedSVM.supportVectors && trainedSVM.supportVectors.some(sv => sv.x === point.x && sv.y === point.y && sv.class === point.class);
                 const isMisclassified = trainedSVM && trainedSVM.misclassifiedPoints && trainedSVM.misclassifiedPoints.some(mp => mp.x === point.x && mp.y === point.y && mp.class === point.class);
                drawPoint(point, isSV, isMisclassified);
            });
        }

        // --- Data Management ---

        function addPoint(dataX, dataY, pointClass) {
            points.push({ x: dataX, y: dataY, class: pointClass });
            draw(); // Redraw after adding point
        }

        function clearData() {
            points = [];
            trainedSVM = null; // Clear trained result
            updateMetrics(); // Clear metrics display
            draw(); // Redraw empty canvas
        }

        function generateLinearData() {
            clearData();
             const numPoints = 50;
            for (let i = 0; i < numPoints / 2; i++) {
                // Class 1 (blue)
                addPoint(Math.random() * 5 - 8, Math.random() * 5 - 8, 1);
                // Class -1 (red)
                addPoint(Math.random() * 5 + 3, Math.random() * 5 + 3, -1);
            }
             draw();
        }

        function generateCircleData() {
            clearData();
             const numPoints = 80;
             const innerRadius = 3;
             const outerRadius = 7;
             const center = {x: 0, y: 0};

            for (let i = 0; i < numPoints / 2; i++) {
                // Class 1 (blue) - Inner circle
                let r = Math.random() * innerRadius;
                let angle = Math.random() * Math.PI * 2;
                addPoint(center.x + r * Math.cos(angle), center.y + r * Math.sin(angle), 1);

                // Class -1 (red) - Outer ring
                r = Math.random() * (outerRadius - innerRadius) + innerRadius;
                angle = Math.random() * Math.PI * 2;
                addPoint(center.x + r * Math.cos(angle), center.y + r * Math.sin(angle), -1);
            }
             draw();
        }

         function generateOverlapData() {
            clearData();
             const numPoints = 80;
             const center1 = {x: -4, y: -4};
             const center2 = {x: 4, y: 4};
             const stdDev = 3; // Larger std dev for overlap

             for (let i = 0; i < numPoints / 2; i++) {
                // Class 1 (blue) - Gaussian blob
                addPoint(center1.x + (Math.random() - 0.5) * 2 * stdDev, center1.y + (Math.random() - 0.5) * 2 * stdDev, 1);

                // Class -1 (red) - Gaussian blob
                addPoint(center2.x + (Math.random() - 0.5) * 2 * stdDev, center2.y + (Math.random() - 0.5) * 2 * stdDev, -1);
            }
             draw();
         }


        // --- SVM Training Logic (Simplified Iterative) ---

        function trainSVM() {
            if (points.length === 0) {
                trainedSVM = null;
                updateMetrics();
                draw();
                return;
            }

            // Initialize w and b
            let w = [0, 0];
            let b = 0;
            const N = points.length;

            // Simple iterative optimization (Subgradient-like)
            for (let iter = 0; iter < svmParams.iterations; iter++) {
                // Shuffle points for stochastic gradient
                 const shuffledPoints = points.sort(() => Math.random() - 0.5);

                shuffledPoints.forEach(point => {
                    const x = [point.x, point.y];
                    const y = point.class;
                    const margin = y * (w[0] * x[0] + w[1] * x[1] + b);

                    if (svmParams.mode === 'hard') {
                        // Update only if misclassified or violates margin
                        if (margin < 1) {
                            w[0] = w[0] + svmParams.learningRate * y * x[0];
                            w[1] = w[1] + svmParams.learningRate * y * x[1];
                            b = b + svmParams.learningRate * y;
                        }
                    } else { // Soft Margin
                        // Update using the hinge loss gradient
                        // Gradient of ||w||^2/2 + C * sum(max(0, 1 - margin_i))
                        // w gradient: w - C * sum(y_i * x_i for violations)
                        // b gradient: -C * sum(y_i for violations)
                        const hingeLossGradient = margin < 1 ? y : 0;

                        w[0] = w[0] - svmParams.learningRate * w[0] + svmParams.learningRate * svmParams.C * hingeLossGradient * x[0];
                        w[1] = w[1] - svmParams.learningRate * w[1] + svmParams.learningRate * svmParams.C * hingeLossGradient * x[1];
                        b = b + svmParams.learningRate * svmParams.C * hingeLossGradient;
                    }
                });
            }

            // After training, calculate metrics and identify SVs
            let supportVectors = [];
            let misclassifiedPoints = [];
            let misclassificationCount = 0;

            points.forEach(point => {
                 const x = [point.x, point.y];
                 const y = point.class;
                const decision = w[0] * x[0] + w[1] * x[1] + b;
                const margin = y * decision;

                 // Identify Support Vectors: points on or inside the margin (within tolerance)
                 // For hard margin, margin should be ~1. For soft margin, margin <= 1 + tolerance
                 if (margin <= 1 + svmParams.tolerance) {
                    supportVectors.push(point);
                 }

                 // Identify misclassified points
                 if (margin < 0) {
                     misclassifiedPoints.push(point);
                     misclassificationCount++;
                 }
            });

            // Calculate margin width: 2 / ||w||
            const wMag = Math.sqrt(w[0]*w[0] + w[1]*w[1]);
            const marginWidth = wMag > 1e-6 ? (2 / wMag) : Infinity; // Avoid division by zero

            trainedSVM = {
                w: w,
                b: b,
                supportVectors: supportVectors,
                marginWidth: marginWidth,
                misclassifiedPoints: misclassifiedPoints,
                misclassificationCount: misclassificationCount
            };

            updateMetrics();
            draw();
        }

        function updateMetrics() {
            if (trainedSVM) {
                marginWidthSpan.textContent = trainedSVM.marginWidth === Infinity ? 'Infinity' : trainedSVM.marginWidth.toFixed(2);
                svCountSpan.textContent = trainedSVM.supportVectors.length;
                misclassificationCountSpan.textContent = trainedSVM.misclassificationCount;
            } else {
                marginWidthSpan.textContent = 'N/A';
                svCountSpan.textContent = 'N/A';
                misclassificationCountSpan.textContent = 'N/A';
            }

             // Show/hide misclassification metric based on mode
             if (svmParams.mode === 'hard') {
                  misclassificationMetricP.style.display = 'none';
             } else {
                  misclassificationMetricP.style.display = 'block';
             }
        }

        // --- Event Listeners ---

        window.addEventListener('resize', resizeCanvas);

        // Canvas click to add points
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;
            const { x: dataX, y: dataY } = canvasToData(canvasX, canvasY);

            addPoint(dataX, dataY, currentAddPointClass);
        });

        // Control Panel Event Listeners
        trainBtn.addEventListener('click', trainSVM);
        clearDataBtn.addEventListener('click', clearData);
        generateLinearDataBtn.addEventListener('click', generateLinearData);
        generateCircleDataBtn.addEventListener('click', generateCircleData);
         generateOverlapDataBtn.addEventListener('click', generateOverlapData);


        addPointClassRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                currentAddPointClass = parseInt(event.target.value, 10);
            });
        });

        svmModeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                svmParams.mode = event.target.value;
                // Enable/disable C slider based on mode
                cSlider.disabled = svmParams.mode === 'hard';
                 updateMetrics(); // Update metric visibility
                // Re-train automatically or wait for button click? Brief says 'Train SVM' button.
                // trainSVM(); // Optional: auto-retrain on mode change
            });
        });

         // Handle Kernel selection (UI only, implementation limited)
         kernelTypeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                 //svmParams.kernel = event.target.value; // Keep as linear for now
                 // Disable kernel-specific sliders if not linear
                 const isLinear = event.target.value === 'linear';
                 gammaSlider.disabled = true; // Always disabled as RBF not implemented
                 degreeSlider.disabled = true; // Always disabled as Poly not implemented

                 if (!isLinear) {
                     alert("Only Linear kernel is implemented in this version.");
                     // Revert selection back to linear in UI
                     document.querySelector('input[name="kernelType"][value="linear"]').checked = true;
                 }
            });
         });


        cSlider.addEventListener('input', (event) => {
            svmParams.C = parseFloat(event.target.value);
            cValueSpan.textContent = `Value: ${svmParams.C.toFixed(1)}`;
        });

         // Kernel parameter sliders (UI updates only)
         gammaSlider.addEventListener('input', (event) => {
             svmParams.gamma = parseFloat(event.target.value);
             gammaValueSpan.textContent = `Value: ${svmParams.gamma.toFixed(2)}`;
         });

         degreeSlider.addEventListener('input', (event) => {
             svmParams.degree = parseInt(event.target.value, 10);
             degreeValueSpan.textContent = `Value: ${svmParams.degree}`;
         });


        // Initial Setup
        resizeCanvas(); // Set initial canvas size
        generateLinearData(); // Load default data
        updateMetrics(); // Initialize metrics display

        // Trigger initial draw once everything is set up
        window.onload = draw; // Ensure initial draw after images (if any) or layout settles (though no images here)
        // Or just call draw immediately after setup:
        // draw(); // Better for purely JS/CSS/HTML page
        // Let's rely on resizeCanvas() and generateLinearData() to call draw initially.


    </script>
</body>
</html>
