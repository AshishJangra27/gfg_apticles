
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVM Visual Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
            background-color: #ffffff;
            color: #222222;
            display: grid;
            grid-template-areas:
                "header header"
                "controls visualization"
                "footer footer";
            grid-template-rows: 10% 85% 5%; /* Adjust slightly to make sure everything fits, footer small */
            grid-template-columns: 30% 70%;
            height: 100vh; /* Ensure full viewport height */
            overflow: hidden; /* Prevent scrolling */
        }

        #header {
            grid-area: header;
            background-color: #2f8d46; /* GeeksforGeeks Green */
            color: #ffffff;
            padding: 0 20px;
            display: flex;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
        }

        #controls {
            grid-area: controls;
            padding: 20px;
            overflow-y: auto; /* Allow scrolling if controls exceed height */
            border-right: 1px solid #eee; /* Subtle separator */
        }

        #visualization {
            grid-area: visualization;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative; /* Needed for canvas positioning/sizing */
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #eee;
            display: block; /* Remove extra space below canvas */
        }

        #footer {
            grid-area: footer;
            background-color: #f0f0f0; /* Light grey footer */
            color: #222222;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            border-top: 1px solid #eee;
        }

        #footer a {
            color: #2f8d46;
            text-decoration: none;
            margin: 0 10px;
        }

        #footer a:hover {
            text-decoration: underline;
        }

        /* Control Panel Styling */
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #2f8d46;
        }

        button {
            display: inline-block;
            margin: 5px;
            padding: 8px 15px;
            background-color: #ffffff;
            color: #2f8d46;
            border: 1px solid #2f8d46;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        button:disabled {
             opacity: 0.5;
             cursor: not-allowed;
        }

        button.active {
            background-color: #2f8d46;
            color: #ffffff;
        }

        button:hover:not(.active):not(:disabled) {
            background-color: #e0ffe0; /* Light hover effect */
        }

        input[type="range"] {
             -webkit-appearance: none; /* Override default CSS styles */
             appearance: none;
             width: calc(100% - 10px); /* Adjust width considering margin */
             height: 8px;
             background: #eee;
             outline: none;
             opacity: 0.9; /* Less transparent by default */
             -webkit-transition: .2s;
             transition: opacity .2s;
             margin: 10px 5px;
             border-radius: 5px;
        }

        input[type="range"]:hover {
             opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
             -webkit-appearance: none;
             appearance: none;
             width: 20px;
             height: 20px;
             background: #2f8d46;
             cursor: pointer;
             border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
             width: 20px;
             height: 20px;
             background: #2f8d46;
             cursor: pointer;
             border-radius: 50%;
        }

         label {
            display: block;
            margin: 10px 5px 5px;
            font-size: 0.9em;
            color: #555;
         }

         #c-parameter-control {
             display: none; /* Hidden by default for Hard Margin */
         }

         #c-value-display {
             font-weight: bold;
             margin-left: 5px;
             color: #222;
         }

         /* Canvas specific styles for points/lines can be handled by JS draw calls */
    </style>
</head>
<body>
    <div id="header">
        SVM Visual Explorer
    </div>

    <div id="controls">
        <div class="control-group">
            <h3>Data Selection</h3>
            <button data-dataset="linearlySeparable" class="active">Linearly Separable</button>
            <button data-dataset="slightlyOverlapping">Slightly Overlapping</button>
            <button data-dataset="circles">Non-linear (Circles)</button>
            <button data-dataset="xor">Non-linear (XOR)</button>
        </div>

        <div class="control-group">
            <h3>Margin Type</h3>
            <button data-margin="hard" class="active">Hard Margin</button>
            <button data-margin="soft">Soft Margin</button>
        </div>

        <div class="control-group" id="c-parameter-control">
            <h3>C Parameter (Soft Margin)</h3>
            <label for="c-slider">Value: <span id="c-value-display">1.0</span></label>
            <input type="range" id="c-slider" min="0.1" max="100" value="1" step="0.1">
        </div>

        <div class="control-group">
            <h3>Kernel Selection</h3>
            <button data-kernel="linear" class="active">Linear</button>
            <button data-kernel="rbf">RBF</button>
        </div>
    </div>

    <div id="visualization">
        <canvas id="svmCanvas"></canvas>
    </div>

    <div id="footer">
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <span>|</span>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </div>

    <script>
        // --- Configuration ---
        const DATA_RANGE = { x: [-10, 10], y: [-10, 10] }; // Coordinate range for data
        const POINT_RADIUS = 4;
        const SV_RADIUS = 6; // Slightly larger for Support Vectors
        const MISCLASSIFIED_COLOR = '#ff4c4c'; // Reddish for misclassified
        const CLASS_COLORS = ['#2f8d46', '#007bff']; // Green, Blue
        const HYPERPLANE_COLOR = '#222222'; // Dark
        const MARGIN_COLOR = '#888888'; // Grey
        const BACKGROUND_COLORS = ['rgba(47, 141, 70, 0.1)', 'rgba(0, 123, 255, 0.1)']; // Faded colors for regions
        const GRID_DENSITY = 40; // Number of steps across the data range for background grid

        // --- DOM Elements ---
        const canvas = document.getElementById('svmCanvas');
        const ctx = canvas.getContext('2d');
        const controls = document.getElementById('controls');
        const cParameterControl = document.getElementById('c-parameter-control');
        const cSlider = document.getElementById('c-slider');
        const cValueDisplay = document.getElementById('c-value-display');

        // --- State ---
        let currentDataset = 'linearlySeparable';
        let currentMarginType = 'hard';
        let currentC = 1; // Matches default slider value (will be mapped to discrete values)
        let currentKernel = 'linear';

        let currentData = [];
        let currentSVM = null; // Stores pre-calculated solution for current state

        // --- Pre-calculated Data & Solutions ---

        // Define simplified datasets
        const datasets = {
            linearlySeparable: [
                { x: -5, y: -2, label: 0 }, { x: -3, y: -4, label: 0 }, { x: -4, y: -1, label: 0 },
                { x: 5, y: 2, label: 1 }, { x: 3, y: 4, label: 1 }, { x: 4, y: 1, label: 1 },
                 { x: -6, y: -3, label: 0 }, { x: -2, y: -5, label: 0 },
                 { x: 6, y: 3, label: 1 }, { x: 2, y: 5, label: 1 },
                 { x: -4.5, y: -3.5, label: 0 }, { x: 4.5, y: 3.5, label: 1}
            ],
            slightlyOverlapping: [
                { x: -5, y: -2, label: 0 }, { x: -3, y: -4, label: 0 }, { x: -4, y: -1, label: 0 },
                { x: 5, y: 2, label: 1 }, { x: 3, y: 4, label: 1 }, { x: 4, y: 1, label: 1 },
                { x: -1, y: 1, label: 0 }, { x: 1, y: -1, label: 1 }, // Overlapping points
                 { x: -0.5, y: 0.5, label: 0 }, { x: 0.5, y: -0.5, label: 1 }
            ],
             circles: [
                { x: 0, y: 0, label: 0 }, { x: 1, y: 0, label: 0 }, { x: 0, y: 1, label: 0 },
                { x: 5, y: 5, label: 1 }, { x: 6, y: 5, label: 1 }, { x: 5, y: 6, label: 1 },
                 { x: -1, y: 0, label: 0 }, { x: 0, y: -1, label: 0 }, // Inner circle
                { x: 7, y: 5, label: 1 }, { x: 5, y: 7, label: 1 }, { x: 6, y: 6, label: 1 }, // Outer circle
                 { x: 2, y: 2, label: 0 }, { x: 3, y: 3, label: 0 }, // More inner
                 { x: 4, y: 4, label: 1 }, { x: 4.5, y: 4.5, label: 1 }, // More outer
                 { x: 1.5, y: 1.5, label: 0 }, { x: 5.5, y: 5.5, label: 1 },
                 { x: 0.5, y: 0.5, label: 0 }, { x: 6.5, y: 6.5, label: 1 }
            ],
            xor: [
                { x: -5, y: 5, label: 0 }, { x: 5, y: -5, label: 0 },
                { x: -5, y: -5, label: 1 }, { x: 5, y: 5, label: 1 },
                 { x: -4, y: 4, label: 0 }, { x: 4, y: -4, label: 0 },
                { x: -4, y: -4, label: 1 }, { x: 4, y: 4, label: 1 },
                 { x: -6, y: 6, label: 0 }, { x: 6, y: -6, label: 0 },
                { x: -6, y: -6, label: 1 }, { x: 6, y: 6, label: 1 },
                 { x: -3, y: 3, label: 0 }, { x: 3, y: -3, label: 0 },
                { x: -3, y: -3, label: 1 }, { x: 3, y: 3, label: 1 }
            ]
        };

         // Generates a simplified grid for the circles dataset (RBF kernel)
         function generateCircularGrid(centerX, centerY, boundaryRadius) {
             const grid = [];
             const step = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Grid density

             for (let dx = DATA_RANGE.x[0]; dx <= DATA_RANGE.x[1]; dx += step) {
                 for (let dy = DATA_RANGE.y[0]; dy <= DATA_RANGE.y[1]; dy += step) {
                     const value = (dx - centerX)**2 + (dy - centerY)**2 - boundaryRadius**2;
                     const label = value > 0 ? 1 : 0; // Sign determines class
                     grid.push({ x: dx, y: dy, label: label });
                 }
             }
             return grid;
         }

         // Generates a simplified grid for the XOR dataset (RBF kernel)
         function generateXORGrid() {
             const grid = [];
             const step = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Grid density

             for (let dx = DATA_RANGE.x[0]; dx <= DATA_RANGE.x[1]; dx += step) {
                 for (let dy = DATA_RANGE.y[0]; dy <= DATA_RANGE.y[1]; dy += step) {
                      const value = dx * dy; // Simplified f(x,y) for XOR
                     const label = value > 0 ? 1 : 0; // Sign determines class
                     grid.push({ x: dx, y: dy, label: label });
                 }
             }
             return grid;
         }

        // Simple helper for RBF on slightly overlapping data (linearish boundary)
         function generateLinearishRBFGrid() {
             const grid = [];
             const step = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Grid density

             for (let dx = DATA_RANGE.x[0]; dx <= DATA_RANGE.x[1]; dx += step) {
                 for (let dy = DATA_RANGE.y[0]; dy <= DATA_RANGE.y[1]; dy += step) {
                     // Use a slightly curved decision boundary for RBF
                     const value = dx + dy - 0.5 + 0.05 * Math.sin(dx) + 0.05 * Math.sin(dy); // Linearish with slight curves
                     const label = value > 0 ? 1 : 0;
                     grid.push({ x: dx, y: dy, label: label });
                 }
             }
             return grid;
         }


         // Dummy/Simplified Pre-calculated Solutions (Manual creation based on expected outcomes)
         const svmSolutions = {
             linearlySeparable: {
                 hard: {
                     linear: { // Simple linear separator for y = -x + const
                         w: [1, 1], b: -0.5, // Example: hyperplane roughly x+y=0.5
                         svIndices: [0, 8], // Example SVs
                         misclassifiedIndices: [],
                         decisionBoundaryGrid: null
                     }
                 },
                 soft: {
                     linear: {
                          '0.1': { w: [0.8, 0.8], b: -0.4, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '1': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '100': { w: [1.2, 1.2], b: -0.6, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null }
                     },
                     rbf: { // RBF on simple linear data can be linear
                         '0.1': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '1': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '100': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [] }
                     }
                 }
             },
             slightlyOverlapping: {
                 hard: {
                     linear: null // Hard margin fails
                 },
                 soft: {
                     linear: {
                         // Manual parameters for linear soft margin
                         '0.1': { w: [0.4, 0.4], b: -0.2, svIndices: [0, 5, 6, 7, 8, 9], misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: null }, // Low C: wide margin, allows errors
                         '1': { w: [0.8, 0.8], b: -0.4, svIndices: [0, 5, 6, 7, 8, 9], misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: null }, // Medium C: balances margin and errors (example)
                         '100': { w: [1.5, 1.5], b: -0.75, svIndices: [0, 5, 6, 7, 8, 9], misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: null } // High C: tries harder to separate, narrower margin
                     },
                      rbf: { // RBF might handle overlap better, potentially with curved boundary
                         '0.1': { w: null, b: null, svIndices: Array.from({length: datasets.slightlyOverlapping.length}, (_, i) => i), misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: generateLinearishRBFGrid() },
                         '1': { w: null, b: null, svIndices: Array.from({length: datasets.slightlyOverlapping.length}, (_, i) => i), misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: generateLinearishRBFGrid() },
                         '100': { w: null, b: null, svIndices: Array.from({length: datasets.slightlyOverlapping.length}, (_, i) => i), misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: generateLinearishRBFGrid() }
                     }
                 }
             },
             circles: {
                 hard: {
                     linear: null // Hard margin fails
                 },
                 soft: {
                     linear: {
                          '0.1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.circles.length}, (_, i) => i), decisionBoundaryGrid: null }, // Linear fails, misclassifies all
                          '1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.circles.length}, (_, i) => i), decisionBoundaryGrid: null },
                          '100': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.circles.length}, (_, i) => i), decisionBoundaryGrid: null }
                     },
                     rbf: {
                          '0.1': { // Low C: Wider boundary zone
                              w: null, b: null, svIndices: Array.from({length: datasets.circles.length}, (_, i) => i), misclassifiedIndices: [],
                              decisionBoundaryGrid: generateCircularGrid(0, 0, 3.5)
                          },
                           '1': { // Medium C: Tighter boundary
                              w: null, b: null, svIndices: Array.from({length: datasets.circles.length}, (_, i) => i), misclassifiedIndices: [],
                              decisionBoundaryGrid: generateCircularGrid(0, 0, 3)
                          },
                           '100': { // High C: Very tight boundary
                              w: null, b: null, svIndices: Array.from({length: datasets.circles.length}, (_, i) => i), misclassifiedIndices: [],
                              decisionBoundaryGrid: generateCircularGrid(0, 0, 2.5)
                          }
                     }
                 }
             },
              xor: {
                 hard: {
                     linear: null // Hard margin fails
                 },
                 soft: {
                     linear: {
                          '0.1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.xor.length}, (_, i) => i).filter(i => datasets.xor[i].label === 0), decisionBoundaryGrid: null }, // Linear fails (e.g., classifies all as 1, misclassifying class 0)
                          '1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.xor.length}, (_, i) => i).filter(i => datasets.xor[i].label === 0), decisionBoundaryGrid: null },
                          '100': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.xor.length}, (_, i) => i).filter(i => datasets.xor[i].label === 0), decisionBoundaryGrid: null }
                     },
                     rbf: {
                          '0.1': { // Low C: mushy boundaries
                             w: null, b: null, svIndices: Array.from({length: datasets.xor.length}, (_, i) => i), misclassifiedIndices: [],
                             decisionBoundaryGrid: generateXORGrid()
                          },
                          '1': { // Medium C: clearer boundaries
                             w: null, b: null, svIndices: Array.from({length: datasets.xor.length}, (_, i) => i), misclassifiedIndices: [],
                             decisionBoundaryGrid: generateXORGrid()
                          },
                          '100': { // High C: sharper boundaries
                             w: null, b: null, svIndices: Array.from({length: datasets.xor.length}, (_, i) => i), misclassifiedIndices: [],
                             decisionBoundaryGrid: generateXORGrid()
                          }
                     }
                 }
             }
         };


        // --- Helper Functions ---

        // Maps data coordinate to canvas pixel
        function mapX(x) {
            const dataWidth = DATA_RANGE.x[1] - DATA_RANGE.x[0];
            const canvasWidth = canvas.width;
            return ((x - DATA_RANGE.x[0]) / dataWidth) * canvasWidth;
        }

        // Maps data coordinate to canvas pixel
        function mapY(y) {
            const dataHeight = DATA_RANGE.y[1] - DATA_RANGE.y[0];
            const canvasHeight = canvas.height;
            // Canvas Y goes down, data Y goes up
            return canvasHeight - ((y - DATA_RANGE.y[0]) / dataHeight) * canvasHeight;
        }


        // --- Drawing Functions ---

        function drawVisualization() {
            // Set canvas size to match its display size (for responsive-like behavior within grid cell)
            const visArea = document.getElementById('visualization');
            // Calculate max square size that fits within the visualization area padding
            const size = Math.min(visArea.clientWidth - 40, visArea.clientHeight - 40); // Subtract padding
            canvas.width = size;
            canvas.height = size;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background classification areas (if grid data exists)
             if (currentSVM && currentSVM.decisionBoundaryGrid) {
                 const grid = currentSVM.decisionBoundaryGrid;
                 const dataStep = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Step used in grid generation
                 const canvasStepX = mapX(DATA_RANGE.x[0] + dataStep) - mapX(DATA_RANGE.x[0]);
                 const canvasStepY = mapY(DATA_RANGE.y[0]) - mapY(DATA_RANGE.y[0] + dataStep); // Y is inverse

                 grid.forEach(gridPoint => {
                     if (gridPoint.label !== null) {
                         ctx.fillStyle = BACKGROUND_COLORS[gridPoint.label];
                         // Draw rectangle for the grid cell centered around gridPoint
                         // Need to adjust from center (dx, dy) or corner. Drawing centered rects is easier.
                         const rectX = mapX(gridPoint.x - dataStep / 2);
                         const rectY = mapY(gridPoint.y + dataStep / 2); // Y is inverse

                         ctx.fillRect(rectX, rectY, canvasStepX + 1, canvasStepY + 1); // Add +1 to cover tiny gaps
                     }
                 });
             }


            // Draw axes (simplified)
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(mapX(0), mapY(DATA_RANGE.y[0]));
            ctx.lineTo(mapX(0), mapY(DATA_RANGE.y[1]));
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(mapX(DATA_RANGE.x[0]), mapY(0));
            ctx.lineTo(mapX(DATA_RANGE.x[1]), mapY(0));
            ctx.stroke();

            // Draw hyperplane and margins (for linear kernels)
            if (currentKernel === 'linear' && currentSVM && currentSVM.w && currentSVM.b !== null) {
                const w = currentSVM.w;
                const b = currentSVM.b;

                 // Helper to get canvas coordinates for line endpoint within canvas bounds
                 function getLineEndpoint(x, y) {
                     // Clamp x and y to data range boundaries, but extend slightly to edge of canvas visual area
                     const buffer = 1; // Extend line slightly past data range
                     const clampedX = Math.max(DATA_RANGE.x[0] - buffer, Math.min(DATA_RANGE.x[1] + buffer, x));
                     const clampedY = Math.max(DATA_RANGE.y[0] - buffer, Math.min(DATA_RANGE.y[1] + buffer, y));
                     return [mapX(clampedX), mapY(clampedY)];
                 }

                // Equation: w[0]*x + w[1]*y + b = C (where C is 0, 1, or -1)
                // If w[1] is non-zero: y = (-w[0]/w[1])*x + (C-b)/w[1]
                // If w[0] is non-zero: x = (-w[1]/w[0])*y + (C-b)/w[0]

                 function drawLine(C_val, style, width) {
                      let p1, p2; // End points of the line segment to draw

                     if (Math.abs(w[1]) > Math.abs(w[0])) { // Line is more horizontal, calculate y for x range ends
                          const x0 = DATA_RANGE.x[0];
                          const y0 = (-w[0]/w[1]) * x0 + (C_val - b)/w[1];
                          const x1 = DATA_RANGE.x[1];
                          const y1 = (-w[0]/w[1]) * x1 + (C_val - b)/w[1];
                          p1 = getLineEndpoint(x0, y0);
                          p2 = getLineEndpoint(x1, y1);
                     } else if (Math.abs(w[0]) > 1e-6) { // Line is more vertical, calculate x for y range ends
                         const y0 = DATA_RANGE.y[0];
                         const x0 = (-w[1]/w[0]) * y0 + (C_val - b)/w[0];
                         const y1 = DATA_RANGE.y[1];
                         const x1 = (-w[1]/w[0]) * y1 + (C_val - b)/w[0];
                          p1 = getLineEndpoint(x0, y0);
                          p2 = getLineEndpoint(x1, y1);
                     } else { // w is close to zero, effectively no linear boundary
                         p1 = p2 = null;
                     }

                     if (p1 && p2) {
                          ctx.strokeStyle = style;
                          ctx.lineWidth = width;
                          ctx.beginPath();
                          ctx.moveTo(p1[0], p1[1]);
                          ctx.lineTo(p2[0], p2[1]);
                          ctx.stroke();
                     }
                 }

                // Draw Hyperplane (C=0)
                 drawLine(0, HYPERPLANE_COLOR, 2);

                 // Draw Margins (C=1 and C=-1) if SVs exist (indicating a valid solution found)
                  if (currentSVM.svIndices !== null) { // Check for null SVs which might happen if Hard fails but w,b are set
                      drawLine(1, MARGIN_COLOR, 1);
                      drawLine(-1, MARGIN_COLOR, 1);
                  }

            }


            // Draw points
            currentData.forEach((point, index) => {
                const isSV = currentSVM && currentSVM.svIndices && currentSVM.svIndices.includes(index);
                const isMisclassified = currentSVM && currentSVM.misclassifiedIndices && currentSVM.misclassifiedIndices.includes(index);

                ctx.fillStyle = CLASS_COLORS[point.label];
                ctx.strokeStyle = isMisclassified ? MISCLASSIFIED_COLOR : (isSV ? HYPERPLANE_COLOR : CLASS_COLORS[point.label]);
                ctx.lineWidth = isSV ? 2 : (isMisclassified ? 2 : 1);

                const radius = isSV ? SV_RADIUS : POINT_RADIUS;

                ctx.beginPath();
                ctx.arc(mapX(point.x), mapY(point.y), radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });

             // Add text label for failure cases
             if (currentSVM === null) { // Check if solution lookup returned null
                 ctx.fillStyle = MISCLASSIFIED_COLOR;
                 ctx.font = '1.2em sans-serif';
                 ctx.textAlign = 'center';
                  let message = "Could not find a solution.";
                 if (currentMarginType === 'hard' && (currentDataset === 'slightlyOverlapping' || currentDataset === 'circles' || currentDataset === 'xor')) {
                     message = "Hard Margin failed: Data not linearly separable";
                 } else if (currentKernel === 'linear' && (currentDataset === 'circles' || currentDataset === 'xor')) {
                     message = "Linear kernel insufficient for this data.";
                 } else {
                     message = "Configuration not supported or failed.";
                 }
                 ctx.fillText(message, canvas.width / 2, canvas.height / 2);
             }
        }

        // --- Interaction Logic ---

        function updateControls() {
            // Set active class for buttons
            controls.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });
            controls.querySelector(`[data-dataset="${currentDataset}"]`).classList.add('active');
            controls.querySelector(`[data-margin="${currentMarginType}"]`).classList.add('active');
            controls.querySelector(`[data-kernel="${currentKernel}"]`).classList.add('active');

            // Show/hide C parameter control
            if (currentMarginType === 'soft') {
                cParameterControl.style.display = 'block';
                // Update slider value display but don't change actual slider position here
                // cValueDisplay.textContent = cSlider.value; // Update on slider input
            } else {
                cParameterControl.style.display = 'none';
            }

             // Disable kernel selection for hard margin on non-linear data, force linear selection visual
             const kernelButtons = controls.querySelectorAll('[data-kernel]');
             if (currentMarginType === 'hard' && (currentDataset === 'slightlyOverlapping' || currentDataset === 'circles' || currentDataset === 'xor')) {
                 currentKernel = 'linear'; // Force internal state to linear for hard margin on these datasets
                  kernelButtons.forEach(btn => {
                     btn.disabled = true; // Disable all kernel buttons
                  });
                  controls.querySelector('[data-kernel="linear"]').disabled = false; // Re-enable linear
                  controls.querySelector('[data-kernel="linear"]').classList.add('active'); // Set linear active
                  controls.querySelector('[data-kernel="rbf"]').classList.remove('active');
             } else {
                 kernelButtons.forEach(btn => btn.disabled = false); // Re-enable all kernels
             }
        }

        function recalculateSVM() {
            // Map continuous slider value to discrete C keys for lookup
             const cValue = parseFloat(cSlider.value);
             let mappedC;

             // Logarithmic-like mapping to discrete C values '0.1', '1', '100'
             // Use thresholds on the log scale: log(0.1) = -1, log(1)=0, log(100)=2. Midpoints: -0.5, 1
             // Map slider value (linear scale 0.1-100) to these thresholds
             const logValue = Math.log10(cValue); // Map value to log scale
             const logThreshold1 = (Math.log10(0.1) + Math.log10(1)) / 2; // Midpoint log(0.1) and log(1)
             const logThreshold2 = (Math.log10(1) + Math.log10(100)) / 2; // Midpoint log(1) and log(100)

             if (logValue < logThreshold1) { // Below log(0.316)
                 mappedC = 0.1;
             } else if (logValue < logThreshold2) { // Between log(0.316) and log(10)
                 mappedC = 1;
             } else { // Above log(10)
                 mappedC = 100;
             }

            // Only update state and redraw if the *mapped* C value changes
            // This prevents excessive redrawing while dragging within a threshold
            if (currentC !== mappedC && currentMarginType === 'soft') { // Only update mappedC if in soft margin mode
                currentC = mappedC;
                // Proceed with lookup and redraw below
            } else if (currentMarginType === 'hard') {
                 currentC = 1; // C is not relevant for hard margin, reset to default mapped value
            }
             // Note: currentC might not change if slider is dragged within a bucket.
             // The check below for solution existence will use the *currentC* state.

             const cKey = currentMarginType === 'soft' ? String(currentC) : null; // Use mapped C value as key for soft margin

             let solution = null;
             try {
                 // Navigate the svmSolutions structure
                 const datasetSolutions = svmSolutions[currentDataset];
                 if (datasetSolutions) {
                     const marginSolutions = datasetSolutions[currentMarginType];
                     if (marginSolutions) {
                         const kernelSolutions = marginSolutions[currentKernel];
                         if (kernelSolutions) {
                             if (currentMarginType === 'soft') {
                                 solution = kernelSolutions[cKey];
                             } else { // Hard margin
                                 solution = kernelSolutions; // Should be the direct solution object or null
                             }
                         }
                     }
                 }

                 // If solution is explicitly null in the structure, keep it null
                 // If it's undefined (path not found), also treat as null failure
                 if (solution === undefined) {
                     solution = null;
                 }

             } catch (e) {
                  console.error("Error looking up SVM solution:", e);
                  solution = null; // Treat any lookup error as failure
             }

            currentSVM = solution;

            // Update controls based on state (e.g., hide C slider, disable kernels)
            updateControls();

            // Redraw visualization
            drawVisualization();
        }

        // --- Event Listeners ---

        controls.addEventListener('click', (event) => {
            const target = event.target;
            if (target.tagName === 'BUTTON' && !target.disabled) {
                let needsRecalculate = false;

                if (target.dataset.dataset) {
                    currentDataset = target.dataset.dataset;
                    currentData = datasets[currentDataset]; // Load new data

                    // Auto-adjust margin/kernel for a better starting point on complex data
                    if (currentDataset === 'linearlySeparable') {
                         // Keep current margin/kernel
                    } else if (currentDataset === 'slightlyOverlapping') {
                         if (currentMarginType === 'hard') currentMarginType = 'soft'; // Force soft for overlapping
                         // Keep current kernel or default to linear? Default to linear to show failure first.
                         currentKernel = 'linear';
                    } else { // Circles or XOR
                         if (currentMarginType === 'hard') currentMarginType = 'soft'; // Force soft for non-linear
                         // Keep current kernel or default to linear? Default to linear to show failure first.
                         currentKernel = 'linear';
                    }
                     needsRecalculate = true;

                } else if (target.dataset.margin) {
                    if (currentMarginType !== target.dataset.margin) {
                       currentMarginType = target.dataset.margin;
                       // When switching to Hard, if on non-linear data, recalculateSVM handles setting kernel to linear
                       needsRecalculate = true;
                    }
                } else if (target.dataset.kernel) {
                    if (currentKernel !== target.dataset.kernel) {
                       currentKernel = target.dataset.kernel;
                       needsRecalculate = true;
                    }
                }

                if (needsRecalculate) {
                   recalculateSVM(); // Recalculate and redraw after any button click
                } else {
                   // If the button clicked didn't change state (e.g. clicked active button), just update controls visuals
                   updateControls();
                }
            }
        });

        cSlider.addEventListener('input', (event) => {
             const value = parseFloat(event.target.value);
             // Mapping C happens inside recalculateSVM, which is called here
            cValueDisplay.textContent = value.toFixed(1); // Always display actual slider value with 1 decimal
            recalculateSVM(); // Recalculate and redraw with new C
        });

        // Handle window resize to redraw canvas
        window.addEventListener('resize', () => {
            drawVisualization(); // Just redraw, no recalculation needed
        });

        // --- Initial Load ---
        function init() {
            currentData = datasets[currentDataset]; // Load initial data
            // Set initial slider value display
            cValueDisplay.textContent = parseFloat(cSlider.value).toFixed(1);
            recalculateSVM(); // Perform initial calculation and drawing
        }

        init();

    </script>
</body>
</html>
```

Passed through review again, adjusted the background drawing slightly by adding +1 to fillRect size to avoid microscopic gaps between grid cells. Improved the linear line drawing by using the `getLineEndpoint` helper consistently. Added more data points to datasets for slightly better appearance. Refined logic for disabling kernel buttons and auto-selecting margin/kernel when changing dataset. Ensured `recalculateSVM` is called only when state *might* change from button clicks. Added a clearer failure message based on context. Looks good.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVM Visual Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
            background-color: #ffffff;
            color: #222222;
            display: grid;
            grid-template-areas:
                "header header"
                "controls visualization"
                "footer footer";
            grid-template-rows: 10% 85% 5%; /* Adjust slightly to make sure everything fits, footer small */
            grid-template-columns: 30% 70%;
            height: 100vh; /* Ensure full viewport height */
            overflow: hidden; /* Prevent scrolling */
        }

        #header {
            grid-area: header;
            background-color: #2f8d46; /* GeeksforGeeks Green */
            color: #ffffff;
            padding: 0 20px;
            display: flex;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
        }

        #controls {
            grid-area: controls;
            padding: 20px;
            overflow-y: auto; /* Allow scrolling if controls exceed height */
            border-right: 1px solid #eee; /* Subtle separator */
        }

        #visualization {
            grid-area: visualization;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative; /* Needed for canvas positioning/sizing */
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #eee;
            display: block; /* Remove extra space below canvas */
        }

        #footer {
            grid-area: footer;
            background-color: #f0f0f0; /* Light grey footer */
            color: #222222;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            border-top: 1px solid #eee;
        }

        #footer a {
            color: #2f8d46;
            text-decoration: none;
            margin: 0 10px;
        }

        #footer a:hover {
            text-decoration: underline;
        }

        /* Control Panel Styling */
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #2f8d46;
        }

        button {
            display: inline-block;
            margin: 5px;
            padding: 8px 15px;
            background-color: #ffffff;
            color: #2f8d46;
            border: 1px solid #2f8d46;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        button:disabled {
             opacity: 0.5;
             cursor: not-allowed;
        }

        button.active {
            background-color: #2f8d46;
            color: #ffffff;
        }

        button:hover:not(.active):not(:disabled) {
            background-color: #e0ffe0; /* Light hover effect */
        }

        input[type="range"] {
             -webkit-appearance: none; /* Override default CSS styles */
             appearance: none;
             width: calc(100% - 10px); /* Adjust width considering margin */
             height: 8px;
             background: #eee;
             outline: none;
             opacity: 0.9; /* Less transparent by default */
             -webkit-transition: .2s;
             transition: opacity .2s;
             margin: 10px 5px;
             border-radius: 5px;
        }

        input[type="range"]:hover {
             opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
             -webkit-appearance: none;
             appearance: none;
             width: 20px;
             height: 20px;
             background: #2f8d46;
             cursor: pointer;
             border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
             width: 20px;
             height: 20px;
             background: #2f8d46;
             cursor: pointer;
             border-radius: 50%;
        }

         label {
            display: block;
            margin: 10px 5px 5px;
            font-size: 0.9em;
            color: #555;
         }

         #c-parameter-control {
             display: none; /* Hidden by default for Hard Margin */
         }

         #c-value-display {
             font-weight: bold;
             margin-left: 5px;
             color: #222;
         }

         /* Canvas specific styles for points/lines can be handled by JS draw calls */
    </style>
</head>
<body>
    <div id="header">
        SVM Visual Explorer
    </div>

    <div id="controls">
        <div class="control-group">
            <h3>Data Selection</h3>
            <button data-dataset="linearlySeparable" class="active">Linearly Separable</button>
            <button data-dataset="slightlyOverlapping">Slightly Overlapping</button>
            <button data-dataset="circles">Non-linear (Circles)</button>
            <button data-dataset="xor">Non-linear (XOR)</button>
        </div>

        <div class="control-group">
            <h3>Margin Type</h3>
            <button data-margin="hard" class="active">Hard Margin</button>
            <button data-margin="soft">Soft Margin</button>
        </div>

        <div class="control-group" id="c-parameter-control">
            <h3>C Parameter (Soft Margin)</h3>
            <label for="c-slider">Value: <span id="c-value-display">1.0</span></label>
            <input type="range" id="c-slider" min="0.1" max="100" value="1" step="0.1">
        </div>

        <div class="control-group">
            <h3>Kernel Selection</h3>
            <button data-kernel="linear" class="active">Linear</button>
            <button data-kernel="rbf">RBF</button>
        </div>
    </div>

    <div id="visualization">
        <canvas id="svmCanvas"></canvas>
    </div>

    <div id="footer">
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <span>|</span>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </div>

    <script>
        // --- Configuration ---
        const DATA_RANGE = { x: [-10, 10], y: [-10, 10] }; // Coordinate range for data
        const POINT_RADIUS = 4;
        const SV_RADIUS = 6; // Slightly larger for Support Vectors
        const MISCLASSIFIED_COLOR = '#ff4c4c'; // Reddish for misclassified
        const CLASS_COLORS = ['#2f8d46', '#007bff']; // Green, Blue
        const HYPERPLANE_COLOR = '#222222'; // Dark
        const MARGIN_COLOR = '#888888'; // Grey
        const BACKGROUND_COLORS = ['rgba(47, 141, 70, 0.1)', 'rgba(0, 123, 255, 0.1)']; // Faded colors for regions
        const GRID_DENSITY = 40; // Number of steps across the data range for background grid

        // --- DOM Elements ---
        const canvas = document.getElementById('svmCanvas');
        const ctx = canvas.getContext('2d');
        const controls = document.getElementById('controls');
        const cParameterControl = document.getElementById('c-parameter-control');
        const cSlider = document.getElementById('c-slider');
        const cValueDisplay = document.getElementById('c-value-display');

        // --- State ---
        let currentDataset = 'linearlySeparable';
        let currentMarginType = 'hard';
        let currentC = 1; // Matches default slider value (will be mapped to discrete values)
        let currentKernel = 'linear';

        let currentData = [];
        let currentSVM = null; // Stores pre-calculated solution for current state

        // --- Pre-calculated Data & Solutions ---

        // Define simplified datasets
        const datasets = {
            linearlySeparable: [
                { x: -5, y: -2, label: 0 }, { x: -3, y: -4, label: 0 }, { x: -4, y: -1, label: 0 },
                { x: 5, y: 2, label: 1 }, { x: 3, y: 4, label: 1 }, { x: 4, y: 1, label: 1 },
                 { x: -6, y: -3, label: 0 }, { x: -2, y: -5, label: 0 },
                 { x: 6, y: 3, label: 1 }, { x: 2, y: 5, label: 1 },
                 { x: -4.5, y: -3.5, label: 0 }, { x: 4.5, y: 3.5, label: 1}
            ],
            slightlyOverlapping: [
                { x: -5, y: -2, label: 0 }, { x: -3, y: -4, label: 0 }, { x: -4, y: -1, label: 0 },
                { x: 5, y: 2, label: 1 }, { x: 3, y: 4, label: 1 }, { x: 4, y: 1, label: 1 },
                { x: -1, y: 1, label: 0 }, { x: 1, y: -1, label: 1 }, // Overlapping points
                 { x: -0.5, y: 0.5, label: 0 }, { x: 0.5, y: -0.5, label: 1 }
            ],
             circles: [
                { x: 0, y: 0, label: 0 }, { x: 1, y: 0, label: 0 }, { x: 0, y: 1, label: 0 },
                { x: 5, y: 5, label: 1 }, { x: 6, y: 5, label: 1 }, { x: 5, y: 6, label: 1 },
                 { x: -1, y: 0, label: 0 }, { x: 0, y: -1, label: 0 }, // Inner circle
                { x: 7, y: 5, label: 1 }, { x: 5, y: 7, label: 1 }, { x: 6, y: 6, label: 1 }, // Outer circle
                 { x: 2, y: 2, label: 0 }, { x: 3, y: 3, label: 0 }, // More inner
                 { x: 4, y: 4, label: 1 }, { x: 4.5, y: 4.5, label: 1 }, // More outer
                 { x: 1.5, y: 1.5, label: 0 }, { x: 5.5, y: 5.5, label: 1 },
                 { x: 0.5, y: 0.5, label: 0 }, { x: 6.5, y: 6.5, label: 1 }
            ],
            xor: [
                { x: -5, y: 5, label: 0 }, { x: 5, y: -5, label: 0 },
                { x: -5, y: -5, label: 1 }, { x: 5, y: 5, label: 1 },
                 { x: -4, y: 4, label: 0 }, { x: 4, y: -4, label: 0 },
                { x: -4, y: -4, label: 1 }, { x: 4, y: 4, label: 1 },
                 { x: -6, y: 6, label: 0 }, { x: 6, y: -6, label: 0 },
                { x: -6, y: -6, label: 1 }, { x: 6, y: 6, label: 1 },
                 { x: -3, y: 3, label: 0 }, { x: 3, y: -3, label: 0 },
                { x: -3, y: -3, label: 1 }, { x: 3, y: 3, label: 1 }
            ]
        };

         // Generates a simplified grid for the circles dataset (RBF kernel)
         function generateCircularGrid(centerX, centerY, boundaryRadius) {
             const grid = [];
             const step = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Grid density

             for (let dx = DATA_RANGE.x[0]; dx <= DATA_RANGE.x[1]; dx += step) {
                 for (let dy = DATA_RANGE.y[0]; dy <= DATA_RANGE.y[1]; dy += step) {
                     const value = (dx - centerX)**2 + (dy - centerY)**2 - boundaryRadius**2;
                     const label = value > 0 ? 1 : 0; // Sign determines class
                     grid.push({ x: dx, y: dy, label: label });
                 }
             }
             return grid;
         }

         // Generates a simplified grid for the XOR dataset (RBF kernel)
         function generateXORGrid() {
             const grid = [];
             const step = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Grid density

             for (let dx = DATA_RANGE.x[0]; dx <= DATA_RANGE.x[1]; dx += step) {
                 for (let dy = DATA_RANGE.y[0]; dy <= DATA_RANGE.y[1]; dy += step) {
                      const value = dx * dy; // Simplified f(x,y) for XOR
                     const label = value > 0 ? 1 : 0; // Sign determines class
                     grid.push({ x: dx, y: dy, label: label });
                 }
             }
             return grid;
         }

        // Simple helper for RBF on slightly overlapping data (linearish boundary)
         function generateLinearishRBFGrid() {
             const grid = [];
             const step = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Grid density

             for (let dx = DATA_RANGE.x[0]; dx <= DATA_RANGE.x[1]; dx += step) {
                 for (let dy = DATA_RANGE.y[0]; dy <= DATA_RANGE.y[1]; dy += step) {
                     // Use a slightly curved decision boundary for RBF
                     const value = dx + dy - 0.5 + 0.05 * Math.sin(dx) + 0.05 * Math.sin(dy); // Linearish with slight curves
                     const label = value > 0 ? 1 : 0;
                     grid.push({ x: dx, y: dy, label: label });
                 }
             }
             return grid;
         }


         // Dummy/Simplified Pre-calculated Solutions (Manual creation based on expected outcomes)
         const svmSolutions = {
             linearlySeparable: {
                 hard: {
                     linear: { // Simple linear separator for y = -x + const
                         w: [1, 1], b: -0.5, // Example: hyperplane roughly x+y=0.5
                         svIndices: [0, 8], // Example SVs
                         misclassifiedIndices: [],
                         decisionBoundaryGrid: null
                     }
                 },
                 soft: {
                     linear: {
                          '0.1': { w: [0.8, 0.8], b: -0.4, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '1': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '100': { w: [1.2, 1.2], b: -0.6, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null }
                     },
                     rbf: { // RBF on simple linear data can be linear
                         '0.1': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '1': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [], decisionBoundaryGrid: null },
                          '100': { w: [1, 1], b: -0.5, svIndices: [0, 8], misclassifiedIndices: [] }
                     }
                 }
             },
             slightlyOverlapping: {
                 hard: {
                     linear: null // Hard margin fails
                 },
                 soft: {
                     linear: {
                         // Manual parameters for linear soft margin
                         '0.1': { w: [0.4, 0.4], b: -0.2, svIndices: [0, 5, 6, 7, 8, 9], misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: null }, // Low C: wide margin, allows errors
                         '1': { w: [0.8, 0.8], b: -0.4, svIndices: [0, 5, 6, 7, 8, 9], misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: null }, // Medium C: balances margin and errors (example)
                         '100': { w: [1.5, 1.5], b: -0.75, svIndices: [0, 5, 6, 7, 8, 9], misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: null } // High C: tries harder to separate, narrower margin
                     },
                      rbf: { // RBF might handle overlap better, potentially with curved boundary
                         '0.1': { w: null, b: null, svIndices: Array.from({length: datasets.slightlyOverlapping.length}, (_, i) => i), misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: generateLinearishRBFGrid() },
                         '1': { w: null, b: null, svIndices: Array.from({length: datasets.slightlyOverlapping.length}, (_, i) => i), misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: generateLinearishRBFGrid() },
                         '100': { w: null, b: null, svIndices: Array.from({length: datasets.slightlyOverlapping.length}, (_, i) => i), misclassifiedIndices: [6, 7, 8, 9], decisionBoundaryGrid: generateLinearishRBFGrid() }
                     }
                 }
             },
             circles: {
                 hard: {
                     linear: null // Hard margin fails
                 },
                 soft: {
                     linear: {
                          '0.1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.circles.length}, (_, i) => i), decisionBoundaryGrid: null }, // Linear fails, misclassifies all
                          '1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.circles.length}, (_, i) => i), decisionBoundaryGrid: null },
                          '100': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.circles.length}, (_, i) => i), decisionBoundaryGrid: null }
                     },
                     rbf: {
                          '0.1': { // Low C: Wider boundary zone
                              w: null, b: null, svIndices: Array.from({length: datasets.circles.length}, (_, i) => i), misclassifiedIndices: [],
                              decisionBoundaryGrid: generateCircularGrid(0, 0, 3.5)
                          },
                           '1': { // Medium C: Tighter boundary
                              w: null, b: null, svIndices: Array.from({length: datasets.circles.length}, (_, i) => i), misclassifiedIndices: [],
                              decisionBoundaryGrid: generateCircularGrid(0, 0, 3)
                          },
                           '100': { // High C: Very tight boundary
                              w: null, b: null, svIndices: Array.from({length: datasets.circles.length}, (_, i) => i), misclassifiedIndices: [],
                              decisionBoundaryGrid: generateCircularGrid(0, 0, 2.5)
                          }
                     }
                 }
             },
              xor: {
                 hard: {
                     linear: null // Hard margin fails
                 },
                 soft: {
                     linear: {
                          '0.1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.xor.length}, (_, i) => i).filter(i => datasets.xor[i].label === 0), decisionBoundaryGrid: null }, // Linear fails (e.g., classifies all as 1, misclassifying class 0)
                          '1': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.xor.length}, (_, i) => i).filter(i => datasets.xor[i].label === 0), decisionBoundaryGrid: null },
                          '100': { w: [0, 0], b: 0, svIndices: [], misclassifiedIndices: Array.from({length: datasets.xor.length}, (_, i) => i).filter(i => datasets.xor[i].label === 0), decisionBoundaryGrid: null }
                     },
                     rbf: {
                          '0.1': { // Low C: mushy boundaries
                             w: null, b: null, svIndices: Array.from({length: datasets.xor.length}, (_, i) => i), misclassifiedIndices: [],
                             decisionBoundaryGrid: generateXORGrid()
                          },
                          '1': { // Medium C: clearer boundaries
                             w: null, b: null, svIndices: Array.from({length: datasets.xor.length}, (_, i) => i), misclassifiedIndices: [],
                             decisionBoundaryGrid: generateXORGrid()
                          },
                          '100': { // High C: sharper boundaries
                             w: null, b: null, svIndices: Array.from({length: datasets.xor.length}, (_, i) => i), misclassifiedIndices: [],
                             decisionBoundaryGrid: generateXORGrid()
                          }
                     }
                 }
             }
         };


        // --- Helper Functions ---

        // Maps data coordinate to canvas pixel
        function mapX(x) {
            const dataWidth = DATA_RANGE.x[1] - DATA_RANGE.x[0];
            const canvasWidth = canvas.width;
            return ((x - DATA_RANGE.x[0]) / dataWidth) * canvasWidth;
        }

        // Maps data coordinate to canvas pixel
        function mapY(y) {
            const dataHeight = DATA_RANGE.y[1] - DATA_RANGE.y[0];
            const canvasHeight = canvas.height;
            // Canvas Y goes down, data Y goes up
            return canvasHeight - ((y - DATA_RANGE.y[0]) / dataHeight) * canvasHeight;
        }


        // --- Drawing Functions ---

        function drawVisualization() {
            // Set canvas size to match its display size (for responsive-like behavior within grid cell)
            const visArea = document.getElementById('visualization');
            // Calculate max square size that fits within the visualization area padding
            const size = Math.min(visArea.clientWidth - 40, visArea.clientHeight - 40); // Subtract padding
            canvas.width = size;
            canvas.height = size;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background classification areas (if grid data exists)
             if (currentSVM && currentSVM.decisionBoundaryGrid) {
                 const grid = currentSVM.decisionBoundaryGrid;
                 const dataStep = (DATA_RANGE.x[1] - DATA_RANGE.x[0]) / GRID_DENSITY; // Step used in grid generation
                 const canvasStepX = mapX(DATA_RANGE.x[0] + dataStep) - mapX(DATA_RANGE.x[0]);
                 const canvasStepY = mapY(DATA_RANGE.y[0]) - mapY(DATA_RANGE.y[0] + dataStep); // Y is inverse

                 grid.forEach(gridPoint => {
                     if (gridPoint.label !== null) {
                         ctx.fillStyle = BACKGROUND_COLORS[gridPoint.label];
                         // Draw rectangle for the grid cell centered around gridPoint
                         const rectX = mapX(gridPoint.x - dataStep / 2);
                         const rectY = mapY(gridPoint.y + dataStep / 2); // Y is inverse

                         ctx.fillRect(rectX, rectY, canvasStepX + 1, canvasStepY + 1); // Add +1 to cover tiny gaps
                     }
                 });
             }


            // Draw axes (simplified)
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(mapX(0), mapY(DATA_RANGE.y[0]));
            ctx.lineTo(mapX(0), mapY(DATA_RANGE.y[1]));
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(mapX(DATA_RANGE.x[0]), mapY(0));
            ctx.lineTo(mapX(DATA_RANGE.x[1]), mapY(0));
            ctx.stroke();

            // Draw hyperplane and margins (for linear kernels)
            if (currentKernel === 'linear' && currentSVM && currentSVM.w && currentSVM.b !== null) {
                const w = currentSVM.w;
                const b = currentSVM.b;

                 // Helper to get canvas coordinates for line endpoint within canvas bounds
                 function getLineEndpoint(x, y) {
                     // Clamp x and y to data range boundaries, but extend slightly to edge of canvas visual area
                     const buffer = 1; // Extend line slightly past data range
                     const clampedX = Math.max(DATA_RANGE.x[0] - buffer, Math.min(DATA_RANGE.x[1] + buffer, x));
                     const clampedY = Math.max(DATA_RANGE.y[0] - buffer, Math.min(DATA_RANGE.y[1] + buffer, y));
                     return [mapX(clampedX), mapY(clampedY)];
                 }

                // Equation: w[0]*x + w[1]*y + b = C (where C is 0, 1, or -1)
                // If w[1] is non-zero: y = (-w[0]/w[1])*x + (C-b)/w[1]
                // If w[0] is non-zero: x = (-w[1]/w[0])*y + (C-b)/w[0]

                 function drawLine(C_val, style, width) {
                      let p1, p2; // End points of the line segment to draw

                     if (Math.abs(w[1]) > Math.abs(w[0]) * 1e-6) { // Check if w[1] is significantly non-zero (more horizontal line)
                          const x0 = DATA_RANGE.x[0];
                          const y0 = (-w[0]/w[1]) * x0 + (C_val - b)/w[1];
                          const x1 = DATA_RANGE.x[1];
                          const y1 = (-w[0]/w[1]) * x1 + (C_val - b)/w[1];
                          p1 = getLineEndpoint(x0, y0);
                          p2 = getLineEndpoint(x1, y1);
                     } else if (Math.abs(w[0]) > 1e-6) { // Check if w[0] is significantly non-zero (more vertical line)
                         const y0 = DATA_RANGE.y[0];
                         const x0 = (-w[1]/w[0]) * y0 + (C_val - b)/w[0];
                         const y1 = DATA_RANGE.y[1];
                         const x1 = (-w[1]/w[0]) * y1 + (C_val - b)/w[0];
                          p1 = getLineEndpoint(x0, y0);
                          p2 = getLineEndpoint(x1, y1);
                     } else { // w is close to zero in both components
                         p1 = p2 = null; // Cannot draw a meaningful line
                     }

                     if (p1 && p2) {
                          ctx.strokeStyle = style;
                          ctx.lineWidth = width;
                          ctx.beginPath();
                          ctx.moveTo(p1[0], p1[1]);
                          ctx.lineTo(p2[0], p2[1]);
                          ctx.stroke();
                     }
                 }

                // Draw Hyperplane (C=0)
                 drawLine(0, HYPERPLANE_COLOR, 2);

                 // Draw Margins (C=1 and C=-1) if SVs exist (indicating a valid solution found)
                  if (currentSVM.svIndices !== null) { // Check for null SVs which might happen if Hard fails but w,b are set
                      drawLine(1, MARGIN_COLOR, 1);
                      drawLine(-1, MARGIN_COLOR, 1);
                  }

            }


            // Draw points
            currentData.forEach((point, index) => {
                const isSV = currentSVM && currentSVM.svIndices && currentSVM.svIndices.includes(index);
                const isMisclassified = currentSVM && currentSVM.misclassifiedIndices && currentSVM.misclassifiedIndices.includes(index);

                ctx.fillStyle = CLASS_COLORS[point.label];
                ctx.strokeStyle = isMisclassified ? MISCLASSIFIED_COLOR : (isSV ? HYPERPLANE_COLOR : CLASS_COLORS[point.label]);
                ctx.lineWidth = isSV ? 2 : (isMisclassified ? 2 : 1);

                const radius = isSV ? SV_RADIUS : POINT_RADIUS;

                ctx.beginPath();
                ctx.arc(mapX(point.x), mapY(point.y), radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });

             // Add text label for failure cases
             if (currentSVM === null) { // Check if solution lookup returned null
                 ctx.fillStyle = MISCLASSIFIED_COLOR;
                 ctx.font = '1.2em sans-serif';
                 ctx.textAlign = 'center';
                  let message = "Could not find a solution.";
                 if (currentMarginType === 'hard' && (currentDataset === 'slightlyOverlapping' || currentDataset === 'circles' || currentDataset === 'xor')) {
                     message = "Hard Margin failed: Data not linearly separable";
                 } else if (currentKernel === 'linear' && (currentDataset === 'circles' || currentDataset === 'xor')) {
                     message = "Linear kernel insufficient for this data.";
                 } else {
                     message = "Configuration not supported or failed.";
                 }
                 ctx.fillText(message, canvas.width / 2, canvas.height / 2);
             }
        }

        // --- Interaction Logic ---

        function updateControls() {
            // Set active class for buttons
            controls.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });
            controls.querySelector(`[data-dataset="${currentDataset}"]`).classList.add('active');
            controls.querySelector(`[data-margin="${currentMarginType}"]`).classList.add('active');
            controls.querySelector(`[data-kernel="${currentKernel}"]`).classList.add('active');

            // Show/hide C parameter control
            if (currentMarginType === 'soft') {
                cParameterControl.style.display = 'block';
                // Update slider value display but don't change actual slider position here
                // cValueDisplay.textContent = cSlider.value; // Update on slider input
            } else {
                cParameterControl.style.display = 'none';
            }

             // Disable kernel selection for hard margin on non-linear data, force linear selection visual
             const kernelButtons = controls.querySelectorAll('[data-kernel]');
             if (currentMarginType === 'hard' && (currentDataset === 'slightlyOverlapping' || currentDataset === 'circles' || currentDataset === 'xor')) {
                 currentKernel = 'linear'; // Force internal state to linear for hard margin on these datasets
                  kernelButtons.forEach(btn => {
                     btn.disabled = true; // Disable all kernel buttons
                  });
                  controls.querySelector('[data-kernel="linear"]').disabled = false; // Re-enable linear
                  controls.querySelector('[data-kernel="linear"]').classList.add('active'); // Set linear active
                  controls.querySelector('[data-kernel="rbf"]').classList.remove('active');
             } else {
                 kernelButtons.forEach(btn => btn.disabled = false); // Re-enable all kernels
             }
        }

        function recalculateSVM() {
            // Map continuous slider value to discrete C keys for lookup
             const cValue = parseFloat(cSlider.value);
             let mappedC;

             // Logarithmic-like mapping to discrete C values '0.1', '1', '100'
             // Use thresholds on the log scale: log(0.1) = -1, log(1)=0, log(100)=2. Midpoints: -0.5, 1
             // Map slider value (linear scale 0.1-100) to these thresholds
             const logValue = Math.log10(cValue > 0 ? cValue : 0.1); // Avoid log(0)
             const logThreshold1 = (Math.log10(0.1) + Math.log10(1)) / 2; // Midpoint log(0.1) and log(1)
             const logThreshold2 = (Math.log10(1) + Math.log10(100)) / 2; // Midpoint log(1) and log(100)

             if (logValue < logThreshold1) { // Below log(0.316)
                 mappedC = 0.1;
             } else if (logValue < logThreshold2) { // Between log(0.316) and log(10)
                 mappedC = 1;
             } else { // Above log(10)
                 mappedC = 100;
             }

            // Only update state and redraw if the *mapped* C value changes
            // This prevents excessive redrawing while dragging within a threshold
            if (currentC !== mappedC && currentMarginType === 'soft') { // Only update mappedC if in soft margin mode
                currentC = mappedC;
                // Proceed with lookup and redraw below
            } else if (currentMarginType === 'hard') {
                 // If switching from soft back to hard, reset C display
                 // cSlider.value = 1; // Reset slider position visually? Not strictly needed by brief
                 // cValueDisplay.textContent = "1.0";
                 currentC = 1; // C is not relevant for hard margin, reset to default mapped value
            }
             // Note: currentC might not change if slider is dragged within a bucket.
             // The check below for solution existence will use the *currentC* state.

             const cKey = currentMarginType === 'soft' ? String(currentC) : null; // Use mapped C value as key for soft margin

             let solution = null;
             try {
                 // Navigate the svmSolutions structure
                 const datasetSolutions = svmSolutions[currentDataset];
                 if (datasetSolutions) {
                     const marginSolutions = datasetSolutions[currentMarginType];
                     if (marginSolutions) {
                         const kernelSolutions = marginSolutions[currentKernel];
                         if (kernelSolutions) {
                             if (currentMarginType === 'soft') {
                                 solution = kernelSolutions[cKey];
                             } else { // Hard margin
                                 solution = kernelSolutions; // Should be the direct solution object or null
                             }
                         }
                     }
                 }

                 // If solution is explicitly null in the structure, keep it null
                 // If it's undefined (path not found), also treat as null failure
                 if (solution === undefined) {
                     solution = null;
                 }

             } catch (e) {
                  console.error("Error looking up SVM solution:", e);
                  solution = null; // Treat any lookup error as failure
             }

            currentSVM = solution;

            // Update controls based on state (e.e.

