
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors Interactive Explorer</title>
    <style>
        :root {
            --primary-color: #2f8d46;
            --background-color: #ffffff;
            --text-color: #222222;
            --light-border: #eeeeee;
            --test-point-color: #ff5733; /* Distinct color for test point */
            --highlight-color: #ffda6c; /* Color to highlight neighbors */
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: var(--text-color);
            background-color: var(--background-color);
            display: grid;
            grid-template-areas:
                "header header header"
                "controls main process"
                "footer footer footer";
            grid-template-rows: auto 1fr auto; /* Header/footer auto height, main area takes rest */
            grid-template-columns: 250px 1fr 200px; /* Controls width, main area flex, process width */
            height: 100vh; /* Full viewport height */
            overflow: hidden; /* Prevent scrolling */
            box-sizing: border-box;
        }

        header {
            grid-area: header;
            text-align: center;
            padding: 10px;
            border-bottom: 1px solid var(--light-border);
            font-size: 1.2em;
            font-weight: bold;
        }

        .controls {
            grid-area: controls;
            padding: 15px;
            border-right: 1px solid var(--light-border);
            overflow-y: auto; /* Allow scrolling controls if they overflow */
        }

        .main-area {
            grid-area: main;
            position: relative; /* For positioning prediction text */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
        }

        canvas {
            display: block;
            border: 1px solid var(--light-border);
            background-color: #f9f9f9; /* Slightly off-white background for canvas */
            max-width: 100%;
            max-height: 100%;
            box-sizing: border-box;
        }

        .process-visualizer {
            grid-area: process;
            padding: 15px;
            border-left: 1px solid var(--light-border);
        }

        .process-visualizer h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .process-visualizer ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .process-visualizer li {
            padding: 8px;
            margin-bottom: 5px;
            border: 1px solid transparent;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            font-size: 0.9em;
            cursor: pointer; /* Indicate interactivity */
        }

        .process-visualizer li.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .process-visualizer li:hover:not(.active) {
             background-color: #e0e0e0;
             border-color: #ccc;
        }


        footer {
            grid-area: footer;
            text-align: center;
            padding: 10px;
            border-top: 1px solid var(--light-border);
            font-size: 0.8em;
            background-color: #f7f7f7; /* Slightly lighter footer */
        }

        footer a {
            color: var(--primary-color);
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--light-border);
        }

        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .control-group input[type="range"],
        .control-group select,
        .control-group button {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }

         .control-group input[type="range"] {
             padding: 0; /* Range sliders don't need vertical padding */
             height: 25px;
         }


        .control-group button {
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .control-group button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .control-group button:hover:not(.active) {
            background-color: #e0e0e0;
        }

        #kValueDisplay {
            font-weight: normal;
            margin-left: 5px;
        }

        #predictionDisplay {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            padding: 8px 15px;
            border: 1px solid var(--light-border);
            border-radius: 4px;
            font-size: 1em;
            font-weight: bold;
            z-index: 10; /* Ensure it's above the canvas */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }


        /* Canvas drawing styles handled by JS */
        /* Point styles, highlight styles are drawn directly onto the canvas */

    </style>
</head>
<body>

    <header>
        K-Nearest Neighbors (KNN) Interactive Explorer
    </header>

    <div class="controls">
        <div class="control-group">
            <label for="modeToggle">Mode:</label>
            <button id="modeToggle" data-mode="classification" class="active">Classification</button>
        </div>

        <div class="control-group">
            <label for="kSlider">Number of Neighbors (K): <span id="kValueDisplay">3</span></label>
            <input type="range" id="kSlider" min="1" max="15" value="3">
        </div>

        <div class="control-group">
            <label for="metricSelect">Distance Metric:</label>
            <select id="metricSelect">
                <option value="euclidean">Euclidean</option>
                <option value="manhattan">Manhattan</option>
            </select>
        </div>

        <!-- Potential future controls would go here -->

    </div>

    <div class="main-area">
        <canvas id="knnCanvas"></canvas>
        <div id="predictionDisplay">Predicted: Calculating...</div>
    </div>

    <div class="process-visualizer">
        <h4>KNN Steps</h4>
        <ul>
            <li id="step1">1. Start with data & test point.</li>
            <li id="step2">2. Select K & Metric.</li>
            <li id="step3">3. Calculate distances.</li>
            <li id="step4">4. Find K Nearest.</li>
            <li id="step5">5. Predict outcome.</li>
        </ul>
    </div>

    <footer>
        Made with ❤️ by Ashish Jangra |
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a> |
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        const canvas = document.getElementById('knnCanvas');
        const ctx = canvas.getContext('2d');
        const kSlider = document.getElementById('kSlider');
        const kValueDisplay = document.getElementById('kValueDisplay');
        const metricSelect = document.getElementById('metricSelect');
        const modeToggle = document.getElementById('modeToggle');
        const predictionDisplay = document.getElementById('predictionDisplay');
        const processSteps = {
            start: document.getElementById('step1'),
            select: document.getElementById('step2'),
            calculate: document.getElementById('step3'),
            find: document.getElementById('step4'),
            predict: document.getElementById('step5')
        };

        // --- Configuration ---
        const canvasWidth = 600; // Fixed canvas size for simplicity
        const canvasHeight = 400;
        const padding = 20; // Padding inside canvas border
        const pointRadius = 5;
        const testPointRadius = 7;
        const highlightCircleRadius = 25; // Radius for neighbor highlight circle

        let currentK = parseInt(kSlider.value);
        let currentMetric = metricSelect.value;
        let currentMode = 'classification'; // 'classification' or 'regression'

        // --- Data ---
        // Classification data: { x, y, class }
        const classificationData = [
            { x: 100, y: 100, class: 'A' }, { x: 120, y: 110, class: 'A' }, { x: 90, y: 130, class: 'A' },
            { x: 110, y: 90, class: 'A' }, { x: 140, y: 120, class: 'A' }, { x: 80, y: 100, class: 'A' },
            { x: 400, y: 300, class: 'B' }, { x: 420, y: 290, class: 'B' }, { x: 390, y: 310, class: 'B' },
            { x: 410, y: 320, class: 'B' }, { x: 380, y: 280, class: 'B' }, { x: 430, y: 330, class: 'B' },
            { x: 250, y: 150, class: 'A' }, { x: 280, y: 170, class: 'A' },
            { x: 200, y: 250, class: 'B' }, { x: 230, y: 230, class: 'B' },
             { x: 300, y: 200, class: 'A' }, { x: 320, y: 190, class: 'A' },
            { x: 350, y: 250, class: 'B' }, { x: 340, y: 270, class: 'B' }
        ];

        // Regression data: { x, y, value } - value based on y for simplicity
        const regressionData = [
             { x: 100, y: 100, value: 10 }, { x: 120, y: 110, value: 12 }, { x: 90, y: 130, value: 15 },
            { x: 110, y: 90, value: 9 }, { x: 140, y: 120, value: 13 }, { x: 80, y: 100, value: 10 },
            { x: 400, y: 300, value: 60 }, { x: 420, y: 290, value: 58 }, { x: 390, y: 310, value: 62 },
            { x: 410, y: 320, value: 65 }, { x: 380, y: 280, value: 55 }, { x: 430, y: 330, value: 68 },
            { x: 250, y: 150, value: 20 }, { x: 280, y: 170, value: 25 },
            { x: 200, y: 250, value: 40 }, { x: 230, y: 230, value: 38 },
             { x: 300, y: 200, value: 30 }, { x: 320, y: 190, value: 28 },
            { x: 350, y: 250, value: 45 }, { x: 340, y: 270, value: 48 }
        ];


        let testPoint = { x: 300, y: 200 }; // Initial position
        let dragging = false;
        let dragStartX, dragStartY;
        let testPointStartX, testPointStartY;

        let neighbors = []; // Array to store the k nearest neighbors


        // --- Distance Metrics ---
        function euclideanDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function manhattanDistance(p1, p2) {
            return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
        }

        function getDistance(p1, p2, metric) {
            switch (metric) {
                case 'euclidean': return euclideanDistance(p1, p2);
                case 'manhattan': return manhattanDistance(p1, p2);
                default: return euclideanDistance(p1, p2);
            }
        }

        // --- KNN Logic ---
        function findNearestNeighbors(point, k, data, metric) {
            processSteps.calculate.classList.add('active');
            processSteps.find.classList.remove('active'); // Clear previous step

            const distances = data.map(p => ({
                point: p,
                distance: getDistance(point, p, metric)
            }));

            distances.sort((a, b) => a.distance - b.distance);

            processSteps.calculate.classList.remove('active');
            processSteps.find.classList.add('active');

            return distances.slice(0, k).map(d => d.point);
        }

        function predict(neighbors, mode) {
            processSteps.predict.classList.add('active');
            let outcome;

            if (mode === 'classification') {
                const classCounts = {};
                neighbors.forEach(p => {
                    classCounts[p.class] = (classCounts[p.class] || 0) + 1;
                });

                let maxCount = 0;
                let predictedClass = 'N/A'; // Handle case with no neighbors (shouldn't happen if k >= 1)

                // Find the class with the max count
                for (const className in classCounts) {
                    if (classCounts[className] > maxCount) {
                        maxCount = classCounts[className];
                        predictedClass = className;
                    } else if (classCounts[className] === maxCount) {
                        // Simple tie-breaking: prefer the one seen first, or just keep the current
                        // A more robust tie-breaker might look at distances, but keep it simple.
                    }
                }
                 outcome = predictedClass;
                 predictionDisplay.textContent = `Predicted Class: ${outcome}`;

            } else { // Regression
                const sum = neighbors.reduce((acc, p) => acc + p.value, 0);
                const average = neighbors.length > 0 ? sum / neighbors.length : 0;
                outcome = average.toFixed(2); // Round for display
                predictionDisplay.textContent = `Predicted Value: ${outcome}`;
            }

            // Add a short delay before removing the 'active' class for visual effect
            setTimeout(() => processSteps.predict.classList.remove('active'), 500);

            return outcome;
        }

        // --- Drawing ---
        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            const data = currentMode === 'classification' ? classificationData : regressionData;

            // Draw training points
            data.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);

                if (currentMode === 'classification') {
                    ctx.fillStyle = p.class === 'A' ? 'rgba(47, 141, 70, 0.7)' : 'rgba(65, 105, 225, 0.7)'; // GFG green vs RoyalBlue
                } else { // Regression
                     // Simple color gradient based on value (0 to ~70 based on sample data)
                    const minVal = Math.min(...regressionData.map(d => d.value));
                    const maxVal = Math.max(...regressionData.map(d => d.value));
                    const valueNormalized = (p.value - minVal) / (maxVal - minVal); // 0 to 1
                    const hue = (1 - valueNormalized) * 240; // Blue (0) to Red (240) range approx
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.7)`;
                }

                ctx.fill();
                ctx.strokeStyle = var(--text-color);
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw K nearest neighbors highlight
            neighbors.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, highlightCircleRadius, 0, Math.PI * 2);
                ctx.strokeStyle = var(--highlight-color);
                ctx.lineWidth = 2;
                // ctx.setLineDash([5, 5]); // Optional: dotted circle
                ctx.stroke();
                 // ctx.setLineDash([]); // Reset line dash

                // Optional: Draw subtle lines to neighbors (can be noisy)
                // ctx.beginPath();
                // ctx.moveTo(testPoint.x, testPoint.y);
                // ctx.lineTo(p.x, p.y);
                // ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                // ctx.lineWidth = 1;
                // ctx.stroke();
            });


            // Draw test point
            ctx.beginPath();
            ctx.arc(testPoint.x, testPoint.y, testPointRadius, 0, Math.PI * 2);
            ctx.fillStyle = var(--test-point-color);
            ctx.fill();
            ctx.strokeStyle = var(--text-color);
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function updateKNN() {
            processSteps.start.classList.remove('active'); // Assuming start is done initially
            processSteps.select.classList.add('active');
             // Add delay before moving to next step visual
            setTimeout(() => {
                processSteps.select.classList.remove('active');
                 const data = currentMode === 'classification' ? classificationData : regressionData;
                neighbors = findNearestNeighbors(testPoint, currentK, data, currentMetric);
                predict(neighbors, currentMode);
                draw();
            }, 300); // Short delay
        }

        // --- Event Handlers ---
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if click is on the test point (within a small tolerance)
            const distanceToTestPoint = euclideanDistance({ x, y }, testPoint);
            if (distanceToTestPoint < testPointRadius + 5) { // Add a buffer
                dragging = true;
                dragStartX = x;
                dragStartY = y;
                testPointStartX = testPoint.x;
                testPointStartY = testPoint.y;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Calculate the new position based on drag movement
            const dx = x - dragStartX;
            const dy = y - dragStartY;

            const newX = testPointStartX + dx;
            const newY = testPointStartY + dy;

            // Constrain the test point within canvas bounds
            testPoint.x = Math.max(padding, Math.min(canvasWidth - padding, newX));
            testPoint.y = Math.max(padding, Math.min(canvasHeight - padding, newY));

            updateKNN(); // Recalculate and redraw
        });

        canvas.addEventListener('mouseup', () => {
            if (dragging) {
                dragging = false;
                canvas.style.cursor = 'grab';
                // updateKNN was already called on mousemove, but call one last time for certainty
                updateKNN();
            }
        });

         canvas.addEventListener('mouseleave', () => {
            // End drag if mouse leaves canvas while dragging
            if (dragging) {
                dragging = false;
                 canvas.style.cursor = 'grab';
                 updateKNN();
            }
        });


        kSlider.addEventListener('input', (e) => {
            currentK = parseInt(e.target.value);
            kValueDisplay.textContent = currentK;
            updateKNN();
        });

        metricSelect.addEventListener('change', (e) => {
            currentMetric = e.target.value;
            updateKNN();
        });

        modeToggle.addEventListener('click', (e) => {
            if (currentMode === 'classification') {
                currentMode = 'regression';
                e.target.textContent = 'Regression';
            } else {
                currentMode = 'classification';
                e.target.textContent = 'Classification';
            }
            // Update button active state (basic toggle)
            e.target.classList.add('active');
             // Need to find a way to manage other button state if multiple modes
             // For a simple toggle, this is fine.
             // If adding more modes, need a button group logic.

            // Adjust max K based on the smaller dataset size if necessary, or keep simple max
             const data = currentMode === 'classification' ? classificationData : regressionData;
             kSlider.max = Math.min(data.length, 15); // Limit max K to dataset size or reasonable max
             if (currentK > kSlider.max) {
                 currentK = kSlider.max;
                 kSlider.value = currentK;
                 kValueDisplay.textContent = currentK;
             }

            updateKNN();
        });

        // Process Visualizer Hover (Subtle feedback)
        processSteps.calculate.addEventListener('mouseover', () => { /* Add logic to briefly highlight neighbors if implemented */ });
         processSteps.find.addEventListener('mouseover', () => { /* Add logic to briefly highlight neighbors if implemented */ });


        // --- Initialization ---
        function init() {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.cursor = 'grab'; // Initial cursor state
            processSteps.start.classList.add('active'); // Initial step

            // Ensure K is not more than data points
             const data = currentMode === 'classification' ? classificationData : regressionData;
             kSlider.max = Math.min(data.length, 15);
             if (currentK > kSlider.max) {
                 currentK = kSlider.max;
                 kSlider.value = currentK;
                 kValueDisplay.textContent = currentK;
             }

            updateKNN(); // Initial draw and prediction
        }

        init();

    </script>

</body>
</html>
