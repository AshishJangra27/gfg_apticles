
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth First Search Visualizer</title>
    <style>
        /* Global Styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
            font-family: monospace;
            background-color: #ffffff;
            color: #000000;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Fit viewport height */
            width: 100vw; /* Fit viewport width */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        /* Theme Colors (GeeksforGeeks Green: #2f8d46) */
        :root {
            --primary-green: #2f8d46;
            --light-gray: #cccccc;
            --extra-light-gray: #f0f0f0;
            --white: #ffffff;
            --black: #000000;
            --visited-node-color: #e0e0e0; /* Light grey fill for visited nodes */
        }

        /* Header */
        header {
            height: 8vh;
            width: 100vw;
            background-color: var(--extra-light-gray);
            border-bottom: 1px solid var(--light-gray);
            display: flex;
            align-items: center;
            padding: 0 1vw;
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent shrinking below height */
        }

        header img {
            height: 32px;
            margin-right: 1vw;
        }

        header h1 {
            margin: 0;
            font-size: 1.5em;
            color: var(--primary-green); /* Title color */
        }

        /* Footer */
        footer {
            height: 7vh;
            width: 100vw;
            background-color: var(--extra-light-gray);
            border-top: 1px solid var(--light-gray);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 1vw;
            box-sizing: border-box;
            font-size: 0.9em;
            flex-shrink: 0; /* Prevent shrinking below height */
        }

        footer a {
            color: var(--primary-green);
            text-decoration: none;
            margin: 0 1vw;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Main Content Area */
        .main-content {
            flex-grow: 1; /* Take remaining vertical space */
            display: flex;
            height: calc(100vh - 8vh - 7vh); /* Calculate remaining height */
            width: 100vw;
        }

        /* Left Panel (Controls & Input) */
        .left-panel {
            width: 30vw;
            height: 100%; /* Use 100% of parent height */
            padding: 1.5vh 1vw; /* Increased vertical padding */
            box-sizing: border-box;
            border-right: 1px solid var(--light-gray);
            display: flex;
            flex-direction: column;
            gap: 1.5vh; /* Spacing between sections */
            overflow-y: hidden; /* Sticking to non-scrollable */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .input-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 0.5vh; /* Reduce space between input groups */
        }

        .input-group label {
            margin-bottom: 0.5vh;
            font-weight: bold;
            font-size: 0.9em;
        }

        .left-panel textarea,
        .left-panel input[type="text"] {
            padding: 0.8vh; /* Adjusted padding */
            border: 1px solid var(--light-gray);
            box-sizing: border-box;
            font-family: monospace;
            font-size: 1em;
            background-color: var(--white);
            color: var(--black);
        }

        .left-panel textarea {
            height: 18vh; /* Adjusted height for graph input */
            resize: none; /* Prevent manual resize */
        }

        .left-panel input[type="text"] {
            width: 6vw; /* Adjusted width for start node */
        }

        .left-panel .checkbox-group {
            display: flex;
            align-items: center;
            margin-top: 0.5vh; /* Space above checkbox */
            font-size: 0.9em;
        }

        .left-panel .checkbox-group input[type="checkbox"] {
            margin-right: 0.5vw;
            accent-color: var(--primary-green); /* Green checkbox */
        }

        .button-group {
            display: flex;
            gap: 1vw;
            margin-top: 1vh;
            flex-wrap: wrap; /* Allow buttons to wrap if space is tight */
        }

        button {
            padding: 1vh 1vw;
            cursor: pointer;
            border: 1px solid var(--light-gray);
            background-color: var(--extra-light-gray);
            font-family: monospace;
            font-size: 1em;
            flex-grow: 1; /* Buttons fill available space */
            color: var(--black);
            transition: background-color 0.1s ease, border-color 0.1s ease;
        }

        button:hover:not(:disabled) {
            background-color: #e9e9e9; /* Slightly darker than extra-light-gray */
            border-color: #b0b0b0; /* Darker border on hover */
        }

        button:active:not(:disabled) {
            background-color: var(--light-gray);
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
            background-color: var(--extra-light-gray);
            border-color: var(--light-gray);
        }

        button#autoRunButton, button#nextStepButton {
            background-color: var(--primary-green);
            color: var(--white);
            border-color: var(--primary-green);
        }

        button#autoRunButton:hover:not(:disabled), button#nextStepButton:hover:not(:disabled) {
            background-color: #3da257; /* Slightly lighter green */
            border-color: #3da257;
        }
        button#autoRunButton:active:not(:disabled), button#nextStepButton:active:not(:disabled) {
            background-color: #2a7c3d; /* Slightly darker green */
            border-color: #2a7c3d;
        }
        button#autoRunButton:disabled, button#nextStepButton:disabled {
            background-color: #a0cfa0; /* Lighter green when disabled */
            border-color: #a0cfa0;
            color: #ffffff;
        }

        /* Right Panel (Visualization & Output) */
        .right-panel {
            width: 70vw;
            height: 100%; /* Use 100% of parent height */
            display: flex;
            flex-direction: column;
            padding: 1.5vh 1vw; /* Increased vertical padding */
            box-sizing: border-box;
            flex-grow: 1; /* Allow growing to fill space */
        }

        #visualizationCanvas {
            width: 100%;
            flex-grow: 1; /* Canvas takes most of the space */
            border: 1px solid var(--light-gray); /* Border around canvas */
            box-sizing: border-box;
            background-color: var(--white); /* Ensure canvas background is white */
        }

        .traversal-controls {
            display: flex;
            gap: 1vw;
            margin-top: 1.5vh; /* Space above controls */
            margin-bottom: 1.5vh; /* Space below controls */
            height: 5vh; /* Fixed height for buttons */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .traversal-controls button {
            flex-grow: 1;
        }

        .explanation-area {
            height: 5vh; /* Fixed height for explanation */
            border: 1px solid var(--light-gray);
            padding: 0.5vh 1vw; /* Added horizontal padding */
            box-sizing: border-box;
            margin-bottom: 1vh;
            overflow: hidden; /* Prevent overflow */
            display: flex; /* Center text vertically */
            align-items: center;
            background-color: var(--extra-light-gray);
            font-size: 0.9em;
            white-space: nowrap; /* Prevent line breaks for short text */
            text-overflow: ellipsis; /* Add ellipsis if text is too long */
        }

        .output-area {
            height: 9vh; /* Adjusted height for output */
            border: 1px solid var(--light-gray);
            padding: 0.5vh 1vw; /* Added horizontal padding */
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if order is very long */
            word-break: break-word; /* Break long words */
            font-size: 0.9em;
            background-color: var(--extra-light-gray);
            flex-shrink: 0; /* Prevent shrinking */
        }
    </style>
</head>
<body>

    <header>
        <img src="https://media.geeksforgeeks.org/gfg-gg-logo.svg" alt="GeeksforGeeks Logo">
        <h1>Depth First Search Visualizer</h1>
    </header>

    <main class="main-content">
        <div class="left-panel">
            <div class="input-group">
                <label for="graphInput">Enter Graph (e.g., A-B, A-C, B-D):</label>
                <textarea id="graphInput">A-B,A-C,B-D,C-E,D-F,E-F</textarea>
            </div>

             <div class="input-group">
                <label for="startNodeInput">Start Node:</label>
                <input type="text" id="startNodeInput" value="A">
            </div>

             <div class="checkbox-group">
                 <input type="checkbox" id="showVisitedCheckbox" checked>
                 <label for="showVisitedCheckbox">Show Visited Status during Animation</label>
             </div>

            <div class="button-group">
                <button id="randomizeButton">Randomize</button>
                <button id="resetButton">Reset</button>
            </div>
        </div>

        <div class="right-panel">
            <canvas id="visualizationCanvas"></canvas>

            <div class="traversal-controls">
                <button id="autoRunButton">Auto-Run</button>
                <button id="nextStepButton">Next Step</button>
            </div>

            <div class="explanation-area" id="explanationText">Waiting for input...</div>

            <div class="output-area" id="traversalOrderOutput">Traversal Order: </div>
        </div>
    </main>

    <footer>
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        // --- Configuration ---
        const NODE_RADIUS = 20;
        const AUTO_RUN_DELAY_MS = 800;

        // --- DOM Elements ---
        const canvas = document.getElementById('visualizationCanvas');
        const ctx = canvas.getContext('2d');
        const graphInput = document.getElementById('graphInput');
        const startNodeInput = document.getElementById('startNodeInput');
        const showVisitedCheckbox = document.getElementById('showVisitedCheckbox');
        const randomizeButton = document.getElementById('randomizeButton');
        const resetButton = document.getElementById('resetButton');
        const autoRunButton = document.getElementById('autoRunButton');
        const nextStepButton = document.getElementById('nextStepButton');
        const explanationText = document.getElementById('explanationText');
        const traversalOrderOutput = document.getElementById('traversalOrderOutput');

        // --- Graph and Algorithm State ---
        let adjacencyList = {};
        let nodes = {}; // { label: { x, y } }
        let visited = new Set();
        let traversalOrder = [];
        let algorithmStack = []; // Simulates the DFS stack for visualization in step data
        let currentStep = 0;
        let algorithmSteps = []; // Stores sequence of steps for playback
        let animationTimer = null; // For auto-run
        let algorithmRunning = false;

        // --- Canvas Drawing Functions ---

        // Simple circular layout for nodes
        function layoutNodes(graphAdjList, canvasWidth, canvasHeight) {
            const nodeLabels = Object.keys(graphAdjList);
            const numNodes = nodeLabels.length;
            if (numNodes === 0) return {};

            const center_x = canvasWidth / 2;
            const center_y = canvasHeight / 2;
            const radius = Math.min(center_x, center_y) * 0.7; // Use 70% of the smaller half dimension

            const newNodes = {};
            nodeLabels.forEach((label, i) => {
                const angle = (i / numNodes) * 2 * Math.PI - Math.PI / 2; // Start from top
                newNodes[label] = {
                    x: center_x + radius * Math.cos(angle),
                    y: center_y + radius * Math.sin(angle),
                    label: label
                };
            });
            return newNodes;
        }

        function drawGraph(currentNodeLabel = null) {
            // Use computed styles for colors
            const nodeColor = getComputedStyle(document.documentElement).getPropertyValue('--white').trim();
            const nodeBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--black').trim();
            const nodeTextColor = getComputedStyle(document.documentElement).getPropertyValue('--black').trim();
            const edgeColor = getComputedStyle(document.documentElement).getPropertyValue('--light-gray').trim();
            const currentNodeBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-green').trim();
            const visitedNodeColor = getComputedStyle(document.documentElement).getPropertyValue('--visited-node-color').trim();


            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const showVisited = showVisitedCheckbox.checked;

            // Draw Edges
            ctx.strokeStyle = edgeColor;
            ctx.lineWidth = 1;
            const drawnEdges = new Set(); // To avoid drawing duplicates in undirected graph

            for (const [nodeLabel, neighbors] of Object.entries(adjacencyList)) {
                 const nodePos = nodes[nodeLabel];
                 if (!nodePos) continue;

                 for (const neighborLabel of neighbors) {
                     const neighborPos = nodes[neighborLabel];
                     if (!neighborPos) continue;

                     // Ensure edge is drawn only once for undirected graph (e.g., A-B, but not B-A if A-B drawn)
                     const edgeKey = nodeLabel < neighborLabel ? `${nodeLabel}-${neighborLabel}` : `${neighborLabel}-${nodeLabel}`;
                     if (!drawnEdges.has(edgeKey)) {
                         ctx.beginPath();
                         ctx.moveTo(nodePos.x, nodePos.y);
                         ctx.lineTo(neighborPos.x, neighborPos.y);
                         ctx.stroke();
                         drawnEdges.add(edgeKey);
                     }
                 }
            }

            // Draw Nodes
            for (const [label, pos] of Object.entries(nodes)) {
                const isCurrent = label === currentNodeLabel; // Use the passed current node label for highlighting
                const isVisited = visited.has(label); // Use the global visited set

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, NODE_RADIUS, 0, Math.PI * 2);

                // Node Fill
                // Show visited fill only if checkbox is checked OR at the very end state
                if (isVisited && (showVisited || currentStep >= algorithmSteps.length - 1)) { // -1 because the 'end' step also needs final state
                     ctx.fillStyle = visitedNodeColor;
                } else {
                     ctx.fillStyle = nodeColor;
                }
                ctx.fill();

                // Node Border
                ctx.strokeStyle = isCurrent ? currentNodeBorderColor : nodeBorderColor;
                ctx.lineWidth = isCurrent ? 3 : 1;
                ctx.stroke();

                // Node Label
                ctx.fillStyle = nodeTextColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${NODE_RADIUS * 0.8}px monospace`;
                ctx.fillText(label, pos.x, pos.y);
            }
        }

        // --- Graph Parsing and Setup ---

        function parseGraph(graphText) {
            const adj = {};
            const edges = graphText.split(',').map(edge => edge.trim()).filter(edge => edge !== '');
            const nodeSet = new Set();

            for (const edge of edges) {
                const parts = edge.split('-');
                if (parts.length !== 2) {
                    continue; // Skip invalid edges
                }
                const u = parts[0].trim();
                const v = parts[1].trim();

                if (u === '' || v === '') {
                    continue; // Skip edges with empty node names
                }

                if (!adj[u]) adj[u] = [];
                if (!adj[v]) adj[v] = [];

                // Simple undirected graph
                adj[u].push(v);
                adj[v].push(u);

                nodeSet.add(u);
                nodeSet.add(v);
            }

            // Remove duplicates and sort neighbors for consistent order
            for (const node in adj) {
                 adj[node] = Array.from(new Set(adj[node])).sort();
            }

            return { adj, nodeSet: Array.from(nodeSet).sort() };
        }

        function setupGraph() {
            // Stop any running animation
            clearInterval(animationTimer);
            animationTimer = null;
            algorithmRunning = false;
            autoRunButton.textContent = "Auto-Run";

            const graphText = graphInput.value;
            const startNodeLabel = startNodeInput.value.trim();

            const { adj, nodeSet } = parseGraph(graphText);
            adjacencyList = adj;

            if (Object.keys(adjacencyList).length === 0) {
                explanationText.textContent = "Graph is empty or invalid.";
                resetAlgorithmState(false); // Reset state, keep inputs
                // Clear canvas if graph is empty
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                disableTraversalButtons();
                return false;
            }

            if (!nodeSet.includes(startNodeLabel)) {
                explanationText.textContent = `Error: Start node "${startNodeLabel}" not found in graph.`;
                resetAlgorithmState(false); // Reset state, keep inputs
                 // Draw the parsed graph even if start node is invalid
                // Resize canvas first
                 canvas.width = canvas.clientWidth;
                 canvas.height = canvas.clientHeight;
                 if(canvas.width === 0 || canvas.height === 0) { // Fallback size
                     canvas.width = 700;
                     canvas.height = canvas.clientWidth * (9/16); // Maintain aspect ratio approximation
                 }
                 nodes = layoutNodes(adjacencyList, canvas.width, canvas.height);
                 drawGraph(); // Draw graph in initial state
                 disableTraversalButtons(); // Cannot run without valid start
                return false;
            }

             // Calculate node positions
             // Resize canvas to fit panel dimensions *before* layout
             canvas.width = canvas.clientWidth;
             canvas.height = canvas.clientHeight;
              if(canvas.width === 0 || canvas.height === 0) { // Fallback size
                  canvas.width = 700;
                  canvas.height = canvas.clientWidth * (9/16);
              }

            nodes = layoutNodes(adjacencyList, canvas.width, canvas.height);

            resetAlgorithmState(false); // Reset animation state, keep inputs and graph data
            explanationText.textContent = `Ready to start DFS from node "${startNodeLabel}". Press "Next Step" or "Auto-Run".`;
            traversalOrderOutput.textContent = "Traversal Order: ";

            // Pre-calculate algorithm steps
            precalculateDFSSteps(startNodeLabel);

            drawGraph(); // Draw initial graph state
            enableTraversalButtons();

            return true; // Graph setup successful
        }

        function resetAlgorithmState(clearInputs = true) {
            visited = new Set();
            traversalOrder = [];
            algorithmStack = []; // Reset stack representation
            currentStep = 0; // Reset step index
            algorithmSteps = []; // Clear pre-calculated steps
            clearInterval(animationTimer);
            animationTimer = null;
            algorithmRunning = false;
            autoRunButton.textContent = "Auto-Run";

            // Reset text areas
            explanationText.textContent = 'Graph reset. Enter or Randomize a graph, set start node.';
            traversalOrderOutput.textContent = 'Traversal Order: ';

             // Clear inputs only if requested (default is false to keep inputs on "Reset" button)
             if (clearInputs) {
                graphInput.value = '';
                startNodeInput.value = '';
                adjacencyList = {}; // Also clear graph data if inputs are cleared
                nodes = {}; // Clear node positions
             }

             // Disable traversal buttons until graph is set up
            disableTraversalButtons();

             // Draw the graph in its initial state (or clear canvas if no nodes)
             if (Object.keys(nodes).length > 0) {
                 drawGraph(); // Draw graph with no traversal state
             } else {
                 ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas if no nodes
             }

             // Ensure Randomize/Reset are always enabled
             randomizeButton.disabled = false;
             resetButton.disabled = false;
        }

        function disableTraversalButtons() {
            autoRunButton.disabled = true;
            nextStepButton.disabled = true;
        }

        function enableTraversalButtons() {
             // Only enable if there are steps to run
            if (algorithmSteps.length > 0 && currentStep < algorithmSteps.length) {
                // Auto-run becomes pause if running
                if (algorithmRunning) {
                    autoRunButton.disabled = false; // Can always pause
                    nextStepButton.disabled = true; // Cannot step manually when auto-running
                } else {
                     // Not running, enable step and auto-run
                    autoRunButton.disabled = false;
                    nextStepButton.disabled = false;
                }
            } else {
                 // No steps left or algorithmSteps is empty
                 disableTraversalButtons();
            }
        }

        // Pre-calculate algorithm steps based on iterative DFS with explicit stack simulation
        function precalculateDFSSteps(startNodeLabel) {
            const visitedSet = new Set();
            const stack = []; // Explicit stack for iterative DFS simulation during pre-calculation
            const steps = [];
            const adj = adjacencyList;

            // Check if start node exists in the parsed graph
             if (!adj[startNodeLabel]) {
                 steps.push({ type: 'error', explanation: `Start node "${startNodeLabel}" not found in graph.`, state: { visited: new Set(), stack: [], order: [], current: null } });
                 algorithmSteps = steps;
                 return;
            }

            // Step 0: Initial state
            steps.push({ type: 'start', explanation: `Starting DFS from node "${startNodeLabel}".`, state: { visited: new Set(), stack: [], order: [], current: null } });

            // Step 1: Push start node
            stack.push(startNodeLabel);
            steps.push({ type: 'push_initial', node: startNodeLabel, explanation: `Pushing start node "${startNodeLabel}" onto stack. Stack: [${stack.join(', ')}]`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: null } });

            while (stack.length > 0) {
                 const currentNodeLabel = stack[stack.length - 1]; // Peek

                // Step: Peek the top node (checking what's next)
                steps.push({ type: 'peek', node: currentNodeLabel, explanation: `Checking top of stack: "${currentNodeLabel}". Stack: [${stack.join(', ')}]`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: currentNodeLabel } });

                // If the node at the top of the stack is NOT visited when we peek...
                if (!visitedSet.has(currentNodeLabel)) {

                    // Step: Pop and Visit node
                    const processingNode = stack.pop(); // *** POP for processing ***
                    visitedSet.add(processingNode); // Mark as visited
                    traversalOrder.push(processingNode); // Add to traversal order

                    steps.push({ type: 'visit', node: processingNode, explanation: `Popped "${processingNode}". Visiting node "${processingNode}". Traversal order: ${traversalOrder.join(' -> ')}.`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: processingNode } });

                    // Step: Explore Neighbors (Add unvisited neighbors to stack)
                    const neighbors = adj[processingNode] || [];
                    const unvisitedNeighbors = neighbors.filter(n => !visitedSet.has(n)).sort(); // Sort neighbors for deterministic order

                    if (unvisitedNeighbors.length > 0) {
                         // Push neighbors onto stack in reverse sorted order to process them in sorted order
                         steps.push({ type: 'explore_neighbors_start', node: processingNode, explanation: `Exploring unvisited neighbors of "${processingNode}" (${unvisitedNeighbors.join(', ')})...`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: processingNode } });

                         for (let i = unvisitedNeighbors.length - 1; i >= 0; i--) {
                             const neighbor = unvisitedNeighbors[i];
                             stack.push(neighbor);
                             steps.push({ type: 'push_neighbor', node: neighbor, from: processingNode, explanation: `Pushing neighbor "${neighbor}" onto stack. Stack: [${stack.join(', ')}]`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: processingNode } }); // Current node is still the one whose neighbors we are exploring
                         }
                         // After pushing neighbors, the 'current' node is still the one whose neighbors were explored
                         steps.push({ type: 'explore_neighbors_end', node: processingNode, explanation: `Finished exploring neighbors of "${processingNode}". Stack: [${stack.join(', ')}]`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: processingNode } });

                    } else {
                         // Node has no unvisited neighbors to push
                         steps.push({ type: 'no_unvisited_neighbors', node: processingNode, explanation: `Node "${processingNode}" has no unvisited neighbors.`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: processingNode } });
                    }

                } else {
                     // Node was already visited when we peeked it.
                     // This means we reached it again via another path or backtracked. We just pop it off the stack.
                     const processingNode = stack.pop(); // *** POP for backtracking ***
                     steps.push({ type: 'already_visited_pop', node: processingNode, explanation: `Node "${processingNode}" already visited. Popping from stack (Backtrack). Stack: [${stack.join(', ')}]`, state: { visited: new Set(visitedSet), stack: [...stack], order: [...traversalOrder], current: null } }); // Current node becomes null when backtracking from an already visited node popped from stack
                }
            }

            // Final step: DFS complete
            steps.push({ type: 'end', explanation: "DFS Complete.", state: { visited: new Set(visitedSet), stack: [], order: [...traversalOrder], current: null } });

            algorithmSteps = steps;
            // console.log("Pre-calculated steps:", algorithmSteps); // Debugging
        }

        // --- Algorithm Execution ---

        function executeStep() {
            if (currentStep >= algorithmSteps.length) {
                // Traversal is complete
                clearInterval(animationTimer);
                animationTimer = null;
                algorithmRunning = false;
                explanationText.textContent = "DFS traversal finished.";
                autoRunButton.textContent = "Auto-Run"; // Reset button text
                disableTraversalButtons(); // Disable until reset/new graph
                resetButton.disabled = false; // Ensure reset is enabled
                randomizeButton.disabled = false;
                drawGraph(null); // Draw final state (all visited shown)
                return false; // Indicate complete
            }

            const step = algorithmSteps[currentStep];

            // Restore state from the step object
            // Need to handle cases where state might not have all properties for specific step types
            visited = new Set(step.state.visited || []);
            algorithmStack = [...step.state.stack || []]; // Keep this updated for potential display
            traversalOrder = [...step.state.order || []];

            explanationText.textContent = step.explanation;
            traversalOrderOutput.textContent = "Traversal Order: " + traversalOrder.join(" -> ");

            // Draw the graph state for this step
            // Pass the 'current' node label from the step state for highlighting
            drawGraph(step.state.current || null); // Pass current node label

            currentStep++;
            return true; // Indicate step was executed
        }

        function autoRun() {
            if (algorithmRunning) {
                // Pause
                clearInterval(animationTimer);
                animationTimer = null;
                algorithmRunning = false;
                autoRunButton.textContent = "Auto-Run";
                enableTraversalButtons(); // Re-enable next step
            } else {
                // Start/Resume
                algorithmRunning = true;
                autoRunButton.textContent = "Pause";
                nextStepButton.disabled = true; // Disable manual step during auto-run

                 // Execute the first step immediately when starting auto-run
                 const executedFirstStep = executeStep();

                if(executedFirstStep) { // If there was a step to execute
                    enableTraversalButtons(); // Update button states after executing a step
                    animationTimer = setInterval(() => {
                        const executed = executeStep();
                        if (!executed) {
                            // Animation finished via executeStep's return
                            clearInterval(animationTimer);
                            animationTimer = null;
                            algorithmRunning = false;
                            autoRunButton.textContent = "Auto-Run";
                            enableTraversalButtons(); // Update button states
                        }
                    }, AUTO_RUN_DELAY_MS);
                 } else {
                      // If executeStep returned false immediately, algo was already done or no steps
                      clearInterval(animationTimer);
                      animationTimer = null;
                      algorithmRunning = false;
                      autoRunButton.textContent = "Auto-Run";
                      enableTraversalButtons(); // Update button states
                 }
            }
        }

        function nextStep() {
            if (!algorithmRunning) { // Only allow manual step if not auto-running
                 executeStep();
                 // After executing one step, enable/disable buttons
                 enableTraversalButtons();
            }
        }

        // --- Random Graph Generation ---

        function generateRandomGraph(minNodes, maxNodes) {
            const numNodes = Math.floor(Math.random() * (maxNodes - minNodes + 1)) + minNodes;
            const nodes = Array.from({ length: numNodes }, (_, i) => String.fromCharCode(65 + i)); // A, B, C...
            const adj = {};
            nodes.forEach(node => adj[node] = []);
            const edges = new Set();

            if (numNodes > 1) {
                 // Ensure connectivity by creating a tree (spanning tree)
                 // Connect node i to a random node j where j < i
                 for (let i = 1; i < numNodes; i++) {
                     const u = nodes[i];
                     const v = nodes[Math.floor(Math.random() * i)]; // Connect to a random node from 0 to i-1
                     const edge = u < v ? `${u}-${v}` : `${v}-${u}`; // Canonical edge string
                     if (!edges.has(edge)) {
                         adj[u].push(v);
                         adj[v].push(u);
                         edges.add(edge);
                     }
                 }

                 // Add some random extra edges (optional, create a graph that's not just a tree)
                 const maxPossibleEdges = numNodes * (numNodes - 1) / 2;
                 const targetEdges = Math.min(maxPossibleEdges, edges.size + Math.floor(Math.random() * numNodes * 0.8)); // Add up to ~N*0.8 more edges

                 while (edges.size < targetEdges) {
                      const u = nodes[Math.floor(Math.random() * numNodes)];
                      const v = nodes[Math.floor(Math.random() * numNodes)];
                      if (u === v) continue;

                      const edge = u < v ? `${u}-${v}` : `${v}-${u}`;
                      if (!edges.has(edge)) {
                          adj[u].push(v);
                          adj[v].push(u);
                          edges.add(edge);
                      }
                 }
            }


            // Sort neighbors for consistency
             for (const node in adj) {
                 adj[node] = Array.from(new Set(adj[node])).sort();
             }

            const edgeList = Array.from(edges).join(',');
            const startNode = nodes.length > 0 ? nodes[0] : ''; // Start at the first node ('A')

            return { edgeList, startNode };
        }

        function handleRandomize() {
            const { edgeList, startNode } = generateRandomGraph(5, 12); // 5-12 nodes as requested
            graphInput.value = edgeList;
            startNodeInput.value = startNode;
            setupGraph(); // Automatically set up the generated graph
        }


        // --- Initialization ---

        function init() {
             // Disable traversal buttons initially
             disableTraversalButtons();

            // Add event listeners
            randomizeButton.addEventListener('click', handleRandomize);
            resetButton.addEventListener('click', setupGraph); // Reset button re-sets up the current graph input

             // Listen for input changes to clear algorithm state, prompting user to apply changes
             graphInput.addEventListener('input', () => {
                 // Clear algorithm state, but keep inputs and layout
                 resetAlgorithmState(false); // Don't clear inputs
                 explanationText.textContent = 'Graph input changed. Press "Reset" or "Randomize" to update.';
                 disableTraversalButtons(); // Cannot run with potentially invalid/unparsed input state
                 randomizeButton.disabled = false;
                 resetButton.disabled = false;

                 // Attempt to re-parse and re-layout visually, but don't precalculate steps yet
                 try {
                     const { adj, nodeSet } = parseGraph(graphInput.value);
                     adjacencyList = adj; // Update adjacency list
                      if (Object.keys(adjacencyList).length > 0) {
                           canvas.width = canvas.clientWidth;
                           canvas.height = canvas.clientHeight;
                           if(canvas.width === 0 || canvas.height === 0) {
                               canvas.width = 700;
                               canvas.height = canvas.clientWidth * (9/16);
                           }
                           nodes = layoutNodes(adjacencyList, canvas.width, canvas.height); // Recalculate layout
                           drawGraph(); // Draw updated graph structure
                      } else {
                           nodes = {}; // Clear nodes if graph is empty
                           ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
                      }
                 } catch (e) {
                     // Ignore parsing/layout errors during live input, they'll be caught by setupGraph on button click
                     nodes = {};
                     ctx.clearRect(0, 0, canvas.width, canvas.height);
                 }
             });

             startNodeInput.addEventListener('input', () => {
                  // Clear algorithm state, but keep inputs and layout
                 resetAlgorithmState(false); // Don't clear inputs
                 explanationText.textContent = 'Start node input changed. Press "Reset" or "Randomize" to update.';
                 disableTraversalButtons(); // Cannot run with potentially invalid/unparsed input state
                 randomizeButton.disabled = false;
                 resetButton.disabled = false;
                 // Redraw graph with current nodes but no traversal state
                 if (Object.keys(nodes).length > 0) {
                     drawGraph();
                 }
             });


             // Set initial canvas size based on its container
             canvas.width = canvas.clientWidth;
             canvas.height = canvas.clientHeight;
              if(canvas.width === 0 || canvas.height === 0) { // Fallback size if container has no dimensions yet
                  canvas.width = 700;
                  canvas.height = canvas.clientWidth * (9/16);
              }

            // Initial setup with the default graph/start node in HTML
            setupGraph();

            // Redraw on window resize (layout is fixed, but canvas needs resizing and redraw)
            window.addEventListener('resize', () => {
                 canvas.width = canvas.clientWidth;
                 canvas.height = canvas.clientHeight;
                  if(canvas.width === 0 || canvas.height === 0) { // Fallback size
                      canvas.width = 700;
                      canvas.height = canvas.clientWidth * (9/16);
                  }
                 // Re-layout nodes based on new size and redraw
                 if (Object.keys(adjacencyList).length > 0) {
                      nodes = layoutNodes(adjacencyList, canvas.width, canvas.height);
                      // Redraw using the current step's state to maintain animation progress visually if running/paused
                      if (currentStep > 0 && currentStep <= algorithmSteps.length) {
                           // Get the state from the step that *just finished* (index currentStep-1)
                           const lastStepState = algorithmSteps[currentStep - 1].state;
                           drawGraph(lastStepState.current || null);
                      } else {
                           drawGraph(null); // Draw initial state if not started or finished
                      }
                 } else {
                      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear if empty
                 }
            });
        }

        // Run initialization when the DOM is ready
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
