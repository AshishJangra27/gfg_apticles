
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python List Explorer</title>
    <style>
        /* Basic Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: monospace;
            background-color: #ffffff;
            color: #000000;
            overflow: hidden; /* Prevent scrolling */
            display: grid;
            grid-template-rows: 10vh 83vh 7vh;
            grid-template-columns: 100vw;
            height: 100vh; /* Ensure body takes full viewport height */
        }

        /* Green Accent */
        :root {
            --green-accent: #2f8d46;
            --light-gray: #cccccc;
        }

        /* Header */
        .header {
            grid-row: 1;
            grid-column: 1;
            display: flex;
            align-items: center;
            padding: 0 2vw;
            border-bottom: 1px solid var(--light-gray);
            justify-content: space-between;
        }

        .header img {
            height: 32px; /* Fixed height for logo */
            vertical-align: middle;
        }

        .header h1 {
            font-size: 1.8vh; /* Relative font size */
            flex-grow: 1;
            text-align: center;
            margin-left: 2vw; /* Space after logo */
        }

        .header .global-controls button {
            margin-left: 10px;
            padding: 0.5vh 1vw;
            background-color: #fff;
            border: 1px solid var(--green-accent);
            color: var(--green-accent);
            cursor: pointer;
            font-family: monospace;
            font-size: 1.5vh;
        }

        .header .global-controls button:hover {
            background-color: var(--green-accent);
            color: #fff;
        }

        /* Main Content Area */
        .main-content {
            grid-row: 2;
            grid-column: 1;
            display: grid;
            grid-template-columns: 65vw 35vw; /* List Viz and Controls/Feedback */
            grid-template-rows: 54vh 29vh; /* List Viz/Controls and Object Pool */
            padding: 1vh 2vw;
            gap: 1vh;
        }

        .list-visualization-panel {
            grid-area: 1 / 1 / 2 / 2; /* Row 1, Col 1 */
            border: 1px solid var(--light-gray);
            padding: 1vh;
            overflow-x: auto; /* Allow horizontal scrolling if list grows too large */
            overflow-y: hidden;
            white-space: nowrap; /* Keep elements in a single line */
            display: flex;
            align-items: flex-start; /* Align elements to the top */
        }

        .controls-feedback-panel {
            grid-area: 1 / 2 / 2 / 3; /* Row 1, Col 2 */
            border: 1px solid var(--light-gray);
            padding: 1vh;
            display: flex;
            flex-direction: column;
        }

        .object-pool-visualization-panel {
            grid-area: 2 / 1 / 3 / 3; /* Row 2, spans both columns */
            border: 1px solid var(--light-gray);
            padding: 1vh;
            overflow-x: auto; /* Allow horizontal scrolling */
            overflow-y: hidden;
        }

        .controls-group {
            margin-bottom: 1.5vh;
            padding-bottom: 1.5vh;
            border-bottom: 1px dashed var(--light-gray);
        }

        .controls-group:last-child {
             border-bottom: none;
        }

        .controls-group label {
            display: block;
            margin-bottom: 0.5vh;
            font-size: 1.4vh;
        }

         .controls-group input[type="text"],
         .controls-group input[type="number"],
         .controls-group button {
            padding: 0.4vh 0.5vw;
            margin-right: 0.5vw;
            font-size: 1.4vh;
            font-family: monospace;
            border: 1px solid var(--light-gray);
        }

        .controls-group input[type="text"],
         .controls-group input[type="number"] {
            width: 8vw; /* Fixed width for inputs */
        }

         .controls-group button {
            background-color: #fff;
            color: var(--green-accent);
            border-color: var(--green-accent);
            cursor: pointer;
         }

         .controls-group button:hover {
            background-color: var(--green-accent);
            color: #fff;
         }

        .feedback-area {
            margin-top: auto; /* Push feedback to the bottom */
            border-top: 1px dashed var(--light-gray);
            padding-top: 1vh;
            min-height: 4vh; /* Reserve space for 2 lines */
            font-size: 1.4vh;
            color: #555;
        }

        /* List/Object Element Styling */
        .list-container, .object-container {
             display: flex; /* Use flexbox for horizontal layout */
             align-items: flex-start; /* Align elements to the top */
             gap: 1vw; /* Space between elements */
             padding-bottom: 1vh; /* Space for potential links/arrows below */
        }

        .object-pool-item {
            border: 1px solid var(--light-gray);
            padding: 1vh;
            margin-bottom: 1vh;
        }

        .object-pool-item-label {
            font-size: 1.4vh;
            font-weight: bold;
            margin-bottom: 0.5vh;
        }


        .list-element, .object-element {
            display: inline-block; /* Or use flex item */
            border: 1px solid #000;
            padding: 0.5vh 0.8vw;
            text-align: center;
            position: relative;
            min-width: 5vw; /* Minimum width */
             min-height: 5vh; /* Minimum height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
             transition: border-color 0.3s ease, background-color 0.3s ease;
        }

        .list-element .index, .object-element .index {
            position: absolute;
            top: -1.8vh; /* Position index above box */
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.3vh;
            color: #555;
        }

        .list-element .value, .object-element .value {
            font-size: 1.5vh;
            word-break: break-all; /* Break long values */
        }

        .list-element.highlight, .object-element.highlight {
            border-color: var(--green-accent);
            background-color: #e9f5e9; /* Light green background */
        }

        .list-element.highlight-border, .object-element.highlight-border {
             border-color: var(--green-accent);
        }

         .list-element.highlight-background, .object-element.highlight-background {
             background-color: #e9f5e9;
         }

        /* Footer */
        .footer {
            grid-row: 3;
            grid-column: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            border-top: 1px solid var(--light-gray);
        }

        .footer a {
            color: var(--green-accent);
            text-decoration: none;
            margin: 0 1vw;
            font-size: 1.4vh;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <div class="header">
        <img src="https://media.geeksforgeeks.org/gfg-gg-logo.svg" alt="GeeksforGeeks Logo">
        <h1>Python List Explorer</h1>
        <div class="global-controls">
            <button id="resetBtn">Reset</button>
            <button id="randomizeBtn">Randomize</button>
            <button id="autoRunBtn">Auto-Run Demo</button>
            <button id="nextStepBtn" disabled>Next Step</button>
        </div>
    </div>

    <div class="main-content">
        <div class="list-visualization-panel" id="listVisualization">
             <!-- List elements will be rendered here -->
             <div class="list-container"></div>
        </div>

        <div class="controls-feedback-panel">
            <div class="controls-group">
                <label>Access/Modify by Index:</label>
                <input type="number" id="getIndexInput" placeholder="Index">
                <input type="text" id="setValueInput" placeholder="New Value (optional)">
                <button id="setBtn">Get/Set Element</button>
            </div>

             <div class="controls-group">
                <label>Append Element:</label>
                <input type="text" id="appendValueInput" placeholder="Value to Append">
                <button id="appendBtn">Append Value</button>
            </div>

            <div class="controls-group">
                <label>Insert Element:</label>
                <input type="number" id="insertIndexInput" placeholder="Index">
                <input type="text" id="insertValueInput" placeholder="Value to Insert">
                <button id="insertBtn">Insert Value</button>
            </div>

            <div class="controls-group">
                <label>Remove by Value:</label>
                <input type="text" id="removeValueInput" placeholder="Value to Remove">
                <button id="removeBtn">Remove First Occurrence</button>
            </div>

            <div class="controls-group">
                <label>Remove by Index (Pop):</label>
                <input type="number" id="popIndexInput" placeholder="Index to Pop">
                <button id="popBtn">Pop Element</button>
            </div>

            <div class="feedback-area" id="feedback">
                Ready.
            </div>
        </div>

        <div class="object-pool-visualization-panel" id="objectPoolVisualization">
            <!-- Object Pool items will be rendered here -->
            <div class="object-pool-container"></div>
        </div>
    </div>

    <div class="footer">
        <a href="https://github.com/AshishJangra27/" target="_blank">[GitHub]</a>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">[LinkedIn]</a>
    </div>

    <script>
        let myList = []; // The main Python list representation (JS Array)
        let objectPool = {}; // Stores complex objects (nested lists, etc.) by ID
        let nextObjectId = 1; // Counter for unique object IDs

        // --- DOM References ---
        const listContainer = document.querySelector('#listVisualization .list-container');
        const objectPoolContainer = document.querySelector('#objectPoolVisualization .object-pool-container');
        const feedbackArea = document.getElementById('feedback');

        // Controls
        const getIndexInput = document.getElementById('getIndexInput');
        const setValueInput = document.getElementById('setValueInput');
        const setBtn = document.getElementById('setBtn');
        const appendValueInput = document.getElementById('appendValueInput');
        const appendBtn = document.getElementById('appendBtn');
        const insertIndexInput = document.getElementById('insertIndexInput');
        const insertValueInput = document.getElementById('insertValueInput');
        const insertBtn = document.getElementById('insertBtn');
        const removeValueInput = document.getElementById('removeValueInput');
        const removeBtn = document.getElementById('removeBtn');
        const popIndexInput = document.getElementById('popIndexInput');
        const popBtn = document.getElementById('popBtn');

        // Global Controls
        const resetBtn = document.getElementById('resetBtn');
        const randomizeBtn = document.getElementById('randomizeBtn');
        const autoRunBtn = document.getElementById('autoRunBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');

        // --- Helper Functions ---

        // Parses input string into appropriate JS type (number, string, array for list)
        function parseInput(inputStr) {
            inputStr = inputStr.trim();
            if (inputStr === "") return null; // Indicate empty input

            // Try parsing as number
            const num = Number(inputStr);
            if (!isNaN(num)) return num;

            // Try parsing as boolean
            if (inputStr.toLowerCase() === 'true') return true;
            if (inputStr.toLowerCase() === 'false') return false;

            // Try parsing as null/None
             if (inputStr.toLowerCase() === 'null' || inputStr.toLowerCase() === 'none') return null;


            // Try parsing as a list literal (basic support)
            if (inputStr.startsWith('[') && inputStr.endsWith(']')) {
                try {
                    // Basic parsing - relies on eval, which is dangerous but simple for demo
                    // A safer approach would be a custom parser
                    const parsedArray = JSON.parse(inputStr.replace(/'/g, '"')); // Replace single quotes with double for JSON
                    // Check if the parsed result is actually an array
                    if (Array.isArray(parsedArray)) {
                         // Recursively parse elements within the nested list
                         const recursivelyParsedArray = parsedArray.map(item => {
                             if (typeof item === 'string') {
                                 // Attempt to re-parse strings within the array in case they were numbers/booleans etc.
                                 const innerParsed = parseInput(item);
                                 return innerParsed !== null ? innerParsed : item; // If parsing fails, keep as string
                             }
                             return item; // Keep other types (numbers, booleans already parsed by JSON)
                         });
                         return recursivelyParsedArray;
                    }
                } catch (e) {
                    console.warn("Could not parse as list:", e);
                    // Fallback to string if list parsing fails
                }
            }

            // Default to string
            return inputStr;
        }

        // Creates a representation object for an element value
        // If value is a mutable object (like Array), adds to pool and returns a reference
        function createValueRepresentation(value) {
            if (Array.isArray(value)) {
                const objId = `obj_${nextObjectId++}`;
                // Store a deep copy or the actual object? For visualization, storing the object allows shared reference demos.
                // Let's store the actual array and wrap its elements recursively.
                objectPool[objId] = { type: 'list', value: value.map(item => createValueRepresentation(item)) }; // Recursively wrap nested list elements
                return { type: 'ref', id: objId };
            } else {
                return { type: 'primitive', value: value };
            }
        }

         // Resolves a reference object to its display value
        function resolveDisplayValue(representation) {
            if (representation.type === 'primitive') {
                // Handle special cases for display (e.g., null, undefined)
                 if (representation.value === null) return 'None'; // Python None
                 if (representation.value === undefined) return 'undefined'; // JS undefined
                 if (typeof representation.value === 'string') return `'${representation.value}'`; // Quote strings
                 return representation.value; // Numbers, booleans etc.
            } else if (representation.type === 'ref') {
                 const obj = objectPool[representation.id];
                 if (obj && obj.type === 'list') {
                      return `[...] (ID: ${representation.id})`; // Show indicator for nested list
                 }
                return `<${representation.id}>`; // Generic object reference
            }
            return 'error'; // Should not happen
        }

        // Gets the actual JS value from a representation
         function getActualValue(representation) {
            if (representation.type === 'primitive') {
                return representation.value;
            } else if (representation.type === 'ref') {
                 const obj = objectPool[representation.id];
                 // For a list ref, return the actual array by recursively resolving elements
                 if (obj && obj.type === 'list') {
                     return obj.value.map(item => getActualValue(item));
                 }
                 return obj ? obj.value : null; // Return the stored object value
            }
            return undefined;
        }


        // Renders the list and object pool to the DOM
        function render() {
            // Clear current visualization
            listContainer.innerHTML = '';
            objectPoolContainer.innerHTML = '';

            // Render main list
            myList.forEach((item, index) => {
                const elementDiv = document.createElement('div');
                elementDiv.classList.add('list-element');
                elementDiv.dataset.index = index; // Store index
                elementDiv.dataset.type = item.type; // Store type (primitive/ref)
                if (item.type === 'ref') {
                     elementDiv.dataset.objectId = item.id; // Store object ID if it's a reference
                     elementDiv.classList.add('list-element-ref'); // Class for reference type
                }

                const indexSpan = document.createElement('span');
                indexSpan.classList.add('index');
                indexSpan.textContent = index;

                const valueSpan = document.createElement('span');
                valueSpan.classList.add('value');
                valueSpan.textContent = resolveDisplayValue(item);

                elementDiv.appendChild(indexSpan);
                elementDiv.appendChild(valueSpan);

                // Add click listener for reference types to highlight object pool item
                if (item.type === 'ref') {
                    elementDiv.addEventListener('click', () => {
                         highlightObjectPoolItem(item.id);
                         feedbackArea.textContent = `Selected element at index ${index}, referencing ${item.id}.`;
                    });
                }

                listContainer.appendChild(elementDiv);
            });

            // Render object pool
            for (const objId in objectPool) {
                 const obj = objectPool[objId];
                 const poolItemDiv = document.createElement('div');
                 poolItemDiv.classList.add('object-pool-item');
                 poolItemDiv.dataset.objectId = objId; // Store object ID

                 const label = document.createElement('div');
                 label.classList.add('object-pool-item-label');
                 label.textContent = `${objId}:`; // Display object ID as label
                 poolItemDiv.appendChild(label);

                 // Render the content of the object (assuming it's a list for now)
                 if (obj.type === 'list') {
                     const objectContainer = document.createElement('div');
                     objectContainer.classList.add('object-container');

                     obj.value.forEach((item, index) => {
                         const elementDiv = document.createElement('div');
                         elementDiv.classList.add('object-element');
                         elementDiv.dataset.index = index; // Store index within the nested list
                         elementDiv.dataset.type = item.type;
                         if (item.type === 'ref') {
                             elementDiv.dataset.objectId = item.id;
                             elementDiv.classList.add('object-element-ref');
                         }
                         elementDiv.dataset.parentObjectId = objId; // Store parent object ID

                         const indexSpan = document.createElement('span');
                         indexSpan.classList.add('index');
                         indexSpan.textContent = index;

                         const valueSpan = document.createElement('span');
                         valueSpan.classList.add('value');
                         valueSpan.textContent = resolveDisplayValue(item);

                         elementDiv.appendChild(indexSpan);
                         elementDiv.appendChild(valueSpan);

                         // Add click listener for interaction within the nested list visualization
                         elementDiv.addEventListener('click', () => {
                              // Example: Allow modifying nested list element directly
                             const newValue = prompt(`Modify ${objId}[${index}]. Enter new value:`);
                             if (newValue !== null) {
                                 try {
                                     const parsedNewValue = parseInput(newValue);
                                      if (parsedNewValue !== null) {
                                           // Update the nested list in the object pool
                                           const newRepresentation = createValueRepresentation(parsedNewValue);
                                           objectPool[objId].value[index] = newRepresentation;
                                           render(); // Re-render everything to show the change
                                           feedbackArea.textContent = `Modified ${objId}[${index}] to ${resolveDisplayValue(newRepresentation)}.`;
                                           highlightElement(`.object-element[data-parent-object-id="${objId}"][data-index="${index}"]`);
                                      }
                                 } catch (e) {
                                      feedbackArea.textContent = `Error modifying ${objId}[${index}]: ${e.message}`;
                                 }
                             }
                         });

                         objectContainer.appendChild(elementDiv);
                     });
                     poolItemDiv.appendChild(objectContainer);
                 } // Add rendering logic for other object types if needed later

                 objectPoolContainer.appendChild(poolItemDiv);
            }
        }

        // Highlights a specific element or set of elements using a CSS selector
        function highlightElement(selector, duration = 1000) {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
                el.classList.add('highlight');
            });
            setTimeout(() => {
                elements.forEach(el => {
                    el.classList.remove('highlight');
                });
            }, duration);
        }

        // Highlights an item in the object pool by its ID
        function highlightObjectPoolItem(objectId, duration = 1000) {
             highlightElement(`.object-pool-item[data-object-id="${objectId}"]`, duration);
             // Also highlight any list elements pointing to this object
             highlightElement(`.list-element-ref[data-object-id="${objectId}"]`, duration);
        }


        // Resets the application state
        function resetApp(initialList = []) {
            myList = initialList.map(item => createValueRepresentation(item));
            objectPool = {}; // Clear object pool on reset
            nextObjectId = 1;
            render();
            feedbackArea.textContent = 'App reset.';
            resetDemo(); // Also reset demo state
        }

        // --- List Operations ---

        function handleGetSet() {
            const index = parseInt(getIndexInput.value);
            const newValueStr = setValueInput.value;

            if (isNaN(index) || index < 0 || index >= myList.length) {
                feedbackArea.textContent = `Error: Invalid index ${index}.`;
                return;
            }

            const elementRepresentation = myList[index];
            const actualValue = getActualValue(elementRepresentation);

            if (newValueStr === "") {
                // Get operation
                feedbackArea.textContent = `Element at index ${index} is ${resolveDisplayValue(elementRepresentation)}. Actual value: ${JSON.stringify(actualValue)}.`;
                highlightElement(`.list-element[data-index="${index}"]`);
                 if (elementRepresentation.type === 'ref') {
                     highlightObjectPoolItem(elementRepresentation.id);
                 }
            } else {
                // Set operation
                try {
                     const parsedNewValue = parseInput(newValueStr);
                     if (parsedNewValue === null && newValueStr !== "null" && newValueStr !== "None") { // Check if input was genuinely empty/whitespace, not the string "null"
                         feedbackArea.textContent = "Error: New value cannot be empty.";
                         return;
                     }

                    const newRepresentation = createValueRepresentation(parsedNewValue);

                     // Check if old element was a reference that is no longer referenced
                     const oldRepresentation = myList[index];
                     if (oldRepresentation.type === 'ref') {
                         // Note: Simple object pool cleanup is tricky without tracking all references.
                         // For this demo, we won't auto-remove from pool, assuming they might be referenced elsewhere.
                         // A real garbage collector is complex.
                     }

                     myList[index] = newRepresentation; // Update the list with the new representation

                     feedbackArea.textContent = `Changed list[${index}] to ${resolveDisplayValue(newRepresentation)}.`;
                     render(); // Re-render the visualization
                     highlightElement(`.list-element[data-index="${index}"]`); // Highlight the changed element
                     if (newRepresentation.type === 'ref') {
                          highlightObjectPoolItem(newRepresentation.id);
                     }

                } catch (e) {
                    feedbackArea.textContent = `Error setting list[${index}]: ${e.message}`;
                }
            }
        }

        function handleAppend() {
            const valueStr = appendValueInput.value;
            if (valueStr.trim() === "") {
                feedbackArea.textContent = "Error: Value to append cannot be empty.";
                return;
            }
            try {
                const parsedValue = parseInput(valueStr);
                 if (parsedValue === null && valueStr !== "null" && valueStr !== "None") {
                     feedbackArea.textContent = "Error: Value to append cannot be empty.";
                     return;
                 }
                const representation = createValueRepresentation(parsedValue);
                myList.push(representation);
                feedbackArea.textContent = `Appended ${resolveDisplayValue(representation)} to the list.`;
                render();
                 // Highlight the newly added element at the end
                 highlightElement(`.list-element[data-index="${myList.length - 1}"]`);
                 if (representation.type === 'ref') {
                      highlightObjectPoolItem(representation.id);
                 }
            } catch (e) {
                feedbackArea.textContent = `Error appending value: ${e.message}`;
            }
        }

        function handleInsert() {
            const index = parseInt(insertIndexInput.value);
            const valueStr = insertValueInput.value;

            if (isNaN(index) || index < 0 || index > myList.length) {
                feedbackArea.textContent = `Error: Invalid index ${index}. Index must be between 0 and ${myList.length}.`;
                return;
            }
            if (valueStr.trim() === "") {
                feedbackArea.textContent = "Error: Value to insert cannot be empty.";
                return;
            }

            try {
                const parsedValue = parseInput(valueStr);
                 if (parsedValue === null && valueStr !== "null" && valueStr !== "None") {
                      feedbackArea.textContent = "Error: Value to insert cannot be empty.";
                     return;
                 }
                const representation = createValueRepresentation(parsedValue);

                myList.splice(index, 0, representation);
                feedbackArea.textContent = `Inserted ${resolveDisplayValue(representation)} at index ${index}.`;
                render();
                // Highlight the newly inserted element
                 highlightElement(`.list-element[data-index="${index}"]`);
                 if (representation.type === 'ref') {
                      highlightObjectPoolItem(representation.id);
                 }
            } catch (e) {
                feedbackArea.textContent = `Error inserting value: ${e.message}`;
            }
        }

        function handleRemoveValue() {
            const valueStr = removeValueInput.value;
             if (valueStr.trim() === "") {
                feedbackArea.textContent = "Error: Value to remove cannot be empty.";
                return;
            }

            try {
                const valueToRemove = parseInput(valueStr); // Parse value to match list element types

                // Find the index of the first occurrence matching the value
                let removeIndex = -1;
                for(let i = 0; i < myList.length; i++) {
                    const actualElementValue = getActualValue(myList[i]);
                    // Use loose equality or specific logic for comparison? Python uses equality.
                    // Simple equality check might not work for nested lists correctly.
                    // For demo, let's compare primitives directly and references by ID/structure.
                     if (myList[i].type === 'primitive' && myList[i].value === valueToRemove) {
                         removeIndex = i;
                         break;
                     } else if (myList[i].type === 'ref' && valueToRemove !== null && typeof valueToRemove === 'object' && Array.isArray(valueToRemove)) {
                         // Basic check: If trying to remove a list literal, compare with the referenced list structure
                         const referencedList = getActualValue(myList[i]);
                         if (JSON.stringify(referencedList) === JSON.stringify(valueToRemove)) {
                             removeIndex = i;
                             break;
                         }
                     }
                }


                if (removeIndex === -1) {
                    feedbackArea.textContent = `Value ${valueStr} not found in the list.`;
                } else {
                     // Highlight before removing
                     highlightElement(`.list-element[data-index="${removeIndex}"]`, 500); // Short highlight before removal

                    // Remove the element
                    const removedRepresentation = myList.splice(removeIndex, 1)[0];

                    feedbackArea.textContent = `Removed first occurrence of value ${valueStr} at index ${removeIndex}.`;
                    // Need a slight delay before rendering to allow highlight to be seen
                    setTimeout(render, 500);

                     // Note: Similar to set, cleanup of the object pool for removed references is complex.
                     // We won't implement garbage collection here.
                }
            } catch (e) {
                feedbackArea.textContent = `Error removing value: ${e.message}`;
            }
        }

        function handlePop() {
            const index = parseInt(popIndexInput.value);

            if (isNaN(index) || index < 0 || index >= myList.length) {
                feedbackArea.textContent = `Error: Invalid index ${index}. Index must be between 0 and ${myList.length - 1}.`;
                return;
            }

            // Highlight before popping
             highlightElement(`.list-element[data-index="${index}"]`, 500); // Short highlight before removal

            // Remove the element and get the removed item
            const removedRepresentation = myList.splice(index, 1)[0];
            const removedValue = getActualValue(removedRepresentation);

            feedbackArea.textContent = `Popped element at index ${index}: ${resolveDisplayValue(removedRepresentation)}. Actual value: ${JSON.stringify(removedValue)}.`;
             // Delay rendering to allow highlight
             setTimeout(render, 500);

             // Note: Similar to set/remove, cleanup of the object pool is not implemented.
        }

         // --- Global Controls ---

         function handleRandomize() {
             // Create a random list structure
             const randomLength = Math.floor(Math.random() * 7) + 3; // 3 to 9 elements
             const newList = [];
             objectPool = {}; // Clear pool for new random list
             nextObjectId = 1;

             function getRandomValue(depth) {
                 const type = Math.random();
                 if (type < 0.4) return Math.floor(Math.random() * 100); // Number
                 if (type < 0.7) { // String
                     const chars = 'abcdefghijklmnopqrstuvwxyz';
                     const len = Math.floor(Math.random() * 5) + 3;
                     let str = '';
                     for(let i=0; i<len; i++) str += chars.charAt(Math.floor(Math.random() * chars.length));
                     return str;
                 }
                 if (type < 0.9 && depth < 2) { // Nested List (limit depth)
                     const nestedLength = Math.floor(Math.random() * 3) + 1; // 1 to 3 elements in nested list
                     const nestedList = [];
                     for(let i=0; i<nestedLength; i++) {
                         nestedList.push(getRandomValue(depth + 1)); // Recurse
                     }
                     return nestedList;
                 }
                 return Math.random() > 0.5 ? true : false; // Boolean
             }

             for(let i = 0; i < randomLength; i++) {
                 newList.push(getRandomValue(0));
             }

             resetApp(newList); // Use reset to initialize with the new random list
             feedbackArea.textContent = 'List randomized.';
         }


        // --- Guided Demo ---
        const demoSteps = [
            { type: 'reset', value: [10, 20, [30, 40], "hello"] },
            { type: 'feedback', message: 'Starting with a list: [10, 20, [30, 40], "hello"]' },
            { type: 'get', index: 0, feedback: 'Accessing element at index 0...' },
            { type: 'feedback', message: 'The element at index 0 is 10.' },
            { type: 'set', index: 1, value: 99, feedback: 'Changing list[1] to 99...' },
             { type: 'feedback', message: 'list[1] is now 99.' },
            { type: 'append', value: 100, feedback: 'Appending 100...' },
            { type: 'feedback', message: '100 is added to the end.' },
            { type: 'insert', index: 2, value: "new item", feedback: 'Inserting "new item" at index 2...' },
             { type: 'feedback', message: '"new item" is now at index 2, subsequent elements shifted.' },
            { type: 'pop', index: 0, feedback: 'Popping element at index 0...' },
            { type: 'feedback', message: 'The first element (10) was removed.' },
            { type: 'remove', value: "hello", feedback: 'Removing first occurrence of "hello"...' },
             { type: 'feedback', message: 'The string "hello" was removed.' },
            { type: 'feedback', message: 'Interacting with nested lists:'},
            { type: 'highlight_ref', index: 2, feedback: 'Observe the element at index 2, it references an object in the pool.' },
            { type: 'set_nested', objectIndex: 0, index: 0, value: 300, feedback: 'Changing the first element of the *nested list* (referenced by list[2])...' }, // This step needs custom handling
             { type: 'feedback', message: 'Note how changing the nested list in the object pool affects the list element referencing it.'},
             { type: 'reset', value: [1, 2, 3]},
             { type: 'feedback', message: 'Demo complete. Resetting list.'}

        ];
        let currentStepIndex = 0;
        let autoRunInterval = null;

        function executeStep(step) {
            feedbackArea.textContent = step.feedback || ''; // Display feedback message if available

            switch (step.type) {
                case 'reset':
                    resetApp(step.value);
                    break;
                case 'get':
                    getIndexInput.value = step.index;
                    setValueInput.value = ''; // Ensure empty for get
                    handleGetSet();
                    break;
                case 'set':
                    getIndexInput.value = step.index;
                    setValueInput.value = typeof step.value === 'object' ? JSON.stringify(step.value) : step.value;
                    handleGetSet();
                    break;
                case 'append':
                    appendValueInput.value = typeof step.value === 'object' ? JSON.stringify(step.value) : step.value;
                    handleAppend();
                    break;
                case 'insert':
                    insertIndexInput.value = step.index;
                    insertValueInput.value = typeof step.value === 'object' ? JSON.stringify(step.value) : step.value;
                    handleInsert();
                    break;
                 case 'remove':
                    removeValueInput.value = typeof step.value === 'object' ? JSON.stringify(step.value) : step.value;
                    handleRemoveValue();
                    break;
                case 'pop':
                    popIndexInput.value = step.index;
                    handlePop();
                    break;
                 case 'feedback':
                     // Feedback is already set at the start of the function
                     break;
                 case 'highlight_ref':
                     highlightElement(`.list-element[data-index="${step.index}"]`);
                     const element = myList[step.index];
                      if (element && element.type === 'ref') {
                           highlightObjectPoolItem(element.id);
                      }
                     break;
                case 'set_nested':
                     // Find the object ID for the element at objectIndex in the main list
                     const mainListElement = myList[step.objectIndex];
                     if (mainListElement && mainListElement.type === 'ref' && objectPool[mainListElement.id]) {
                         const objId = mainListElement.id;
                         const nestedList = objectPool[objId].value;
                         const nestedIndex = step.index;
                         const newValue = step.value;

                         if (nestedIndex >= 0 && nestedIndex < nestedList.length) {
                             const newRepresentation = createValueRepresentation(newValue);
                             nestedList[nestedIndex] = newRepresentation;
                             render(); // Re-render to show the change
                             highlightElement(`.object-element[data-parent-object-id="${objId}"][data-index="${nestedIndex}"]`); // Highlight in object pool
                             highlightElement(`.list-element[data-index="${step.objectIndex}"]`); // Also highlight the main list element referencing it
                             if (newRepresentation.type === 'ref') {
                                 highlightObjectPoolItem(newRepresentation.id); // Highlight new referenced object if created
                             }
                         } else {
                             feedbackArea.textContent = `Error: Invalid nested index ${nestedIndex} for ${objId}.`;
                         }
                     } else {
                          feedbackArea.textContent = `Error: Element at index ${step.objectIndex} is not a valid nested list reference.`;
                     }
                     break;

                default:
                    feedbackArea.textContent = `Unknown step type: ${step.type}`;
            }
        }

        function nextStep() {
            if (currentStepIndex < demoSteps.length) {
                executeStep(demoSteps[currentStepIndex]);
                currentStepIndex++;
                if (currentStepIndex >= demoSteps.length) {
                    nextStepBtn.disabled = true;
                    autoRunBtn.textContent = 'Auto-Run Demo';
                    stopAutoRun();
                }
            }
        }

        function startAutoRun() {
            if (autoRunInterval) return; // Already running
            autoRunBtn.textContent = 'Stop Auto-Run';
            nextStepBtn.disabled = true; // Disable manual step during auto-run
            // Reset demo if already at the end
            if (currentStepIndex >= demoSteps.length) {
                 currentStepIndex = 0;
                 resetApp([]); // Start clean for the demo
            }

            autoRunInterval = setInterval(() => {
                if (currentStepIndex < demoSteps.length) {
                    executeStep(demoSteps[currentStepIndex]);
                    currentStepIndex++;
                } else {
                    stopAutoRun();
                    autoRunBtn.textContent = 'Auto-Run Demo';
                    nextStepBtn.disabled = false; // Re-enable manual step after auto-run
                }
            }, 1500); // Adjust speed (milliseconds per step)
        }

        function stopAutoRun() {
            clearInterval(autoRunInterval);
            autoRunInterval = null;
             autoRunBtn.textContent = 'Auto-Run Demo';
             nextStepBtn.disabled = false; // Re-enable manual step
        }

        function resetDemo() {
            stopAutoRun();
            currentStepIndex = 0;
            nextStepBtn.disabled = false; // Enable manual step
            autoRunBtn.textContent = 'Auto-Run Demo';
        }


        // --- Event Listeners ---
        setBtn.addEventListener('click', handleGetSet);
        appendBtn.addEventListener('click', handleAppend);
        insertBtn.addEventListener('click', handleInsert);
        removeBtn.addEventListener('click', handleRemoveValue);
        popBtn.addEventListener('click', handlePop);

        resetBtn.addEventListener('click', () => resetApp([10, 20, 30])); // Default list on reset
        randomizeBtn.addEventListener('click', handleRandomize);
        autoRunBtn.addEventListener('click', () => {
            if (autoRunInterval) {
                stopAutoRun();
            } else {
                startAutoRun();
            }
        });
        nextStepBtn.addEventListener('click', nextStep);


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            resetApp([10, 20, [30, 40], "hello"]); // Initial state
        });

    </script>

</body>
</html>
