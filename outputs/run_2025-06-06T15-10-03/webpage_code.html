```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Conditionals Explorer</title>
    <style>
        /* GeeksforGeeks Theme */
        :root {
            --gfg-green: #2f8d46;
            --gfg-dark: #222222;
            --gfg-white: #ffffff;
            --gfg-light-grey: #f0f0f0;
            --condition-true: #3cb371; /* MediumSeaGreen */
            --condition-false: #e9967a; /* DarkSalmon */
            --executing-path: #ffd700; /* Gold */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
            margin: 0;
            padding: 0;
            background-color: var(--gfg-white);
            color: var(--gfg-dark);
            overflow: hidden; /* Fixed viewport */
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: var(--gfg-green);
            color: var(--gfg-white);
            padding: 10px 20px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            flex-shrink: 0; /* Prevent shrinking */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 1.2em;
        }

        .main-container {
            flex-grow: 1; /* Take remaining space */
            display: flex;
            overflow: hidden; /* Contain children */
        }

        .controls-panel, .simulation-area {
            padding: 20px;
            overflow-y: auto; /* Allow scrolling if content exceeds height */
            box-sizing: border-box; /* Include padding in width */
        }

        .controls-panel {
            width: 30%;
            min-width: 280px; /* Ensure minimum size */
            border-right: 1px solid var(--gfg-light-grey);
            background-color: var(--gfg-light-grey);
            flex-shrink: 0; /* Prevent shrinking */
        }

        .simulation-area {
            width: 70%;
            flex-grow: 1; /* Take available space */
            display: flex;
            flex-direction: column;
        }

        .concept-selector h3, .variable-inputs h3, .condition-visualizer h3, .code-flow-visualizer h3, .simulated-output h3 {
            color: var(--gfg-green);
            border-bottom: 2px solid var(--gfg-green);
            padding-bottom: 5px;
            margin-top: 20px;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        .concept-selector h3:first-child, .variable-inputs h3:first-child { margin-top: 0; }


        .concept-selector button {
            background-color: var(--gfg-white);
            border: 1px solid var(--gfg-green);
            color: var(--gfg-green);
            padding: 8px 15px;
            margin: 0 5px 5px 0;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
            font-size: 0.9em;
        }

        .concept-selector button:hover {
            background-color: var(--gfg-green);
            color: var(--gfg-white);
        }

        .concept-selector button.active {
            background-color: var(--gfg-green);
            color: var(--gfg-white);
            font-weight: bold;
        }

        .variable-input-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on smaller widths */
        }

        .variable-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            width: 100%; /* Label takes full width */
        }

        .variable-input-group .input-container {
            display: flex;
            align-items: center;
            width: 100%; /* Container takes full width */
        }


        .variable-input-group input[type="range"] {
            flex-grow: 1; /* Slider takes most space */
            margin-right: 10px; /* Space between slider and number input */
        }

        .variable-input-group input[type="number"] {
             width: 60px; /* Fixed width for number input */
             padding: 5px;
             border: 1px solid var(--gfg-light-grey);
             border-radius: 4px;
             text-align: center;
         }

         .variable-input-group label span {
             font-weight: normal; /* Don't bold the value */
         }


        .simulation-area > div {
             margin-bottom: 20px; /* Space between simulation components */
             flex-shrink: 0; /* Prevent shrinking by default */
        }

        .condition-visualizer {
            background-color: #e8f5e9; /* Very light green */
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #c8e6c9; /* Light green border */
        }

        .condition-item {
            margin-bottom: 8px;
            padding: 5px;
            background-color: var(--gfg-white);
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .condition-item strong {
            color: var(--gfg-green);
            word-break: break-word; /* Allow condition text to wrap */
             flex-grow: 1;
             margin-right: 10px; /* Space before result */
        }

        .condition-result {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 3px;
            white-space: nowrap; /* Prevent wrapping */
             flex-shrink: 0; /* Prevent shrinking */
        }

        .condition-result.true {
            background-color: var(--condition-true);
            color: var(--gfg-white);
        }

        .condition-result.false {
            background-color: var(--condition-false);
            color: var(--gfg-white);
        }

        .code-flow-visualizer {
            flex-grow: 1; /* Take remaining height in simulation area */
             background-color: #fff; /* White background */
             padding: 15px;
             border-radius: 5px;
             border: 1px solid #ddd;
             font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
             font-size: 0.9em;
             position: relative; /* Needed for absolute positioning of highlighters if used */
             overflow-y: auto; /* Allow scrolling if code block is large */
             display: flex; /* Use flex for internal structure */
             flex-direction: column;
        }
         .code-flow-visualizer h3 { /* Keep header fixed */
            flex-shrink: 0;
            margin-top: 0;
         }
         .code-flow-container { /* Scrollable container for code blocks */
             flex-grow: 1;
             overflow-y: auto;
         }


        .code-block {
            margin: 5px 0;
            padding: 8px;
            border-left: 3px solid transparent; /* Default border */
            transition: background-color 0.3s ease; /* Smooth transition */
             position: relative; /* Needed for potential absolute position highlights */
        }

         .code-block.if-block { border-left-color: #007bff; /* Blue */ }
         .code-block.elif-block { border-left-color: #ffc107; /* Yellow */ }
         .code-block.else-block { border-left-color: #dc3545; /* Red */ }
         .code-block.nested-block { border-left-color: #6610f2; /* Indigo */ }


        .code-block .condition-text {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0056b3; /* Darker blue for condition */
        }

        .code-block .block-body {
            margin-left: 20px; /* Indentation for block content */
            border-left: 1px dashed #ccc; /* Visual guide for indentation */
            padding-left: 10px;
        }

        .code-block .print-statement {
            color: #28a745; /* Green for print */
            margin-bottom: 5px;
        }

         .code-block.executing {
             background-color: var(--executing-path); /* Highlight background */
             color: var(--gfg-dark); /* Ensure text readable on highlight */
             box-shadow: 0 0 5px rgba(0,0,0,0.2);
         }

         .code-block.executing .condition-text {
             color: #004085; /* Darker blue on highlight */
         }
         .code-block.executing .print-statement {
             color: #1e7e34; /* Darker green for print on highlight */
         }


        .simulated-output {
            background-color: #f1f8e9; /* Very light green */
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dcedc8; /* Light green border */
            margin-top: auto; /* Push to the bottom */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .simulated-output h3 {
             margin-top: 0;
        }

        .simulated-output pre {
            margin: 0;
            padding: 0;
            white-space: pre-wrap; /* Wrap long output */
            word-break: break-word;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            color: #004d40; /* Dark Cyan for output */
        }


        .footer {
            background-color: var(--gfg-dark);
            color: var(--gfg-white);
            padding: 10px 20px;
            text-align: center;
            font-size: 0.9em;
            flex-shrink: 0; /* Prevent shrinking */
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
        }

        .footer a {
            color: var(--gfg-green);
            text-decoration: none;
            margin: 0 10px;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Simple Tooltip (using title attribute - no extra JS) */
         [title]:hover {
             cursor: help; /* Indicate hover info */
         }

    </style>
</head>
<body>
    <header class="header">
        <h1>Python Conditionals Explorer</h1>
    </header>

    <div class="main-container">
        <div class="controls-panel">
            <div class="concept-selector">
                <h3>Select Concept</h3>
                <button data-concept="if" class="active">if</button>
                <button data-concept="if-else">if...else</button>
                 <button data-concept="if-else-logical">if...else (Logical)</button>
                <button data-concept="elif">if...elif...else</button>
                <button data-concept="nested">Nested if...else</button>
            </div>

            <div class="variable-inputs">
                <h3>Variables</h3>
                <!-- Variable inputs will be dynamically inserted here -->
            </div>
        </div>

        <div class="simulation-area">
            <div class="condition-visualizer">
                <h3>Condition Evaluation</h3>
                <!-- Condition results will be dynamically inserted here -->
            </div>

            <div class="code-flow-visualizer">
                <h3>Code Flow</h3>
                <div class="code-flow-container">
                 <!-- Code blocks will be dynamically inserted here -->
                </div>
            </div>

            <div class="simulated-output">
                <h3>Simulated Output</h3>
                <pre id="output-content"></pre>
            </div>
        </div>
    </div>

    <footer class="footer">
        <span>&copy; 2023 Explorer</span>
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        const conceptSelector = document.querySelector('.concept-selector');
        const variableInputsDiv = document.querySelector('.variable-inputs');
        const conditionVisualizerDiv = document.querySelector('.condition-visualizer');
        const codeFlowContainer = document.querySelector('.code-flow-container'); // Container for scrollable code blocks
        const outputContentPre = document.getElementById('output-content');

        // --- Data Structure for Concepts ---
        const concepts = {
            'if': {
                variables: [{ name: 'i', type: 'range', min: -20, max: 20, step: 1, initial: 5 }],
                code: [
                    { type: 'if', condition: 'i > 0', conditionText: 'if i > 0:', block: [{ type: 'print', text: 'i is positive' }] },
                    { type: 'print', text: 'Code after if block' } // Code that executes regardless
                ],
                conditions: ['i > 0'], // List of conditions to evaluate in visualizer
                getOutput: (vars, path) => {
                    let output = '';
                    if (path.includes('if0-print0')) output += 'i is positive\n';
                     if (path.includes('print1')) output += 'Code after if block\n';
                    return output.trim();
                }
            },
            'if-else': {
                variables: [{ name: 'i', type: 'range', min: -20, max: 20, step: 1, initial: 5 }],
                code: [
                    { type: 'if', condition: 'i > 10', conditionText: 'if i > 10:', block: [{ type: 'print', text: 'i is greater than 10' }] },
                    { type: 'else', conditionText: 'else:', block: [{ type: 'print', text: 'i is not greater than 10' }] },
                     { type: 'print', text: 'Code after if-else block' }
                ],
                 conditions: ['i > 10'],
                getOutput: (vars, path) => {
                    let output = '';
                    if (path.includes('if0-print0')) output += 'i is greater than 10\n';
                    else if (path.includes('else1-print0')) output += 'i is not greater than 10\n';
                     if (path.includes('print2')) output += 'Code after if-else block\n';
                    return output.trim();
                }
            },
             'if-else-logical': {
                 variables: [
                     { name: 'age', type: 'range', min: 0, max: 100, step: 1, initial: 25 },
                     { name: 'exp', type: 'range', min: 0, max: 20, step: 1, initial: 3 }
                 ],
                 code: [
                     { type: 'if', condition: 'age >= 18 && exp >= 5', conditionText: 'if age >= 18 and exp >= 5:', block: [{ type: 'print', text: 'Qualified for senior role' }] },
                     { type: 'else', conditionText: 'else:', block: [{ type: 'print', text: 'Not qualified for senior role' }] },
                      { type: 'print', text: 'Application reviewed' }
                 ],
                 conditions: ['age >= 18', 'exp >= 5', 'age >= 18 && exp >= 5'], // Evaluate sub-conditions and final
                 getOutput: (vars, path) => {
                     let output = '';
                     if (path.includes('if0-print0')) output += 'Qualified for senior role\n';
                     else if (path.includes('else1-print0')) output += 'Not qualified for senior role\n';
                      if (path.includes('print2')) output += 'Application reviewed\n';
                     return output.trim();
                 }
             },
            'elif': {
                variables: [{ name: 'i', type: 'range', min: 0, max: 20, step: 1, initial: 12 }],
                code: [
                    { type: 'if', condition: 'i < 5', conditionText: 'if i < 5:', block: [{ type: 'print', text: 'i is small' }] },
                    { type: 'elif', condition: 'i < 15', conditionText: 'elif i < 15:', block: [{ type: 'print', text: 'i is medium' }] },
                    { type: 'else', conditionText: 'else:', block: [{ type: 'print', text: 'i is large' }] },
                     { type: 'print', text: 'Execution complete' }
                ],
                conditions: ['i < 5', 'i < 15'], // Conditions to evaluate
                getOutput: (vars, path) => {
                    let output = '';
                    if (path.includes('if0-print0')) output += 'i is small\n';
                    else if (path.includes('elif1-print0')) output += 'i is medium\n';
                    else if (path.includes('else2-print0')) output += 'i is large\n';
                     if (path.includes('print3')) output += 'Execution complete\n';
                    return output.trim();
                }
            },
            'nested': {
                variables: [{ name: 'i', type: 'range', min: -10, max: 10, step: 1, initial: 3 }],
                code: [
                    {
                        type: 'if', condition: 'i > 0', conditionText: 'if i > 0:', block: [
                            { type: 'print', text: 'i is positive' },
                            { type: 'if', condition: 'i % 2 == 0', conditionText: 'if i % 2 == 0:', block: [{ type: 'print', text: 'i is even' }] },
                            { type: 'else', conditionText: 'else:', block: [{ type: 'print', text: 'i is odd' }] }
                        ]
                    },
                    { type: 'else', conditionText: 'else:', block: [{ type: 'print', text: 'i is not positive' }] },
                     { type: 'print', text: 'End of program' }
                ],
                 conditions: ['i > 0', 'i % 2 == 0'],
                getOutput: (vars, path) => {
                    let output = '';
                    if (path.includes('if0-print0')) output += 'i is positive\n';
                    if (path.includes('if0-if0-print0')) output += 'i is even\n';
                    if (path.includes('if0-else1-print0')) output += 'i is odd\n';
                    if (path.includes('else1-print0')) output += 'i is not positive\n'; // This path segment is slightly confusing due to flattened structure, fix path in determinePath
                    if (path.includes('else1-block0-print0')) output += 'i is not positive\n'; // Corrected path segment check
                    if (path.includes('print2')) output += 'End of program\n';
                    return output.trim();
                }
            }
        };

        let currentConcept = 'if'; // Default concept
        let variableValues = {};

        // --- UI Rendering Functions ---

        function renderVariableInputs(conceptKey) {
            const concept = concepts[conceptKey];
            variableInputsDiv.innerHTML = '<h3>Variables</h3>'; // Clear previous inputs

            concept.variables.forEach(variable => {
                const div = document.createElement('div');
                div.classList.add('variable-input-group');

                const label = document.createElement('label');
                label.setAttribute('for', `input-${variable.name}`);
                label.innerHTML = `${variable.name}: <span id="value-${variable.name}">${variable.initial}</span>`;
                div.appendChild(label);

                const inputContainer = document.createElement('div');
                inputContainer.classList.add('input-container');

                const rangeInput = document.createElement('input');
                rangeInput.setAttribute('type', 'range');
                rangeInput.setAttribute('id', `input-${variable.name}`);
                rangeInput.setAttribute('name', variable.name);
                rangeInput.setAttribute('min', variable.min);
                rangeInput.setAttribute('max', variable.max);
                rangeInput.setAttribute('step', variable.step);
                rangeInput.setAttribute('value', variable.initial);
                inputContainer.appendChild(rangeInput);

                const numberInput = document.createElement('input');
                numberInput.setAttribute('type', 'number');
                numberInput.setAttribute('value', variable.initial);
                numberInput.setAttribute('data-sync', variable.name);
                numberInput.setAttribute('min', variable.min);
                numberInput.setAttribute('max', variable.max);
                numberInput.setAttribute('step', variable.step);
                inputContainer.appendChild(numberInput);


                div.appendChild(inputContainer);
                variableInputsDiv.appendChild(div);

                variableValues[variable.name] = variable.initial; // Store initial value

                 const valueSpan = div.querySelector(`#value-${variable.name}`);


                // Sync range to number and label value
                rangeInput.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    numberInput.value = val;
                    valueSpan.textContent = val;
                    handleVariableChange(variable.name, val);
                });

                // Sync number to range and label value
                numberInput.addEventListener('input', (e) => {
                     let val = parseFloat(e.target.value);
                     // Clamp value within range
                     if (isNaN(val)) val = variable.initial; // Fallback if input is cleared
                     val = Math.max(variable.min, Math.min(variable.max, val));
                     e.target.value = val; // Update number input to clamped value if needed

                     rangeInput.value = val;
                     valueSpan.textContent = val;
                     handleVariableChange(variable.name, val);
                 });

                 // Handle number input blur to clamp final value
                 numberInput.addEventListener('blur', (e) => {
                     let val = parseFloat(e.target.value);
                     if (isNaN(val) || val < variable.min || val > variable.max) {
                         val = variable.initial; // Reset to initial or last valid? Initial is safer.
                         e.target.value = val;
                         rangeInput.value = val;
                         valueSpan.textContent = val;
                         handleVariableChange(variable.name, val); // Ensure state is synced
                     }
                 });
            });
        }

        function renderCodeFlow(codeStructure) {
            codeFlowContainer.innerHTML = ''; // Clear previous flow

             function buildBlockHtml(blocks, currentPathPrefix = '') {
                 let blockHtml = '';
                 blocks.forEach((block, index) => {
                     // Create a unique path segment for this block
                     // Use type and index, handle nested naming slightly differently
                     const blockPathSegment = `${block.type}${index}`;
                     const fullPath = currentPathPrefix ? `${currentPathPrefix}-${blockPathSegment}` : blockPathSegment;


                     let titleText = '';
                     if (block.conditionText) {
                          titleText = block.conditionText;
                     } else if (block.type === 'print') {
                         titleText = `print('${block.text}')`;
                     }


                     blockHtml += `
                         <div class="code-block ${block.type}-block" data-path="${fullPath}" title="${titleText}">
                             ${block.conditionText ? `<div class="condition-text">${block.conditionText}</div>` : ''}
                             <div class="block-body">
                                 ${block.block ? buildBlockHtml(block.block, fullPath) : ''} <!-- Pass fullPath for nested -->
                                 ${block.type === 'print' ? `<div class="print-statement">print('${block.text}')</div>` : ''}
                             </div>
                         </div>
                     `;
                 });
                 return blockHtml;
             }

             const html = buildBlockHtml(codeStructure);
            codeFlowContainer.innerHTML = html;
        }

        function renderConditionVisualizer(conceptKey, variables) {
            const concept = concepts[conceptKey];
            const conditionsToDisplay = concept.conditions || [];
            let html = '<h3>Condition Evaluation</h3>';

            if (conditionsToDisplay.length === 0) {
                html += '<p>No conditions to evaluate for this concept.</p>';
            } else {
                conditionsToDisplay.forEach(conditionStr => {
                    let result = evaluateCondition(conditionStr, variables);
                    const resultClass = result ? 'true' : 'false';
                     // Replace JS operators back to Python for display
                     let displayCondition = conditionStr.replace(/&&/g, ' and ').replace(/\|\|/g, ' or ').replace(/!/g, 'not ');
                     // Basic formatting for display
                     displayCondition = displayCondition.replace(/>=/g, ' >= ').replace(/<=/g, ' <= ').replace(/==/g, ' == ').replace(/>/g, ' > ').replace(/</g, ' < ').replace(/%/g, ' % ');
                     // Add variable values to the display condition for clarity
                      Object.keys(variables).forEach(varName => {
                          const regex = new RegExp(`\\b${varName}\\b`, 'g'); // Word boundary
                           displayCondition = displayCondition.replace(regex, `${varName}=${variables[varName]}`);
                      });


                    html += `
                        <div class="condition-item">
                            <strong>${displayCondition}</strong>
                            <span class="condition-result ${resultClass}">${result}</span>
                        </div>
                    `;
                });
            }


            conditionVisualizerDiv.innerHTML = html;
        }

        // --- Logic Functions ---

        function evaluateCondition(conditionStr, variables) {
             // UNSAFE in general, but acceptable for a fixed, local, educational demo with trusted input strings.
            try {
                 // Create a function dynamically where variable names are arguments
                const varNames = Object.keys(variables);
                const varValues = Object.values(variables);
                const evalFunction = new Function(...varNames, `return ${conditionStr};`);
                return evalFunction(...varValues);
            } catch (e) {
                console.error("Error evaluating condition:", conditionStr, e);
                return false; // Assume false on error
            }
        }


        function determineExecutionPath(conceptKey, variables) {
            const concept = concepts[conceptKey];
            const path = []; // Array of data-path strings for executing blocks

            function tracePath(blocks, currentPathPrefix = '') {
                 let executionInSequence = false; // Track if we are inside an executing if/elif/else sequence at this level

                 for (let i = 0; i < blocks.length; i++) {
                    const block = blocks[i];
                    const blockPathSegment = `${block.type}${i}`;
                    const fullPath = currentPathPrefix ? `${currentPathPrefix}-${blockPathSegment}` : blockPathSegment;

                    if (block.condition) {
                        // This block has a condition (if or elif)
                         if (executionInSequence) {
                             // If we are already in an executing sequence (previous if/elif was true), skip this condition check
                             continue;
                         }

                        const conditionResult = evaluateCondition(block.condition, variables);

                        if (conditionResult) {
                            path.push(fullPath); // Add the conditional block header
                            if (block.block) {
                                tracePath(block.block, fullPath); // Trace into the block body
                            }
                            // If If or Elif is true, the sequence is done at this level.
                            if (block.type === 'if' || block.type === 'elif') {
                                executionInSequence = true; // Mark sequence as finished execution path
                            }
                             // Note: An 'if' block *not* followed by elif/else will not set executionInSequence to true, allowing subsequent blocks to be checked.
                             // An 'if' block *followed* by elif/else will set it true if its condition is met.
                        } else {
                            // Condition is false, executionInSequence remains false (or was already false). Continue to next block.
                        }

                    } else if (block.type === 'else') {
                         // An 'else' block is executed only if the preceding if/elif sequence did *not* execute any branch.
                         // We need to look back to see if the last processed block was part of a sequence that didn't execute.
                         // This check is hard just by looking at `executionInSequence`.
                         // A simpler model for this structure is to process if/elif/else sequences together.

                         // Reworking: Process blocks in a loop. If an if/elif is encountered, process the *entire* sequence (if, zero or more elifs, optional else) together.

                         // Let's restart the logic for the main loop to process sequences.
                         return handleSequence(blocks, currentPathPrefix); // Delegate sequence handling
                    } else {
                         // Non-conditional block (like a print statement directly under a body or at the top level)
                         path.push(fullPath);
                         if (block.block) { // If this is a block that *contains* other blocks (e.g., the body of a nested conditional)
                              tracePath(block.block, fullPath);
                         }
                         executionInSequence = false; // Reset sequence state after a non-conditional block
                    }
                 }
            }

            // Function to handle if/elif/else sequences
            function handleSequence(blocks, currentPathPrefix = '') {
                const path = [];
                let sequenceExecuted = false; // Flag if any branch in the current sequence was executed

                for (let i = 0; i < blocks.length; i++) {
                    const block = blocks[i];
                    const blockPathSegment = `${block.type}${i}`;
                    const fullPath = currentPathPrefix ? `${currentPathPrefix}-${blockPathSegment}` : blockPathSegment;

                    if (block.type === 'if') {
                        const conditionResult = evaluateCondition(block.condition, variables);
                        if (conditionResult) {
                            path.push(fullPath); // Add if header
                            if (block.block) {
                                path.push(...traceBody(block.block, fullPath)); // Trace body recursively
                            }
                            sequenceExecuted = true;
                            // Skip remaining elifs and the final else in this sequence
                            let j = i + 1;
                             while(j < blocks.length && (blocks[j].type === 'elif' || blocks[j].type === 'else')) {
                                 j++;
                             }
                             i = j - 1; // Set outer loop index to the last block skipped in the sequence
                        } else {
                             // If is false, check for elifs and else in this sequence
                             let foundExecutingBranch = false;
                             let j = i + 1;
                             while(j < blocks.length && (blocks[j].type === 'elif' || blocks[j].type === 'else')) {
                                 const currentSeqBlock = blocks[j];
                                 const currentSeqPathSegment = `${currentSeqBlock.type}${j}`;
                                  const currentSeqFullPath = currentPathPrefix ? `${currentPathPrefix}-${currentSeqPathSegment}` : currentSeqPathSegment;


                                 if (currentSeqBlock.type === 'elif') {
                                     const elifConditionResult = evaluateCondition(currentSeqBlock.condition, variables);
                                     if (elifConditionResult) {
                                         path.push(currentSeqFullPath); // Add elif header
                                         if (currentSeqBlock.block) {
                                             path.push(...traceBody(currentSeqBlock.block, currentSeqFullPath)); // Trace body
                                         }
                                         foundExecutingBranch = true;
                                         sequenceExecuted = true;
                                         // Skip remaining elifs and the final else
                                          let k = j + 1;
                                          while(k < blocks.length && (blocks[k].type === 'elif' || blocks[k].type === 'else')) {
                                             k++;
                                          }
                                          i = k - 1; // Set outer loop index past the sequence
                                         break; // Exit while loop
                                     }
                                 } else if (currentSeqBlock.type === 'else') {
                                      // This else belongs to the sequence if no preceding if/elifs were true
                                      if (!foundExecutingBranch) {
                                          path.push(currentSeqFullPath); // Add else header
                                          if (currentSeqBlock.block) {
                                               path.push(...traceBody(currentSeqBlock.block, currentSeqFullPath)); // Trace body
                                          }
                                          foundExecutingBranch = true; // The else branch executed
                                          sequenceExecuted = true;
                                          i = j; // Set outer loop index past the else
                                          break; // Exit while loop
                                      }
                                 }
                                 j++;
                             }
                             // If no branch in the sequence executed, sequenceExecuted remains false.
                             // Outer loop continues from where the while loop stopped (or right after the initial if if while loop didn't run).

                        }
                    } else if (block.type === 'elif' || block.type === 'else') {
                         // These should have been handled as part of an 'if' sequence above.
                         // If we reach one here, it's a structural issue or a standalone else/elif which isn't valid syntax.
                         // We'll ignore them if they are not part of the sequence processing started by an 'if'.
                         continue; // Skip standalone elif/else
                    }
                    else {
                        // Non-conditional block outside of a sequence
                         if (!sequenceExecuted) { // Only process if the previous sequence (if any) wasn't executed OR this is the first block
                             path.push(fullPath);
                             if (block.block) {
                                 path.push(...traceBody(block.block, fullPath));
                             }
                         }
                         sequenceExecuted = false; // Reset sequence state after a non-conditional block
                    }
                 }
                return path; // Return the paths found in this sequence/block processing
            }

             // Function to trace paths within a block body
             function traceBody(blocks, currentPathPrefix) {
                 const bodyPath = [];
                 blocks.forEach((block, index) => {
                     const blockPathSegment = `${block.type}${index}`;
                     const fullPath = `${currentPathPrefix}-${blockPathSegment}`; // Path includes parent

                     if (block.condition) {
                          // Nested conditional sequence
                          // Delegate to handleSequence, but append result to bodyPath
                          bodyPath.push(...handleSequence([block, ...blocks.slice(index + 1).filter(b => b.type === 'elif' || b.type === 'else')], currentPathPrefix));
                          // Need to advance the outer loop index if we handled a sequence
                           let j = index + 1;
                           while(j < blocks.length && (blocks[j].type === 'elif' || blocks[j].type === 'else')) {
                               j++;
                           }
                           index = j - 1; // Set inner loop index past the sequence
                     } else if (block.type === 'else') {
                          // This else should be handled by the handleSequence call triggered by the preceding if/elif
                          // If we reach a standalone else in a body, it's an error, ignore.
                          return; // Skip standalone else
                     }
                     else {
                          // Non-conditional block inside a body (like print)
                         bodyPath.push(fullPath);
                          if (block.block) { // Should not happen for print, but for general blocks
                             bodyPath.push(...traceBody(block.block, fullPath));
                          }
                     }
                 });
                 return bodyPath;
             }


             // Start tracing from the top-level blocks
            // Need to distinguish between a sequence that executes *none* of its branches and subsequent non-conditional blocks
            // The logic for sequences and non-conditional blocks needs careful interworking at the top level.

             // Let's rebuild the top-level logic
             const topLevelBlocks = concepts[conceptKey].code;
             let finalPath = [];
             let consumedBySequence = false; // Flag if the current block was part of a sequence already processed

             for (let i = 0; i < topLevelBlocks.length; i++) {
                 const block = topLevelBlocks[i];
                 const blockPathSegment = `${block.type}${i}`;
                 const fullPath = blockPathSegment; // Top-level path

                 if (consumedBySequence) {
                     consumedBySequence = false; // Reset flag for the next block
                     continue; // This block was part of the previous sequence
                 }


                 if (block.type === 'if') {
                      // Found the start of a potential sequence
                      const sequenceBlocks = [block];
                      let j = i + 1;
                       while(j < topLevelBlocks.length && (topLevelBlocks[j].type === 'elif' || topLevelBlocks[j].type === 'else')) {
                          sequenceBlocks.push(topLevelBlocks[j]);
                          j++;
                       }
                      // Process the sequence
                      const sequencePath = [];
                      let sequenceBranchExecuted = false;

                      for(let k = 0; k < sequenceBlocks.length; k++) {
                           const currentSeqBlock = sequenceBlocks[k];
                           const currentSeqBlockPathSegment = `${currentSeqBlock.type}${i+k}`; // Correct index based on original topLevelBlocks
                           const currentSeqFullPath = currentSeqBlockPathSegment;

                           if (currentSeqBlock.condition) { // if or elif
                                if (!sequenceBranchExecuted) { // Only check condition if no branch in THIS sequence has executed yet
                                    const conditionResult = evaluateCondition(currentSeqBlock.condition, variables);
                                    if (conditionResult) {
                                        sequencePath.push(currentSeqFullPath);
                                        if (currentSeqBlock.block) {
                                             sequencePath.push(...traceBody(currentSeqBlock.block, currentSeqFullPath));
                                        }
                                        sequenceBranchExecuted = true; // Found the executing branch
                                    }
                                }
                           } else if (currentSeqBlock.type === 'else') {
                                // else block
                                if (!sequenceBranchExecuted) { // Only execute else if no preceding if/elif was true
                                    sequencePath.push(currentSeqFullPath);
                                     if (currentSeqBlock.block) {
                                         sequencePath.push(...traceBody(currentSeqBlock.block, currentSeqFullPath));
                                    }
                                    sequenceBranchExecuted = true; // Else branch executed
                                }
                           }
                      }
                      finalPath.push(...sequencePath); // Add the path from the executed sequence branch
                      // Advance the main loop index past the sequence blocks
                      i += sequenceBlocks.length - 1;
                      consumedBySequence = true; // Mark that we handled a sequence
                 } else {
                      // Non-conditional block at the top level
                      finalPath.push(fullPath);
                       if (block.block) { // If this is a block body wrapper
                          finalPath.push(...traceBody(block.block, fullPath));
                       }
                       consumedBySequence = false; // This block wasn't part of a sequence
                 }
             }

             // Fix nested path names in nested example output mapping
             if (conceptKey === 'nested') {
                 // The path segments are correct ('if0-print0', 'if0-if0-print0', etc.)
                 // The getOutput function just needs to use these segments. The current getOutput is okay.
                 // The 'else1-print0' path in the output check was wrong, it should be 'else1-block0-print0' or similar depending on generated path.
                 // Let's adjust the getOutput check based on the generated paths.
                 // Need to ensure traceBody creates paths like parentPath-childTypeIndex
             }

             console.log("Execution Path:", finalPath); // Debugging
             return finalPath;
        }


        function updateSimulation() {
            const concept = concepts[currentConcept];

            // 1. Evaluate Conditions & Update Visualizer
            renderConditionVisualizer(currentConcept, variableValues);

            // 2. Determine Execution Path & Update Code Flow Highlighter
            const executionPath = determineExecutionPath(currentConcept, variableValues);

            // Remove existing highlights
            codeFlowContainer.querySelectorAll('.code-block').forEach(block => {
                block.classList.remove('executing');
            });

            // Apply new highlights with a slight delay/transition if needed (CSS handles transition)
            executionPath.forEach(pathSegment => {
                 // Find block using data-path
                const blockElement = codeFlowContainer.querySelector(`[data-path="${pathSegment}"]`);
                if (blockElement) {
                    blockElement.classList.add('executing');
                } else {
                    console.warn("Could not find block element for path segment:", pathSegment); // Debugging
                }
            });

            // 3. Update Simulated Output
            const output = concept.getOutput(variableValues, executionPath);
            outputContentPre.textContent = output;
        }

        function handleVariableChange(name, value) {
            variableValues[name] = value;
            updateSimulation(); // Re-run simulation logic
        }

        function switchConcept(conceptKey) {
            currentConcept = conceptKey;

            // Update button active states
            conceptSelector.querySelectorAll('button').forEach(btn => {
                if (btn.dataset.concept === conceptKey) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Render new UI elements
            renderVariableInputs(conceptKey);
            renderCodeFlow(concepts[conceptKey].code);

            // Initialize variables for the new concept and update simulation
             // Initial values are set in renderVariableInputs, but ensure variableValues reflects the *current* state of the inputs after rendering
             concepts[conceptKey].variables.forEach(v => {
                 const inputElement = variableInputsDiv.querySelector(`#input-${v.name}`);
                 if (inputElement) {
                      variableValues[v.name] = parseFloat(inputElement.value);
                 }
             });
            updateSimulation();
        }

        // --- Event Listeners ---

        conceptSelector.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const conceptKey = event.target.dataset.concept;
                if (conceptKey && conceptKey !== currentConcept) {
                    switchConcept(conceptKey);
                }
            }
        });


        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            switchConcept(currentConcept); // Render the default concept
        });

    </script>
</body>
</html>
```