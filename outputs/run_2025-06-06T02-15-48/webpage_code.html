```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosine Similarity Explorer</title>
    <style>
        :root {
            --gfg-green: #2f8d46;
            --gfg-dark: #222222;
            --gfg-white: #ffffff;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--gfg-white);
            color: var(--gfg-dark);
            display: grid;
            grid-template-rows: auto 1fr auto; /* Header, Main content, Footer */
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }

        header {
            background-color: var(--gfg-green);
            color: var(--gfg-white);
            padding: 10px 20px;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        header p {
            margin: 5px 0 0;
            font-size: 0.9em;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        main {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr; /* Left, Center, Right */
            grid-template-rows: 1fr auto; /* Top row (panels+plot), Bottom row (interpretation+considerations) */
            gap: 15px;
            padding: 15px;
            overflow: hidden; /* Prevent main scroll */
        }

        .panel {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto; /* Allow internal panel scroll if needed */
            display: flex;
            flex-direction: column;
        }

        .left-panel {
            grid-column: 1;
            grid-row: 1;
        }

        .center-plot {
            grid-column: 2;
            grid-row: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--gfg-white);
            border: 1px solid #ddd;
            border-radius: 8px;
            position: relative; /* Needed for canvas absolute positioning if used, though canvas itself is flexible */
        }

        #vectorCanvas {
            width: 100%;
            height: 100%;
            display: block; /* Remove extra space below canvas */
        }

        .right-panel {
            grid-column: 3;
            grid-row: 1;
        }

        .bottom-section {
            grid-column: 1 / span 3; /* Span across all three columns */
            grid-row: 2;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto; /* Allow internal scroll */
        }

        .panel h2, .bottom-section h2 {
            color: var(--gfg-green);
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            font-size: 1.3em;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input[type="number"] {
            width: calc(50% - 10px); /* Two inputs per line */
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }

         .input-group input[type="number"]:last-child {
             margin-right: 0;
         }

        .calculation-step {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #eee;
            border-radius: 4px;
            word-break: break-word; /* Prevent long equations from overflowing */
            white-space: pre-wrap; /* Preserve line breaks in calculated output */
        }

        .calculation-step strong {
            color: var(--gfg-dark);
        }

        #angleInterpretation {
            margin-bottom: 15px;
        }

        #angleInterpretation p {
            margin-bottom: 5px;
            font-weight: bold;
        }

        #similarityVisualizer {
            height: 20px;
            background-color: #ccc;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #similarityBar {
            height: 100%;
            width: 0%; /* Will be updated by JS */
            background: linear-gradient(to right, red, yellow, var(--gfg-green)); /* -1 to 1 mapping */
            transition: width 0.5s ease-in-out;
        }

        #similarityValue {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            text-align: center;
            line-height: 20px; /* Center text vertically */
            color: var(--gfg-dark);
            font-size: 0.9em;
            font-weight: bold;
        }

        #toggleConsiderations {
            display: block;
            width: auto;
            padding: 10px 15px;
            margin-top: 10px;
            background-color: var(--gfg-green);
            color: var(--gfg-white);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }

        #toggleConsiderations:hover {
            background-color: #256e37; /* Darker green */
        }

        #keyConsiderationsContent {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            display: none; /* Hidden by default */
        }

        #keyConsiderationsContent p {
            margin-bottom: 10px;
        }

        footer {
            background-color: var(--gfg-green);
            color: var(--gfg-white);
            text-align: center;
            padding: 10px;
            font-size: 0.9em;
        }

        footer a {
            color: var(--gfg-white);
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

         /* Responsive adjustments if needed, though goal is static */
        @media (max-width: 900px) {
            main {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto; /* Stack all sections */
                overflow-y: auto; /* Allow body scroll on smaller screens */
            }
            .left-panel, .center-plot, .right-panel, .bottom-section {
                grid-column: 1 / span 1;
                grid-row: unset !important; /* Reset row */
            }
            .left-panel { order: 1; }
            .center-plot { order: 2; height: 300px; } /* Give plot a height */
            .right-panel { order: 3; }
            .bottom-section { order: 4; }
             body { overflow-y: auto; } /* Allow scroll on mobile */
        }
    </style>
</head>
<body>
    <header>
        <h1>Cosine Similarity Explorer</h1>
        <p>Visualize and understand how cosine similarity measures the angle between two vectors.</p>
    </header>

    <main>
        <div class="panel left-panel">
            <h2>Vector Input</h2>
            <div class="input-group">
                <label for="vectorAx">Vector A:</label>
                <input type="number" id="vectorAx" value="1">
                <input type="number" id="vectorAy" value="0">
                (x, y)
            </div>
            <div class="input-group">
                <label for="vectorBx">Vector B:</label>
                <input type="number" id="vectorBx" value="1">
                <input type="number" id="vectorBy" value="1">
                (x, y)
            </div>
        </div>

        <div class="center-plot">
            <canvas id="vectorCanvas"></canvas>
        </div>

        <div class="panel right-panel">
            <h2>Calculation Breakdown</h2>
            <div id="calculationDotProduct" class="calculation-step"><strong>Dot Product (A · B):</strong> Calculating...</div>
            <div id="calculationMagnitudeA" class="calculation-step"><strong>Magnitude |A|:</strong> Calculating...</div>
            <div id="calculationMagnitudeB" class="calculation-step"><strong>Magnitude |B|:</strong> Calculating...</div>
            <div id="calculationCosineSimilarity" class="calculation-step"><strong>Cosine Similarity:</strong> Calculating...</div>
        </div>

        <div class="bottom-section">
            <div id="angleInterpretation">
                <h2>Angle Interpretation</h2>
                <p>Similarity ranges from 1 (same direction) to -1 (opposite direction), with 0 being orthogonal.</p>
                <div id="similarityVisualizer">
                    <div id="similarityBar"></div>
                    <div id="similarityValue">-</div>
                </div>
                <p id="calculatedAngle">Angle: Calculating...</p>
            </div>

            <button id="toggleConsiderations">Show Key Considerations</button>
            <div id="keyConsiderationsContent">
                <h2>Key Considerations</h2>
                <p><strong>Independence from Magnitude:</strong> Cosine similarity only cares about the angle, not the length of the vectors. Scaling a vector doesn't change the similarity.</p>
                <p><strong>Symmetry:</strong> The similarity between A and B is the same as between B and A (cos(θ) = cos(-θ)).</p>
                <p><strong>Range:</strong> The value is always between -1 and 1 (inclusive).</p>
                 <p><strong>Zero Vectors:</strong> If either vector is the zero vector (0,0), the cosine similarity is undefined because the magnitude is zero, leading to division by zero.</p>
            </div>
        </div>
    </main>

    <footer>
        <p>
            Built with <a href="https://github.com/AshishJangra27/" target="_blank">❤️</a> by Ashish Jangra |
            <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a> |
            <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
        </p>
    </footer>

    <script>
        const vectorAxInput = document.getElementById('vectorAx');
        const vectorAyInput = document.getElementById('vectorAy');
        const vectorBxInput = document.getElementById('vectorBx');
        const vectorByInput = document.getElementById('vectorBy');

        const calculationDotProductDiv = document.getElementById('calculationDotProduct');
        const calculationMagnitudeADiv = document.getElementById('calculationMagnitudeA');
        const calculationMagnitudeBDiv = document.getElementById('calculationMagnitudeB');
        const calculationCosineSimilarityDiv = document.getElementById('calculationCosineSimilarity');

        const similarityBar = document.getElementById('similarityBar');
        const similarityValueSpan = document.getElementById('similarityValue');
        const calculatedAngleP = document.getElementById('calculatedAngle');

        const toggleConsiderationsButton = document.getElementById('toggleConsiderations');
        const keyConsiderationsContentDiv = document.getElementById('keyConsiderationsContent');

        const canvas = document.getElementById('vectorCanvas');
        const ctx = canvas.getContext('2d');

        const PI = Math.PI;

        function updateVisualization() {
            const ax = parseFloat(vectorAxInput.value) || 0;
            const ay = parseFloat(vectorAyInput.value) || 0;
            const bx = parseFloat(vectorBxInput.value) || 0;
            const by = parseFloat(vectorByInput.value) || 0;

            const vecA = { x: ax, y: ay };
            const vecB = { x: bx, y: by };

            // Calculations
            const dotProduct = vecA.x * vecB.x + vecA.y * vecB.y;
            const magnitudeA = Math.sqrt(vecA.x * vecA.x + vecA.y * vecA.y);
            const magnitudeB = Math.sqrt(vecB.x * vecB.x + vecB.y * vecB.y);

            let cosineSimilarity = NaN;
            let angleRad = NaN;
            let angleDeg = NaN;
            let isUndefined = false;

            if (magnitudeA === 0 || magnitudeB === 0) {
                isUndefined = true;
                cosineSimilarity = NaN; // Represent undefined state
                angleRad = NaN;
                angleDeg = NaN;
            } else {
                // Clamp dot product / magnitudes to avoid floating point errors leading to values slightly outside [-1, 1]
                const cosVal = dotProduct / (magnitudeA * magnitudeB);
                cosineSimilarity = Math.max(-1, Math.min(1, cosVal)); // Clamp to [-1, 1]

                angleRad = Math.acos(cosineSimilarity);
                angleDeg = angleRad * (180 / PI);
            }


            // Update Calculation Breakdown
            calculationDotProductDiv.innerHTML = `<strong>Dot Product (A · B):</strong> (${vecA.x} * ${vecB.x}) + (${vecA.y} * ${vecB.y}) = ${dotProduct.toFixed(2)}`;
            calculationMagnitudeADiv.innerHTML = `<strong>Magnitude |A|:</strong> &radic;(${vecA.x}² + ${vecA.y}²) = ${magnitudeA.toFixed(2)}`;
            calculationMagnitudeBDiv.innerHTML = `<strong>Magnitude |B|:</strong> &radic;(${vecBxInput.value}² + ${vecByInput.value}²) = ${magnitudeB.toFixed(2)}`;

            if (isUndefined) {
                 calculationCosineSimilarityDiv.innerHTML = `<strong>Cosine Similarity:</strong> Undefined (Zero vector)`;
                 similarityValueSpan.textContent = 'Undefined';
                 similarityBar.style.width = '0%'; // Or some indicator for undefined
                 calculatedAngleP.textContent = `Angle: Undefined`;
            } else {
                calculationCosineSimilarityDiv.innerHTML = `<strong>Cosine Similarity:</strong> ${dotProduct.toFixed(2)} / (${magnitudeA.toFixed(2)} * ${magnitudeB.toFixed(2)}) = ${cosineSimilarity.toFixed(4)}`;
                similarityValueSpan.textContent = cosineSimilarity.toFixed(4);
                 // Map cosine similarity [-1, 1] to percentage [0, 100] for the bar width
                const barWidth = ((cosineSimilarity + 1) / 2) * 100;
                similarityBar.style.width = `${barWidth}%`;
                calculatedAngleP.textContent = `Angle: ${angleDeg.toFixed(2)}°`;
            }


            // Draw Vectors
            drawVectors(vecA, vecB, angleRad, isUndefined);
        }

        function drawVectors(vecA, vecB, angleRad, isUndefined) {
             // Resize canvas to its display size
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Drawing Setup ---
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxDisplayCoord = Math.max(
                Math.abs(vecA.x), Math.abs(vecA.y),
                Math.abs(vecB.x), Math.abs(vecB.y),
                5 // Ensure a minimum scale even for zero vectors
            );
             // Add some padding so vectors don't touch edges
            const scale = Math.min(centerX, centerY) / (maxDisplayCoord * 1.2); // 1.2 factor for padding

            // Translate origin to center
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(scale, -scale); // Flip Y-axis so +Y is up

            // --- Draw Axes ---
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1 / scale; // Scale line width
            ctx.beginPath();
            ctx.moveTo(-centerX / scale, 0);
            ctx.lineTo(centerX / scale, 0);
            ctx.moveTo(0, -centerY / scale);
            ctx.lineTo(0, centerY / scale);
            ctx.stroke();

            // --- Draw Vectors ---
            ctx.lineWidth = 2 / scale; // Scale line width

            // Draw Vector A
            ctx.strokeStyle = var(--gfg-green);
            drawArrow(ctx, 0, 0, vecA.x, vecA.y, scale);

            // Draw Vector B
            ctx.strokeStyle = var(--gfg-dark);
            drawArrow(ctx, 0, 0, vecB.x, vecB.y, scale);

             // --- Draw Labels ---
            ctx.fillStyle = var(--gfg-green);
            ctx.font = `${14 / scale}px system-ui`;
            ctx.fillText('A', vecA.x + 10/scale, vecA.y - 10/scale); // Offset label slightly

            ctx.fillStyle = var(--gfg-dark);
             ctx.font = `${14 / scale}px system-ui`;
            ctx.fillText('B', vecB.x + 10/scale, vecB.y - 10/scale); // Offset label slightly


            // --- Draw Angle Arc ---
            if (!isUndefined && angleRad !== 0 && angleRad !== PI) {
                 ctx.strokeStyle = '#ff9800'; /* Amber for angle */
                 ctx.lineWidth = 1.5 / scale;
                 const arcRadius = Math.min(50 / scale, Math.min(magnitudeA, magnitudeB) / 2); // Arc radius proportional to vector length, max 50px visual size

                 if (arcRadius > 0) { // Only draw arc if there's space
                     const angleA = Math.atan2(vecA.y, vecA.x);
                     const angleB = Math.atan2(vecB.y, vecB.x);

                     // Determine shortest arc direction
                     let startAngle = angleA;
                     let endAngle = angleB;
                     let counterClockwise = false;

                     if (angleA > angleB) {
                         // If A is greater than B, the angle goes clockwise by default
                         // Check if the counter-clockwise path is shorter
                         if (angleA - angleB > PI) {
                             startAngle = angleA;
                             endAngle = angleB + 2 * PI;
                             counterClockwise = true;
                         } else {
                             startAngle = angleB;
                             endAngle = angleA;
                             counterClockwise = true; // Draw from B to A clockwise visually, which is counter-clockwise in canvas coords if start<end
                              let temp = startAngle;
                             startAngle = endAngle;
                             endAngle = temp;
                             counterClockwise = false; // Drawing from A to B counter-clockwise
                         }
                     } else { // angleA <= angleB
                         // If A is less than or equal to B, the angle goes counter-clockwise by default
                         // Check if the clockwise path is shorter
                         if (angleB - angleA > PI) {
                              startAngle = angleB;
                              endAngle = angleA + 2 * PI;
                              counterClockwise = false; // Go from B to A clockwise (longer way)
                              // Simpler: draw from A to B, and if difference > PI, flip direction
                              startAngle = angleA;
                              endAngle = angleB;
                              counterClockwise = false; // Default path
                              if (endAngle - startAngle > PI) {
                                 counterClockwise = true;
                              }
                         } else {
                              startAngle = angleA;
                              endAngle = angleB;
                              counterClockwise = false;
                         }
                     }

                      // Re-calculate angles to ensure correct arc direction logic
                      // atan2 gives angles in [-PI, PI]
                     let angle_A = Math.atan2(vecA.y, vecA.x);
                     let angle_B = Math.atan2(vecB.y, vecB.x);

                     // Normalize angles to be in [0, 2PI] if needed, or handle the arc logic carefully
                     // Let's simplify: Just draw the arc from A's angle to B's angle
                     // and let canvas handle the wrap-around based on counterClockwise flag.
                     // The angle between vectors is abs(angleA - angleB) or 2PI - abs(angleA - angleB).
                     // atan2 handles the signs correctly for direction.

                     let start = angle_A;
                     let end = angle_B;

                     // Decide direction for shortest arc
                     let diff = end - start;
                     if (diff > PI) {
                         diff -= 2 * PI;
                     } else if (diff < -PI) {
                         diff += 2 * PI;
                     }
                     counterClockwise = diff < 0; // Draw counter-clockwise if B is clockwise from A


                     ctx.beginPath();
                     ctx.arc(0, 0, arcRadius, start, end, counterClockwise);
                     ctx.stroke();

                      // Optional: Draw text label for the angle value near the arc
                      // Requires more complex positioning based on arc start/end and mid-angle
                      // Omitting for simplicity and focus on core functional precision without libraries.
                 }
            }


            ctx.restore(); // Restore original context state
        }

        // Function to draw an arrow line
        function drawArrow(ctx, fromX, fromY, toX, toY, scale) {
            const headlen = 10 / scale; // length of head in scaled units
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            // Draw the arrowhead if the vector has non-zero length
            if (dx !== 0 || dy !== 0) {
                ctx.beginPath();
                ctx.moveTo(toX, toY);
                ctx.lineTo(toX - headlen * Math.cos(angle - PI / 6), toY - headlen * Math.sin(angle - PI / 6));
                ctx.moveTo(toX, toY);
                ctx.lineTo(toX - headlen * Math.cos(angle + PI / 6), toY - headlen * Math.sin(angle + PI / 6));
                ctx.stroke();
            }
        }


        // Event Listeners
        vectorAxInput.addEventListener('input', updateVisualization);
        vectorAyInput.addEventListener('input', updateVisualization);
        vectorBxInput.addEventListener('input', updateVisualization);
        vectorByInput.addEventListener('input', updateVisualization);

        toggleConsiderationsButton.addEventListener('click', () => {
            const isHidden = keyConsiderationsContentDiv.style.display === 'none' || keyConsiderationsContentDiv.style.display === '';
            keyConsiderationsContentDiv.style.display = isHidden ? 'block' : 'none';
            toggleConsiderationsButton.textContent = isHidden ? 'Hide Key Considerations' : 'Show Key Considerations';
        });

        // Initial render
        updateVisualization();

        // Optional: Redraw canvas if the window is resized
        window.addEventListener('resize', updateVisualization);

    </script>
</body>
</html>
```