```html
<!DOCTYPE html>
<html>
<head>
    <title>SQL JOIN Explorer</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', monospace;
            color: #222222;
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Prevent scrolling */
        }

        .header {
            background-color: #2f8d46;
            color: #ffffff;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            flex-shrink: 0; /* Don't shrink */
        }

        .header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        .header p {
            margin-top: 5px;
            font-size: 1em;
            opacity: 0.9;
        }

        .main-content {
            flex-grow: 1; /* Take remaining space */
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1.5fr 1fr; /* Visualizer/Tables row taller than SQL/Comparison */
            gap: 15px;
            padding: 15px;
            overflow: hidden; /* Important for inner components */
        }

        .section {
            background-color: #f8f8f8;
            border: 1px solid #dddddd;
            border-radius: 5px;
            padding: 15px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .section-title {
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 10px;
            color: #2f8d46;
        }

        /* Table Explorer Styles */
        .table-explorer {
            grid-column: 1 / 2;
            grid-row: 1 / 2;
            overflow: auto; /* Scroll tables if needed */
        }

        .tables-container {
            display: flex;
            gap: 20px;
            height: 100%; /* Fill parent */
        }

        .data-table {
            flex: 1;
            border-collapse: collapse;
            width: 100%;
            font-size: 0.9em;
            table-layout: fixed; /* Fixed column width */
        }

        .data-table th, .data-table td {
            border: 1px solid #dddddd;
            padding: 8px;
            text-align: left;
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }

        .data-table th {
            background-color: #eeeeee;
            cursor: pointer;
            position: sticky;
            top: 0; /* Sticky header */
            z-index: 1; /* Ensure header is above body */
        }

        .data-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .data-table tr:hover {
            background-color: #e9e9e9;
            cursor: pointer;
        }

        .data-table tr.highlight-row {
            background-color: #ffffcc; /* Light yellow for row highlight */
        }

        .data-table th.highlight-column {
            background-color: #cceeff; /* Light blue for column highlight */
        }
         .data-table td.highlight-column {
            background-color: #e6f2ff; /* Lighter blue for cell highlight */
        }

        /* SQL Runner Styles */
        .sql-runner {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
        }

        .sql-input {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .sql-query-display {
             flex-grow: 1;
             background-color: #ffffff;
             border: 1px solid #dddddd;
             padding: 8px;
             font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
             font-size: 0.9em;
             margin-right: 10px;
             overflow-x: auto; /* Allow horizontal scrolling for query */
             white-space: nowrap;
             border-radius: 4px;
        }

        .sql-runner button {
            padding: 8px 15px;
            background-color: #2f8d46;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
        }

        .sql-runner button:hover {
            background-color: #257238;
        }

        .sql-output {
            flex-grow: 1;
            overflow: auto; /* Scroll output table */
            border: 1px solid #dddddd;
            background-color: #ffffff;
            border-radius: 4px;
        }

        .sql-output table {
             border-collapse: collapse;
             width: 100%;
             font-size: 0.9em;
        }

        .sql-output th, .sql-output td {
            border: 1px solid #dddddd;
            padding: 8px;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
         .sql-output th {
            background-color: #eee;
             position: sticky;
            top: 0; /* Sticky header */
            z-index: 1; /* Ensure header is above body */
         }
         .sql-output td.highlight-column {
            background-color: #e6f2ff; /* Lighter blue for cell highlight */
        }

        /* Join Visualizer Styles */
        .join-visualizer {
            grid-column: 2 / 3;
            grid-row: 1 / 2;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for animation */
        }

        .join-visualizer svg {
            width: 100%;
            height: 100%;
            max-width: 400px; /* Control max size */
            max-height: 300px;
            overflow: visible; /* Allow elements outside bounds if needed */
        }

         .venn-circle {
            fill: #2f8d46;
            fill-opacity: 0.3;
            stroke: #2f8d46;
            stroke-width: 2;
         }

         .venn-overlap {
            fill: #2f8d46;
            fill-opacity: 0.6;
         }

        .label {
            font-size: 1em;
            font-weight: bold;
            fill: #222222;
            text-anchor: middle;
        }
         .count {
            font-size: 0.9em;
             fill: #222222;
             text-anchor: middle;
         }

         /* Comparison Styles */
        .comparison {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .toggle-label {
            margin-right: 10px;
            font-weight: bold;
        }

        /* Basic Toggle Switch CSS (minimalist) */
        .switch {
          position: relative;
          display: inline-block;
          width: 40px;
          height: 20px;
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: .2s;
          border-radius: 20px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 16px;
          width: 16px;
          left: 2px;
          bottom: 2px;
          background-color: white;
          transition: .2s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: #2f8d46;
        }

        input:checked + .slider:before {
          transform: translateX(20px);
        }
        /* End Toggle Switch CSS */

        .join-type-options {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .join-type-options label {
            display: flex;
            align-items: center;
            font-size: 0.9em;
        }

        .join-type-options input[type="radio"] {
            margin-right: 5px;
             accent-color: #2f8d46; /* Style radio button */
        }

         .join-type-options label span {
             cursor: help; /* Indicate tooltip */
             border-bottom: 1px dotted #222; /* Dotted underline for tooltip */
         }

        /* Tooltip styles (simple) */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 140px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position above the text */
            left: 50%;
            margin-left: -70px; /* Center the tooltip */
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }


        /* Footer */
        .footer {
            background-color: #eeeeee;
            color: #222222;
            padding: 10px;
            text-align: center;
            font-size: 0.8em;
            flex-shrink: 0; /* Don't shrink */
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
        }

        .footer a {
            color: #2f8d46;
            text-decoration: none;
            margin: 0 10px;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Subtle Engagement Styles */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.01); }
            100% { transform: scale(1); }
        }

        .data-table tr.pulsing-row {
            animation: pulse 0.5s ease-in-out 2; /* Pulse twice */
        }

        /* Row highlight when hovering output row - this is tricky to map accurately without complex data linking.
           Deferring this specific subtle interaction for minimalism and stability.
           Column highlight when hovering output column is implemented.
        */

    </style>
</head>
<body>

    <div class="header">
        <h1>SQL JOIN Explorer</h1>
        <p>Visually understand how SQL JOIN operations combine data from different tables.</p>
    </div>

    <div class="main-content">

        <div class="section table-explorer">
            <h2 class="section-title">Data Tables</h2>
            <div class="tables-container">
                <div class="table-wrapper">
                    <h3>Professor</h3>
                    <table id="professor-table" class="data-table"></table>
                </div>
                <div class="table-wrapper">
                    <h3>Teacher</h3>
                    <table id="teacher-table" class="data-table"></table>
                </div>
            </div>
        </div>

        <div class="section join-visualizer">
             <h2 class="section-title">Join Visualization</h2>
             <svg id="join-diagram" viewBox="0 0 400 300"></svg>
        </div>

        <div class="section sql-runner">
            <h2 class="section-title">SQL Runner</h2>
            <div class="sql-input">
                 <div class="sql-query-display" id="sql-query">SELECT * FROM professor INNER JOIN teacher ON professor.prof_id = teacher.ID</div>
                 <button id="run-query">Run</button>
            </div>
            <div class="sql-output">
                <h3>Output</h3>
                <table id="output-table"></table>
            </div>
        </div>

        <div class="section comparison">
            <h2 class="section-title">Comparison</h2>
            <div class="toggle-container">
                 <span class="toggle-label">INNER JOIN</span>
                 <label class="switch">
                    <input type="checkbox" id="join-toggle">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label">OUTER JOIN</span>
            </div>

            <div class="join-type-options" id="outer-join-options" style="display: none;">
                <label class="tooltip">
                    <input type="radio" name="outer_type" value="LEFT" checked>
                    <span class="tooltiptext">Includes all rows from the left table, and matched rows from the right table. NULL for unmatched right rows.</span>
                    <span>LEFT</span>
                </label>
                 <label class="tooltip">
                    <input type="radio" name="outer_type" value="RIGHT">
                     <span class="tooltiptext">Includes all rows from the right table, and matched rows from the left table. NULL for unmatched left rows.</span>
                     <span>RIGHT</span>
                 </label>
                 <label class="tooltip">
                    <input type="radio" name="outer_type" value="FULL">
                     <span class="tooltiptext">Includes all rows from both tables. NULL for unmatched rows on either side.</span>
                     <span>FULL</span>
                 </label>
            </div>
             <!-- Add a simple description area -->
            <div id="join-description" style="margin-top: 10px; font-size: 0.9em;">
                <p><b>INNER JOIN:</b> Returns rows when there is a match in both tables.</p>
            </div>
        </div>

    </div>

    <div class="footer">
        <p>&copy; 2023 SQL JOIN Explorer |
            <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a> |
            <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
        </p>
    </div>

    <script>
        // Sample Data
        const professorData = [
            { prof_id: 1, prof_name: 'Alice', department: 'Physics' },
            { prof_id: 2, prof_name: 'Bob', department: 'Chemistry' },
            { prof_id: 3, prof_name: 'Charlie', department: 'Biology' },
            { prof_id: 4, prof_name: 'David', department: 'History' } // No matching teacher
        ];

        const teacherData = [
            { ID: 1, teacher_name: 'Alice T.', subject: 'Physics', prof_id: 1 },
            { ID: 2, teacher_name: 'Bob T.', subject: 'Chemistry', prof_id: 2 },
            { ID: 5, teacher_name: 'Eve T.', subject: 'Math', prof_id: 5 }, // No matching professor
            { ID: 6, teacher_name: 'Frank T.', subject: 'English', prof_id: 6 }, // No matching professor
            { ID: 3, teacher_name: 'Charlie T.', subject: 'Biology', prof_id: 3 }
        ];

        // DOM Elements
        const professorTableEl = document.getElementById('professor-table');
        const teacherTableEl = document.getElementById('teacher-table');
        const outputTableEl = document.getElementById('output-table');
        const sqlQueryEl = document.getElementById('sql-query');
        const runQueryBtn = document.getElementById('run-query');
        const joinDiagramSvg = document.getElementById('join-diagram');
        const joinToggle = document.getElementById('join-toggle');
        const outerJoinOptions = document.getElementById('outer-join-options');
        const joinDescriptionEl = document.getElementById('join-description');
        const outerTypeRadios = document.querySelectorAll('input[name="outer_type"]');

        // State
        let currentJoinType = 'INNER'; // INNER, LEFT, RIGHT, FULL
        let professorHeaders = Object.keys(professorData[0]);
        let teacherHeaders = Object.keys(teacherData[0]);
        let outputHeaders = []; // Dynamically determined after join
        let outputData = []; // Dynamically determined after join

        // --- Data Rendering Functions ---

        function renderTable(tableElement, data, headers, isProfessor = false) {
            tableElement.innerHTML = ''; // Clear table

            // Create header row
            const thead = tableElement.createTHead();
            const headerRow = thead.insertRow();
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                th.dataset.table = isProfessor ? 'professor' : 'teacher';
                th.dataset.column = headerText;
                headerRow.appendChild(th);
            });

            // Create body rows
            const tbody = tableElement.createTBody();
            data.forEach((rowData, rowIndex) => {
                const tr = tbody.insertRow();
                tr.dataset.index = rowIndex; // Store original index
                tr.dataset.table = isProfessor ? 'professor' : 'teacher';
                tr.dataset.profId = rowData.prof_id || rowData.ID; // Use prof_id or ID for relation

                headers.forEach(header => {
                    const td = tr.insertCell();
                    td.textContent = rowData[header] === null || rowData[header] === undefined ? 'NULL' : rowData[header];
                    td.dataset.column = header;
                     td.dataset.table = isProfessor ? 'professor' : 'teacher';
                });
            });
        }

         function renderOutputTable(tableElement, data, headers) {
             tableElement.innerHTML = ''; // Clear table

            if (data.length === 0) {
                tableElement.innerHTML = '<tbody><tr><td colspan="' + headers.length + '">No results</td></tr></tbody>';
                return;
            }

             // Create header row
            const thead = tableElement.createTHead();
            const headerRow = thead.insertRow();
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                 th.dataset.column = headerText; // Use headerText directly
                 // Determine source table for output column (heuristic based on name pattern)
                 th.dataset.sourceTable = headerText.includes('prof_') || headerText === 'department' || headerText === 'prof_name' ? 'professor' : 'teacher';
                headerRow.appendChild(th);
            });

            // Create body rows
            const tbody = tableElement.createTBody();
            data.forEach((rowData, rowIndex) => {
                const tr = tbody.insertRow();
                headers.forEach(header => {
                    const td = tr.insertCell();
                    td.textContent = rowData[header] === null || rowData[header] === undefined ? 'NULL' : rowData[header];
                    td.dataset.column = header;
                });
            });
         }

        // --- Join Logic ---

         // Simplified join function assuming specific tables and join condition
         function performJoin(joinType, data1, data2, key1, key2) {
             const result = [];
             const unmatched1 = new Set(data1.map(row => row[key1]));
             const unmatched2 = new Set(data2.map(row => row[key2]));

             // Perform INNER JOIN part and track matches
             data1.forEach(row1 => {
                 let matchFound = false;
                 data2.forEach(row2 => {
                     if (row1[key1] === row2[key2]) {
                         result.push({ ...row1, ...row2 });
                         unmatched1.delete(row1[key1]);
                         unmatched2.delete(row2[key2]);
                         matchFound = true;
                     }
                 });
             });

             if (joinType === 'INNER') {
                 // result is already populated with matches
             } else if (joinType === 'LEFT') {
                 // Add unmatched rows from data1
                 data1.forEach(row1 => {
                     if (unmatched1.has(row1[key1])) {
                         const nullRow2 = {};
                         Object.keys(data2[0]).forEach(key => nullRow2[key] = null);
                         result.push({ ...row1, ...nullRow2 });
                     }
                 });
             } else if (joinType === 'RIGHT') {
                 // Add unmatched rows from data2
                  data2.forEach(row2 => {
                     if (unmatched2.has(row2[key2])) {
                         const nullRow1 = {};
                         Object.keys(data1[0]).forEach(key => nullRow1[key] = null);
                         result.push({ ...nullRow1, ...row2 });
                     }
                 });
             } else if (joinType === 'FULL') {
                 // LEFT JOIN part (matches + unmatched from data1)
                 data1.forEach(row1 => {
                     let matchFound = false;
                     data2.forEach(row2 => {
                          if (row1[key1] === row2[key2]) {
                              matchFound = true;
                          }
                     });
                      if (!matchFound) {
                          const nullRow2 = {};
                          Object.keys(data2[0]).forEach(key => nullRow2[key] = null);
                          result.push({ ...row1, ...nullRow2 });
                      }
                 });
                 // RIGHT JOIN part (unmatched from data2 - matches are already added in the initial loop)
                 data2.forEach(row2 => {
                      let matchFound = false;
                     data1.forEach(row1 => {
                          if (row1[key1] === row2[key2]) {
                              matchFound = true;
                          }
                     });
                     if (!matchFound) {
                          const nullRow1 = {};
                         Object.keys(data1[0]).forEach(key => nullRow1[key] = null);
                         result.push({ ...nullRow1, ...row2 });
                     }
                 });
                 // The initial loop already added the INNER JOIN parts.
                 // Need to remove duplicates caused by combining LEFT and RIGHT logic naively.
                 // A better FULL JOIN is LEFT JOIN + unmatched from RIGHT JOIN.
                 // Let's rewrite FULL JOIN logic for clarity.

                 const leftJoinResult = [];
                  const matched1 = new Set(); // Keep track of data1 rows that found matches

                  data1.forEach(row1 => {
                     let matchFound = false;
                      data2.forEach(row2 => {
                          if (row1[key1] === row2[key2]) {
                              leftJoinResult.push({ ...row1, ...row2 });
                              matched1.add(row1[key1]);
                              matchFound = true;
                          }
                      });
                      if (!matchFound) {
                          const nullRow2 = {};
                          Object.keys(data2[0]).forEach(key => nullRow2[key] = null);
                          leftJoinResult.push({ ...row1, ...nullRow2 });
                      }
                  });

                  const fullJoinResult = [...leftJoinResult];

                  data2.forEach(row2 => {
                      let matchFoundInData1 = false;
                      data1.forEach(row1 => {
                          if (row1[key1] === row2[key2]) {
                              matchFoundInData1 = true;
                          }
                      });
                      // If a data2 row did NOT find a match in data1, add it (with nulls for data1 cols)
                      if (!matchFoundInData1) {
                           const nullRow1 = {};
                           Object.keys(data1[0]).forEach(key => nullRow1[key] = null);
                           fullJoinResult.push({ ...nullRow1, ...row2 });
                      }
                  });
                  return fullJoinResult; // Return the correct FULL JOIN result
             }

             // For INNER, LEFT, RIGHT, sort the result to group common keys
             if (joinType !== 'FULL') { // Full join needs a different sort strategy potentially, skip for simplicity
                 result.sort((a, b) => {
                      const keyA = a[key1] === null ? Infinity : a[key1]; // Handle nulls in sort
                      const keyB = b[key1] === null ? Infinity : b[key1];
                     if (keyA < keyB) return -1;
                     if (keyA > keyB) return 1;
                      // If keys are equal, sort by key2
                      const keyA2 = a[key2] === null ? Infinity : a[key2];
                      const keyB2 = b[key2] === null ? Infinity : b[key2];
                      if (keyA2 < keyB2) return -1;
                      if (keyA2 > keyB2) return 1;
                     return 0;
                 });
             }


             return result;
         }

         function executeCurrentJoin() {
             // Assuming JOIN ON professor.prof_id = teacher.ID
             const joinedData = performJoin(currentJoinType, professorData, teacherData, 'prof_id', 'ID');

             // Determine output headers - union of both tables' headers, without duplicates
             const pHeaders = Object.keys(professorData[0]);
             const tHeaders = Object.keys(teacherData[0]);
             outputHeaders = [...new Set([...pHeaders, ...tHeaders])];

             outputData = joinedData; // Store result

             renderOutputTable(outputTableEl, outputData, outputHeaders);
             updateJoinVisualizer(professorData, teacherData, outputData, currentJoinType);
             highlightMatchingRowsInTables(professorData, teacherData, outputData);
         }

        // --- Visualizer Logic (SVG) ---

        function updateJoinVisualizer(data1, data2, joinedData, joinType) {
            joinDiagramSvg.innerHTML = ''; // Clear previous drawing

            const svgWidth = 400;
            const svgHeight = 300; // Match max-width/height in CSS
            const centerX = svgWidth / 2;
            const centerY = svgHeight / 2;
            const radius = 100;
            const overlapOffset = 60; // How much circles overlap

            const colorProfessor = '#ff9900'; // Example color 1
            const colorTeacher = '#33cc33'; // Example color 2
             const colorOverlap = '#2f8d46'; // Green from theme

            // Calculate positions
            const circle1X = centerX - overlapOffset;
            const circle2X = centerX + overlapOffset;
            const circleY = centerY;

            // Count rows
            const count1 = data1.length;
            const count2 = data2.length;
             const countJoined = joinedData.filter(row =>
                 Object.keys(data1[0]).every(key => row[key] !== null && row[key] !== undefined) &&
                 Object.keys(data2[0]).every(key => row[key] !== null && row[key] !== undefined)
             ).length; // Count rows that have data from *both* original tables (inner join result count)

             const countLeftUnmatched = joinedData.filter(row =>
                 Object.keys(data1[0]).every(key => row[key] !== null && row[key] !== undefined) &&
                 Object.keys(data2[0]).some(key => row[key] === null || row[key] === undefined) // Check if at least one column from table 2 is null
             ).length;

              const countRightUnmatched = joinedData.filter(row =>
                 Object.keys(data2[0]).every(key => row[key] !== null && row[key] !== undefined) &&
                 Object.keys(data1[0]).some(key => row[key] === null || row[key] === undefined) // Check if at least one column from table 1 is null
             ).length;


            // Draw Circles (using paths for potentially smoother overlap clipping later, but simple circles for now)
            // Simple circles
            const circleProf = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleProf.setAttribute('cx', circle1X);
            circleProf.setAttribute('cy', circleY);
            circleProf.setAttribute('r', radius);
            circleProf.classList.add('venn-circle');
            circleProf.style.fill = colorProfessor;
            circleProf.style.stroke = colorProfessor;
            joinDiagramSvg.appendChild(circleProf);

             const circleTeach = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleTeach.setAttribute('cx', circle2X);
            circleTeach.setAttribute('cy', circleY);
            circleTeach.setAttribute('r', radius);
            circleTeach.classList.add('venn-circle');
             circleTeach.style.fill = colorTeacher;
             circleTeach.style.stroke = colorTeacher;
            joinDiagramSvg.appendChild(circleTeach);

            // Draw Overlap area (simple circle intersection approximation or draw paths if needed)
            // This is complex with just basic SVG shapes. Let's simplify:
            // Draw 3 circles: Left, Right, Middle (Overlap representation)

             const overlapCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
             overlapCircle.setAttribute('cx', centerX); // Position in the middle
             overlapCircle.setAttribute('cy', centerY);
             overlapCircle.setAttribute('r', radius / 1.5); // Smaller radius for overlap representation
             overlapCircle.classList.add('venn-overlap');
             overlapCircle.style.fill = colorOverlap;
             joinDiagramSvg.appendChild(overlapCircle);


            // Add Text Labels
            const textProf = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textProf.setAttribute('x', circle1X);
            textProf.setAttribute('y', circleY - radius - 10);
            textProf.classList.add('label');
            textProf.textContent = 'Professor';
            joinDiagramSvg.appendChild(textProf);

             const textCountProf = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textCountProf.setAttribute('x', circle1X);
            textCountProf.setAttribute('y', circleY - radius - 10 + 20);
            textCountProf.classList.add('count');
            textCountProf.textContent = `(${count1} rows)`;
            joinDiagramSvg.appendChild(textCountProf);


            const textTeach = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textTeach.setAttribute('x', circle2X);
            textTeach.setAttribute('y', circleY - radius - 10);
            textTeach.classList.add('label');
            textTeach.textContent = 'Teacher';
            joinDiagramSvg.appendChild(textTeach);

             const textCountTeach = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textCountTeach.setAttribute('x', circle2X);
            textCountTeach.setAttribute('y', circleY - radius - 10 + 20);
            textCountTeach.classList.add('count');
            textCountTeach.textContent = `(${count2} rows)`;
            joinDiagramSvg.appendChild(textCountTeach);


             // Text for Overlap/Result
             const textResult = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             textResult.setAttribute('x', centerX);
             textResult.setAttribute('y', centerY - 20);
             textResult.classList.add('label');
             joinDiagramSvg.appendChild(textResult);

             const textCountResult = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             textCountResult.setAttribute('x', centerX);
             textCountResult.setAttribute('y', centerY + 10);
             textCountResult.classList.add('count');
             joinDiagramSvg.appendChild(textCountResult);

             const textDescription = document.createElementNS('http://www.w3.org/2000/svg', 'text');
             textDescription.setAttribute('x', centerX);
             textDescription.setAttribute('y', centerY + 30);
             textDescription.classList.add('count'); // Reuse count style
             textDescription.style.fontSize = '0.8em';
             joinDiagramSvg.appendChild(textDescription);


            // Update text based on join type
            let resultText = '';
            let countResultText = `${joinedData.length} result rows`;
             let descriptionText = '';

            switch (joinType) {
                case 'INNER':
                    resultText = 'Matches';
                    descriptionText = `(${countJoined} matched rows)`;
                    break;
                case 'LEFT':
                     resultText = 'LEFT JOIN';
                     descriptionText = `(${countJoined} matched, ${countLeftUnmatched} left unmatched)`;
                    break;
                case 'RIGHT':
                    resultText = 'RIGHT JOIN';
                     descriptionText = `(${countJoined} matched, ${countRightUnmatched} right unmatched)`;
                    break;
                case 'FULL':
                    resultText = 'FULL JOIN';
                    descriptionText = `(${countJoined} matched, ${countLeftUnmatched} left unmatched, ${countRightUnmatched} right unmatched)`;
                    break;
            }

             textResult.textContent = resultText;
             textCountResult.textContent = countResultText;
             textDescription.textContent = descriptionText;


            // Optional: Add lines or visual cues connecting circles to show join type focus
            // This is complex for minimalist, skip for now.
        }

        // --- Highlighting Logic ---

        let highlightedColumns = { professor: null, teacher: null };
        let highlightedRows = { professor: null, teacher: null }; // Store index of selected row

        function highlightColumn(table, columnName) {
            const tableEl = table === 'professor' ? professorTableEl : teacherTableEl;
            const headers = tableEl.querySelectorAll('th');
            const cells = tableEl.querySelectorAll('td');

            // Remove existing highlight
            tableEl.querySelectorAll('.highlight-column').forEach(el => el.classList.remove('highlight-column'));
             outputTableEl.querySelectorAll('.highlight-column').forEach(el => el.classList.remove('highlight-column'));


            // Add highlight to selected column
            let columnIndex = -1;
            headers.forEach((th, index) => {
                if (th.textContent === columnName) {
                    th.classList.add('highlight-column');
                    columnIndex = index;
                }
            });

            if (columnIndex !== -1) {
                 cells.forEach(td => {
                    if (td.cellIndex === columnIndex) {
                        td.classList.add('highlight-column');
                    }
                });
            }

            // Update state
            highlightedColumns[table] = columnName;

             // Highlight corresponding column in output table if it exists
             const outputHeadersEl = outputTableEl.querySelectorAll('th');
             outputHeadersEl.forEach(th => {
                 // Crude heuristic: match header text or look for known joins keys
                 if (th.textContent === columnName ||
                     (table === 'professor' && th.textContent === 'prof_id' && columnName === 'prof_id') ||
                     (table === 'teacher' && th.textContent === 'ID' && columnName === 'ID') // Assuming ID is the join key in teacher
                    ) {
                     th.classList.add('highlight-column');
                      // Highlight corresponding cells in output table
                      const outputCells = outputTableEl.querySelectorAll('td');
                      outputCells.forEach(td => {
                          if (td.cellIndex === th.cellIndex) {
                             td.classList.add('highlight-column');
                          }
                      });
                 }
             });

        }

         function clearColumnHighlights() {
             professorTableEl.querySelectorAll('.highlight-column').forEach(el => el.classList.remove('highlight-column'));
             teacherTableEl.querySelectorAll('.highlight-column').forEach(el => el.classList.remove('highlight-column'));
             outputTableEl.querySelectorAll('.highlight-column').forEach(el => el.classList.remove('highlight-column'));
             highlightedColumns = { professor: null, teacher: null };
         }

        function highlightRow(table, rowIndex) {
            const tableEl = table === 'professor' ? professorTableEl : teacherTableEl;
            const otherTableEl = table === 'professor' ? teacherTableEl : professorTableEl;

            // Remove existing highlight
             tableEl.querySelectorAll('.highlight-row').forEach(el => el.classList.remove('highlight-row', 'pulsing-row'));
             otherTableEl.querySelectorAll('.highlight-row').forEach(el => el.classList.remove('highlight-row', 'pulsing-row'));


            // Add highlight to selected row
            const selectedRowEl = tableEl.querySelector(`tr[data-index='${rowIndex}']`);
            if (selectedRowEl) {
                 selectedRowEl.classList.add('highlight-row');

                 // Find related row in the other table based on join key
                 const selectedProfId = selectedRowEl.dataset.profId; // Works for both tables if data-prof-id is set

                 const otherTableRows = otherTableEl.querySelectorAll('tr');
                 let matchFound = false;
                 otherTableRows.forEach(otherRowEl => {
                     if (otherRowEl.dataset.profId && otherRowEl.dataset.profId === selectedProfId) {
                         otherRowEl.classList.add('highlight-row');
                         // Add pulse animation if they are a match in the INNER JOIN result
                         const professorRow = table === 'professor' ? professorData[rowIndex] : dataLookup('professor', selectedProfId);
                          const teacherRow = table === 'teacher' ? teacherData[rowIndex] : dataLookup('teacher', selectedProfId);

                          // Check if this pair exists in the INNER JOIN result
                          if (isRowPairInInnerJoin(professorRow, teacherRow)) {
                              selectedRowEl.classList.add('pulsing-row');
                              otherRowEl.classList.add('pulsing-row');
                          }
                         matchFound = true;
                     }
                 });

                // If no match was found in the other table, pulse the selected row itself if it's in the current join result
                if (!matchFound) {
                     const selectedRowData = table === 'professor' ? professorData[rowIndex] : teacherData[rowIndex];
                    if (isRowInCurrentJoin(selectedRowData, table)) {
                         selectedRowEl.classList.add('pulsing-row');
                    }
                }

            }

            // Update state (optional, mainly for tracking)
             highlightedRows[table] = rowIndex;
             highlightedRows[table === 'professor' ? 'teacher' : 'professor'] = null; // Clear other table highlight state
        }

        function clearRowHighlights() {
            professorTableEl.querySelectorAll('.highlight-row').forEach(el => el.classList.remove('highlight-row', 'pulsing-row'));
            teacherTableEl.querySelectorAll('.highlight-row').forEach(el => el.classList.remove('highlight-row', 'pulsing-row'));
             highlightedRows = { professor: null, teacher: null };
        }

         // Helper to lookup data by join key
         function dataLookup(table, profId) {
             const data = table === 'professor' ? professorData : teacherData;
             const key = table === 'professor' ? 'prof_id' : 'ID';
             return data.find(row => row[key] === parseInt(profId));
         }

         // Helper to check if a professor/teacher row pair exists in the INNER JOIN result
         function isRowPairInInnerJoin(profRow, teachRow) {
             if (!profRow || !teachRow) return false;
             // Simple check based on the join key
             return profRow.prof_id === teachRow.ID;
         }

         // Helper to check if a given row is present in the current join result
         function isRowInCurrentJoin(rowData, originalTable) {
              if (!rowData || !outputData) return false;

              const originalKey = originalTable === 'professor' ? 'prof_id' : 'ID';
              const originalValue = rowData[originalKey];

             if (originalValue === undefined) return false;

              // Check if any row in the output matches the original row's key,
              // AND that row in the output does *not* have nulls for columns from the original table.
             const originalTableKeys = Object.keys(originalTable === 'professor' ? professorData[0] : teacherData[0]);

              return outputData.some(outputRow => {
                  // Check if the key value matches (handle prof_id vs ID mapping in output)
                  const outputKeyValue = originalTable === 'professor' ? outputRow.prof_id : outputRow.ID;
                   if (outputKeyValue !== originalValue) return false;

                   // Check if all columns from the original table have non-null values in the output row
                   return originalTableKeys.every(key => outputRow[key] !== null && outputRow[key] !== undefined);
              });
         }


        // Highlight rows in source tables based on the current join result
         function highlightMatchingRowsInTables(data1, data2, joinedData) {
            // Remove previous match highlights
            professorTableEl.querySelectorAll('tr').forEach(tr => tr.classList.remove('join-match', 'join-unmatched-left', 'join-unmatched-right'));
             teacherTableEl.querySelectorAll('tr').forEach(tr => tr.classList.remove('join-match', 'join-unmatched-left', 'join-unmatched-right'));

            const matchedProfIds = new Set();
            const matchedTeacherIds = new Set();

             // Identify matched rows based on the INNER JOIN part of the result
             joinedData.forEach(row => {
                  // A row is a "match" if it has data from *both* original tables
                  const hasProfData = Object.keys(data1[0]).every(key => row[key] !== null && row[key] !== undefined);
                  const hasTeachData = Object.keys(data2[0]).every(key => row[key] !== null && row[key] !== undefined);

                  if (hasProfData && hasTeachData) {
                      matchedProfIds.add(row.prof_id);
                      matchedTeacherIds.add(row.ID);
                  }
             });


             // Apply classes to original tables
             professorTableEl.querySelectorAll('tbody tr').forEach(tr => {
                 const profId = parseInt(tr.dataset.profId);
                 if (matchedProfIds.has(profId)) {
                      tr.classList.add('join-match');
                 } else if (currentJoinType === 'LEFT' || currentJoinType === 'FULL') {
                     // In LEFT or FULL, unmatched left rows are included
                      tr.classList.add('join-unmatched-left');
                 }
             });

             teacherTableEl.querySelectorAll('tbody tr').forEach(tr => {
                  const teacherId = parseInt(tr.dataset.profId); // Using data-prof-id which should map to teacher.ID
                  if (matchedTeacherIds.has(teacherId)) {
                      tr.classList.add('join-match');
                  } else if (currentJoinType === 'RIGHT' || currentJoinType === 'FULL') {
                     // In RIGHT or FULL, unmatched right rows are included
                      tr.classList.add('join-unmatched-right');
                  }
             });

             // Add CSS for these new classes
             const styleEl = document.getElementById('dynamic-join-styles');
             if (!styleEl) {
                 const head = document.head || document.getElementsByTagName('head')[0];
                 const style = document.createElement('style');
                 style.id = 'dynamic-join-styles';
                 head.appendChild(style);
             }
              document.getElementById('dynamic-join-styles').innerHTML = `
                 .data-table tr.join-match {
                     background-color: #d4edda !important; /* Light green */
                 }
                 .data-table tr.join-unmatched-left {
                     background-color: #fff3cd !important; /* Light yellow */
                     opacity: 0.7;
                 }
                 .data-table tr.join-unmatched-right {
                     background-color: #f8d7da !important; /* Light red/pink */
                      opacity: 0.7;
                 }
             `;

         }


        // --- Event Listeners ---

        function setupTableListeners() {
            // Column Header Clicks
            document.querySelectorAll('.data-table th').forEach(th => {
                th.addEventListener('click', function() {
                    const table = this.dataset.table;
                    const column = this.dataset.column;
                    highlightColumn(table, column);
                });
            });

            // Row Clicks
            document.querySelectorAll('.data-table tbody tr').forEach(tr => {
                tr.addEventListener('click', function() {
                    const table = this.dataset.table;
                    const rowIndex = parseInt(this.dataset.index);
                    highlightRow(table, rowIndex);
                });
            });

            // Output Header Hover
             outputTableEl.addEventListener('mouseover', function(e) {
                 if (e.target.tagName === 'TH') {
                     const th = e.target;
                     const outputColumn = th.dataset.column;
                     const sourceTable = th.dataset.sourceTable; // Heuristic source table

                      // Remove existing highlights
                      clearColumnHighlights();

                      // Highlight the output column
                      outputTableEl.querySelectorAll('.highlight-column').forEach(el => el.classList.remove('highlight-column'));
                       th.classList.add('highlight-column');
                       outputTableEl.querySelectorAll(`td:nth-child(${th.cellIndex + 1})`).forEach(td => {
                           td.classList.add('highlight-column');
                       });


                     // Attempt to highlight corresponding column in source tables
                      const professorHeadersEl = professorTableEl.querySelectorAll('th');
                      const teacherHeadersEl = teacherTableEl.querySelectorAll('th');

                     professorHeadersEl.forEach(pth => {
                         if (pth.textContent === outputColumn || (sourceTable === 'professor' && pth.textContent === outputColumn) || (outputColumn === 'prof_id' && pth.textContent === 'prof_id')) {
                             highlightColumn('professor', pth.textContent);
                         }
                     });

                      teacherHeadersEl.forEach(tth => {
                         // Match by name, or if outputColumn is prof_id, match teacher.ID
                          if (tth.textContent === outputColumn || (sourceTable === 'teacher' && tth.textContent === outputColumn) || (outputColumn === 'prof_id' && tth.textContent === 'ID')) {
                             highlightColumn('teacher', tth.textContent);
                         }
                     });

                 }
             });

             // Output Header Mouseout - Clear column highlights
             outputTableEl.addEventListener('mouseout', function(e) {
                 if (e.target.tagName === 'TH') {
                     clearColumnHighlights();
                 }
             });
        }

        // Run button click
        runQueryBtn.addEventListener('click', executeCurrentJoin);

        // Join Toggle change
        joinToggle.addEventListener('change', function() {
            if (this.checked) { // OUTER JOIN
                currentJoinType = document.querySelector('input[name="outer_type"]:checked').value;
                outerJoinOptions.style.display = 'flex';
                 sqlQueryEl.textContent = sqlQueryEl.textContent.replace('INNER JOIN', currentJoinType + ' JOIN');
                 joinDescriptionEl.innerHTML = getDescriptionForJoinType(currentJoinType);

            } else { // INNER JOIN
                currentJoinType = 'INNER';
                outerJoinOptions.style.display = 'none';
                 sqlQueryEl.textContent = sqlQueryEl.textContent.replace(/(LEFT|RIGHT|FULL) JOIN/, 'INNER JOIN');
                 joinDescriptionEl.innerHTML = getDescriptionForJoinType(currentJoinType);
            }
            executeCurrentJoin();
        });

        // Outer Join Type radio button change
        outerTypeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                if (joinToggle.checked) { // Only update if toggle is on OUTER
                    currentJoinType = this.value;
                     sqlQueryEl.textContent = sqlQueryEl.textContent.replace(/(LEFT|RIGHT|FULL) JOIN/, currentJoinType + ' JOIN');
                    joinDescriptionEl.innerHTML = getDescriptionForJoinType(currentJoinType);
                    executeCurrentJoin();
                }
            });
        });

         // Helper to get description for join type
         function getDescriptionForJoinType(type) {
             switch (type) {
                 case 'INNER': return '<p><b>INNER JOIN:</b> Returns rows when there is a match in both tables.</p>';
                 case 'LEFT': return '<p><b>LEFT JOIN:</b> Includes all rows from the left table (Professor), and matched rows from the right table (Teacher). Returns NULL for Teacher columns where no match exists.</p>';
                 case 'RIGHT': return '<p><b>RIGHT JOIN:</b> Includes all rows from the right table (Teacher), and matched rows from the left table (Professor). Returns NULL for Professor columns where no match exists.</p>';
                 case 'FULL': return '<p><b>FULL JOIN:</b> Includes all rows from both tables (Professor and Teacher). Returns NULL for columns where a row has no match in the other table.</p>';
                 default: return '';
             }
         }


        // --- Initial Setup ---

        function init() {
            // Render initial tables
            renderTable(professorTableEl, professorData, professorHeaders, true);
            renderTable(teacherTableEl, teacherData, teacherHeaders, false);

            // Set up event listeners for table interactions
            setupTableListeners();

            // Execute initial INNER JOIN query
            executeCurrentJoin();
        }

        // Run initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
```