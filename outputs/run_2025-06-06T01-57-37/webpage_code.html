```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosine Similarity</title>
    <style>
        /* --- Global Styles --- */
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #ffffff; /* GeeksforGeeks Background */
            color: #222222; /* GeeksforGeeks Text */
            overflow: hidden; /* Fixed viewport */
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }

        header {
            background-color: #2f8d46; /* GeeksforGeeks Primary */
            color: #ffffff;
            padding: 15px;
            text-align: center;
            font-size: 1.8em;
            font-weight: bold;
            flex-shrink: 0; /* Prevent shrinking */
        }

        footer {
            background-color: #f0f0f0; /* Light grey for footer */
            color: #222222;
            padding: 10px;
            text-align: center;
            font-size: 0.9em;
            flex-shrink: 0; /* Prevent shrinking */
        }

        footer a {
            color: #2f8d46; /* GeeksforGeeks Primary for links */
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        main {
            display: flex;
            flex-grow: 1; /* Take available space */
            overflow: hidden; /* Hide scrollbars in main if panels try to overflow */
        }

        .panel {
            padding: 20px;
            overflow-y: auto; /* Allow panels to scroll if content exceeds height */
            box-sizing: border-box;
            border-right: 1px solid #ddd; /* Separator line */
        }

        #left-panel {
            width: 30%;
            flex-shrink: 0; /* Prevent shrinking */
        }

        #right-panel {
            width: 70%;
            display: flex;
            flex-direction: column; /* Arrange content vertically */
            /* border-left: 1px solid #ddd; */ /* Separator handled by left panel */
        }

        h2 {
            color: #2f8d46; /* GeeksforGeeks Primary */
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-top: 0;
        }

        /* --- Vector Input Panel --- */
        .vector-input-group {
            margin-bottom: 20px;
        }

        .vector-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .vector-input-group input[type="number"] {
            width: calc(50% - 10px); /* Adjusted for padding/margin */
            padding: 8px;
            margin: 0 5px 0 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            text-align: center;
        }

        /* --- Visual Representation Panel --- */
        #visual-representation {
            flex-grow: 1; /* Canvas takes remaining space in right panel */
            width: 100%;
            box-sizing: border-box;
            position: relative; /* For positioning elements inside */
        }

        #vectorCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #ffffff; /* White canvas background */
        }

        /* Tooltip for angle interpretation on canvas */
        #angle-display {
             position: absolute;
             bottom: 10px;
             left: 10px;
             background-color: rgba(255, 255, 255, 0.9);
             border: 1px solid #ddd;
             padding: 5px 10px;
             border-radius: 4px;
             font-size: 0.9em;
             pointer-events: none; /* Don't interfere with canvas interaction */
        }


        /* --- Calculation Breakdown Panel --- */
        #calculation-breakdown {
             padding: 10px 20px; /* Add padding similar to other sections */
             border-top: 1px solid #ddd; /* Separator */
        }

        #calculation-breakdown div {
            margin-bottom: 8px;
            padding: 4px;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }

        #calculation-breakdown div strong {
            color: #2f8d46; /* GeeksforGeeks Primary */
        }

        #calculation-breakdown div.highlight {
            background-color: #e0f2e7; /* Light green for hover highlight */
        }

        /* --- Dissimilarity Display --- */
        #dissimilarity-display {
             padding: 10px 20px; /* Add padding */
             border-top: 1px solid #ddd; /* Separator */
        }
        #dissimilarity-gauge {
            width: 100%;
            height: 20px;
            background-color: #eee;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        #dissimilarity-bar {
            height: 100%;
            width: 0%; /* Will be set by JS */
            background-color: #2f8d46; /* Green for Dissimilarity */
            transition: width 0.5s ease-in-out;
        }

        #dissimilarity-label {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 20px; /* Center vertically */
            color: #222;
            font-size: 0.8em;
        }

        /* --- Angle Interpretation Panel --- */
         #angle-interpretation {
             padding: 10px 20px; /* Add padding */
             border-top: 1px solid #ddd; /* Separator */
             display: flex;
             justify-content: space-around;
             flex-wrap: wrap; /* Allow wrapping on smaller screens */
         }

         .angle-range {
             flex-basis: 30%; /* Give each item about 30% width */
             text-align: center;
             padding: 10px 5px;
             margin: 5px;
             border: 1px solid #ccc;
             border-radius: 4px;
             cursor: pointer;
             transition: background-color 0.2s ease, border-color 0.2s ease;
             font-size: 0.9em;
         }

         .angle-range:hover {
             background-color: #f0f0f0;
         }

         .angle-range.active {
             border-color: #2f8d46; /* Highlight active range */
             background-color: #e0f2e7; /* Light green background */
             font-weight: bold;
         }

         .angle-range p {
            margin: 0;
            font-size: 0.8em;
            color: #555;
         }
         .angle-range span {
             display: block;
             font-size: 1em;
             margin-bottom: 5px;
             color: #222;
         }


    </style>
</head>
<body>

    <header>
        Cosine Similarity: Interactive Learning Experience
    </header>

    <main>
        <section id="left-panel" class="panel">
            <h2>Vector Input</h2>

            <div class="vector-input-group">
                <label for="vectorX-x1">Vector X:</label>
                <input type="number" id="vectorX-x1" value="2">
                <input type="number" id="vectorX-x2" value="3">
            </div>

            <div class="vector-input-group">
                <label for="vectorY-x1">Vector Y:</label>
                <input type="number" id="vectorY-x1" value="-3">
                <input type="number" id="vectorY-x2" value="2">
            </div>

        </section>

        <section id="right-panel" class="panel">
            <div id="visual-representation">
                 <h2>Visual Representation</h2>
                 <canvas id="vectorCanvas"></canvas>
                 <div id="angle-display">Angle: --°</div>
            </div>

            <div id="calculation-breakdown">
                <h2>Calculation Breakdown</h2>
                <div id="calc-dot-product"><strong>Dot Product (X · Y):</strong> Loading...</div>
                <div id="calc-magnitudeX"><strong>Magnitude |X|:</strong> Loading...</div>
                <div id="calc-magnitudeY"><strong>Magnitude |Y|:</strong> Loading...</div>
                <div id="calc-cosine"><strong>Cosine Similarity:</strong> Loading...</div>
                <div id="calc-angle"><strong>Angle (°):</strong> Loading...</div>
            </div>

             <div id="dissimilarity-display">
                <h2>Dissimilarity</h2>
                <div id="dissimilarity-gauge">
                     <div id="dissimilarity-bar"></div>
                     <div id="dissimilarity-label">Loading...</div>
                </div>
            </div>

            <div id="angle-interpretation">
                 <h2>Angle Interpretation</h2>
                 <div class="angle-range" data-min-angle="0" data-max-angle="30">
                     <span>0° - 30°</span>
                     <p>Highly Similar</p>
                 </div>
                 <div class="angle-range" data-min-angle="30" data-max-angle="60">
                     <span>30° - 60°</span>
                     <p>Moderately Similar</p>
                 </div>
                 <div class="angle-range" data-min-angle="60" data-max-angle="90">
                      <span>60° - 90°</span>
                      <p>Weakly Similar</p>
                 </div>
                  <div class="angle-range" data-min-angle="90" data-max-angle="120">
                       <span>90° - 120°</span>
                       <p>Weakly Dissimilar</p>
                  </div>
                   <div class="angle-range" data-min-angle="120" data-max-angle="150">
                        <span>120° - 150°</span>
                        <p>Moderately Dissimilar</p>
                   </div>
                    <div class="angle-range" data-min-angle="150" data-max-angle="180">
                         <span>150° - 180°</span>
                         <p>Highly Dissimilar</p>
                    </div>
            </div>
        </section>
    </main>

    <footer>
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        // --- DOM References ---
        const canvas = document.getElementById('vectorCanvas');
        const ctx = canvas.getContext('2d');

        const inputX1 = document.getElementById('vectorX-x1');
        const inputX2 = document.getElementById('vectorX-x2');
        const inputY1 = document.getElementById('vectorY-x1');
        const inputY2 = document.getElementById('vectorY-x2');

        const calcDotProductDiv = document.getElementById('calc-dot-product');
        const calcMagnitudeXDiv = document.getElementById('calc-magnitudeX');
        const calcMagnitudeYDiv = document.getElementById('calc-magnitudeY');
        const calcCosineDiv = document.getElementById('calc-cosine');
        const calcAngleDiv = document.getElementById('calc-angle');
        const angleDisplayDiv = document.getElementById('angle-display');

        const dissimilarityBar = document.getElementById('dissimilarity-bar');
        const dissimilarityLabel = document.getElementById('dissimilarity-label');

        const angleRanges = document.querySelectorAll('.angle-range');

        // --- State ---
        let vectorX = [parseFloat(inputX1.value), parseFloat(inputX2.value)];
        let vectorY = [parseFloat(inputY1.value), parseFloat(inputY2.value)];
        let canvasCenter = { x: 0, y: 0 }; // Will be set on resize
        let scale = 50; // Pixels per unit

        // --- Canvas Drawing ---
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            canvasCenter = { x: canvas.width / 2, y: canvas.height / 2 };
            drawCanvas();
        }

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvasCenter.y);
            ctx.lineTo(canvas.width, canvasCenter.y); // X-axis
            ctx.moveTo(canvasCenter.x, 0);
            ctx.lineTo(canvasCenter.x, canvas.height); // Y-axis
            ctx.stroke();

             // Draw grid lines (optional, basic)
             ctx.strokeStyle = '#eeeeee';
             const gridStep = scale;
             // Vertical lines
             for(let x = canvasCenter.x + gridStep; x < canvas.width; x += gridStep) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
             for(let x = canvasCenter.x - gridStep; x > 0; x -= gridStep) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
             // Horizontal lines
             for(let y = canvasCenter.y + gridStep; y < canvas.height; y += gridStep) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
             for(let y = canvasCenter.y - gridStep; y > 0; y -= gridStep) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }


            // Draw vectors
            ctx.lineWidth = 2;

            // Vector X (Red/Orange-ish - distinct from GFG green)
            ctx.strokeStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(canvasCenter.x, canvasCenter.y);
            ctx.lineTo(canvasCenter.x + vectorX[0] * scale, canvasCenter.y - vectorX[1] * scale); // Y is inverted on canvas
            ctx.stroke();
            drawArrowhead(canvasCenter.x, canvasCenter.y, canvasCenter.x + vectorX[0] * scale, canvasCenter.y - vectorX[1] * scale, '#ff6600');


            // Vector Y (Blue-ish - distinct)
            ctx.strokeStyle = '#0099ff';
            ctx.beginPath();
            ctx.moveTo(canvasCenter.x, canvasCenter.y);
            ctx.lineTo(canvasCenter.x + vectorY[0] * scale, canvasCenter.y - vectorY[1] * scale);
            ctx.stroke();
             drawArrowhead(canvasCenter.x, canvasCenter.y, canvasCenter.x + vectorY[0] * scale, canvasCenter.y - vectorY[1] * scale, '#0099ff');


            // Draw angle arc if magnitudes are non-zero
            const magX = Math.sqrt(vectorX[0]*vectorX[0] + vectorX[1]*vectorX[1]);
            const magY = Math.sqrt(vectorY[0]*vectorY[0] + vectorY[1]*vectorY[1]);

            if (magX > 0 && magY > 0) {
                 let angleRad = Math.acos(dotProduct(vectorX, vectorY) / (magX * magY));
                 let angleDeg = angleRad * (180 / Math.PI);

                 // Determine start and end angles for arc (relative to positive X axis)
                 let angleX = Math.atan2(-vectorX[1], vectorX[0]); // Note negative Y for canvas coords
                 let angleY = Math.atan2(-vectorY[1], vectorY[0]);

                 // Ensure angle is positive and between 0 and 2PI
                 if (angleX < 0) angleX += 2 * Math.PI;
                 if (angleY < 0) angleY += 2 * Math.PI;

                 let startAngle = Math.min(angleX, angleY);
                 let endAngle = Math.max(angleX, angleY);

                 // If the angle spans across the positive X axis (e.g., -30 deg and +30 deg),
                 // the short path is actually the one calculated (60 deg).
                 // If angle is > 180, the long path is the short one.
                 // Simple check: If the difference > PI, the angle is measured the other way
                 if (endAngle - startAngle > Math.PI) {
                      [startAngle, endAngle] = [endAngle, startAngle + 2 * Math.PI]; // Swap and add 2PI to one
                 }


                 ctx.strokeStyle = '#2f8d46'; // GFG Green for angle arc
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 // Arc needs radius, start angle, end angle, counterclockwise
                 const arcRadius = Math.min(50, Math.min(magX, magY) * scale * 0.5); // Dynamic radius
                 ctx.arc(canvasCenter.x, canvasCenter.y, arcRadius, startAngle, endAngle);
                 ctx.stroke();

                 // Display angle value
                 angleDisplayDiv.textContent = `Angle: ${angleDeg.toFixed(1)}°`;

            } else {
                 angleDisplayDiv.textContent = `Angle: --°`;
            }

             // Draw origin dot
             ctx.fillStyle = '#222';
             ctx.beginPath();
             ctx.arc(canvasCenter.x, canvasCenter.y, 3, 0, Math.PI * 2);
             ctx.fill();

             // Draw labels (optional)
             ctx.fillStyle = '#222';
             ctx.font = '12px Arial';
             ctx.fillText('X', canvasCenter.x + vectorX[0] * scale + 5, canvasCenter.y - vectorX[1] * scale - 5);
             ctx.fillText('Y', canvasCenter.x + vectorY[0] * scale + 5, canvasCenter.y - vectorY[1] * scale - 5);
             ctx.fillText('0', canvasCenter.x - 15, canvasCenter.y + 15);
             ctx.fillText('X+', canvas.width - 20, canvasCenter.y + 15);
             ctx.fillText('Y+', canvasCenter.x - 15, 15);
        }

        // Helper to draw arrow heads
        function drawArrowhead(fromX, fromY, toX, toY, color) {
          const headlen = 10; // length of head in pixels
          const angle = Math.atan2(toY - fromY, toX - fromX);
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(toX, toY);
          ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
          ctx.moveTo(toX, toY);
          ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
          ctx.stroke();
        }


        // --- Calculations ---
        function dotProduct(v1, v2) {
            let dot = 0;
            for (let i = 0; i < v1.length; i++) {
                dot += v1[i] * v2[i];
            }
            return dot;
        }

        function magnitude(v) {
            let sumSq = 0;
            for (let i = 0; i < v.length; i++) {
                sumSq += v[i] * v[i];
            }
            return Math.sqrt(sumSq);
        }

        function cosineSimilarity(v1, v2) {
            const dot = dotProduct(v1, v2);
            const mag1 = magnitude(v1);
            const mag2 = magnitude(v2);

            if (mag1 === 0 || mag2 === 0) {
                return 0; // Or NaN, depending on desired behavior for zero vectors
            }
            return dot / (mag1 * mag2);
        }

        // --- Update Displays ---
        function updateCalculations() {
            const dot = dotProduct(vectorX, vectorY);
            const magX = magnitude(vectorX);
            const magY = magnitude(vectorY);
            const cosine = cosineSimilarity(vectorX, vectorY);
            const angleRad = Math.acos(Math.max(-1, Math.min(1, cosine))); // Clamp cosine to [-1, 1] due to floating point inaccuracies
            const angleDeg = angleRad * (180 / Math.PI);

            calcDotProductDiv.innerHTML = `<strong>Dot Product (X · Y):</strong> ${vectorX.join('⋅')}+${vectorY.join('⋅')} = ${dot.toFixed(2)}`;
            calcMagnitudeXDiv.innerHTML = `<strong>Magnitude |X|:</strong> √(${vectorX.map(val => val + '²').join(' + ')}) = ${magX.toFixed(2)}`;
            calcMagnitudeYDiv.innerHTML = `<strong>Magnitude |Y|:</strong> √(${vectorY.map(val => val + '²').join(' + ')}) = ${magY.toFixed(2)}`;
            calcCosineDiv.innerHTML = `<strong>Cosine Similarity:</strong> ${dot.toFixed(2)} / (${magX.toFixed(2)} ⋅ ${magY.toFixed(2)}) = ${cosine.toFixed(2)}`;
            calcAngleDiv.innerHTML = `<strong>Angle (°):</strong> arccos(${cosine.toFixed(2)}) = ${angleDeg.toFixed(1)}°`;

            // Update Dissimilarity Gauge
            // Map cosine -1..1 to dissimilarity 1..0 or 0..100%?
            // 0 deg (cos=1) -> 0% dissimilarity
            // 90 deg (cos=0) -> 50% dissimilarity
            // 180 deg (cos=-1) -> 100% dissimilarity
            const dissimilarityPercentage = ((1 - cosine) / 2) * 100;
            dissimilarityBar.style.width = `${dissimilarityPercentage.toFixed(1)}%`;
            dissimilarityLabel.textContent = `${dissimilarityPercentage.toFixed(1)}% Dissimilarity`;

            // Update Angle Interpretation Highlight
            angleRanges.forEach(range => {
                const min = parseFloat(range.dataset.minAngle);
                const max = parseFloat(range.dataset.maxAngle);
                if (angleDeg >= min && angleDeg < max + (max === 180 ? 0.1 : 0)) { // Account for 180deg boundary
                    range.classList.add('active');
                } else {
                    range.classList.remove('active');
                }
            });

            // Redraw canvas with updated angle
            drawCanvas();
        }

        // --- Event Handlers ---
        function handleInputChange() {
            vectorX = [parseFloat(inputX1.value) || 0, parseFloat(inputX2.value) || 0];
            vectorY = [parseFloat(inputY1.value) || 0, parseFloat(inputY2.value) || 0];
             // Check for NaN resulting from empty inputs and set to 0
            if (isNaN(vectorX[0])) vectorX[0] = 0;
            if (isNaN(vectorX[1])) vectorX[1] = 0;
            if (isNaN(vectorY[0])) vectorY[0] = 0;
            if (isNaN(vectorY[1])) vectorY[1] = 0;

            updateCalculations();
        }

        function handleCalculationHover(event) {
            const target = event.target.closest('div');
            if (!target) return;

            const id = target.id;

            // Remove all highlights first
            inputX1.classList.remove('highlight');
            inputX2.classList.remove('highlight');
            inputY1.classList.remove('highlight');
            inputY2.classList.remove('highlight');
            calcDotProductDiv.classList.remove('highlight');
            calcMagnitudeXDiv.classList.remove('highlight');
            calcMagnitudeYDiv.classList.remove('highlight');
            calcCosineDiv.classList.remove('highlight');
            calcAngleDiv.classList.remove('highlight');


            if (event.type === 'mouseover') {
                 target.classList.add('highlight');
                if (id === 'calc-dot-product' || id === 'calc-cosine' || id === 'calc-angle') {
                    inputX1.classList.add('highlight');
                    inputX2.classList.add('highlight');
                    inputY1.classList.add('highlight');
                    inputY2.classList.add('highlight');
                } else if (id === 'calc-magnitudeX') {
                    inputX1.classList.add('highlight');
                    inputX2.classList.add('highlight');
                } else if (id === 'calc-magnitudeY') {
                    inputY1.classList.add('highlight');
                    inputY2.classList.add('highlight');
                }
                 // No canvas highlight implemented due to complexity without libraries
            }
             // Mouseout handled by removing all highlights above
        }

        function handleAngleRangeClick(event) {
             const target = event.target.closest('.angle-range');
             if (!target) return;

             // Optional: Display a temporary message or persistent text
             // For this minimalist version, we'll just ensure the active class logic is clear.
             // The current angle range is already highlighted by the updateCalculations() function.
             // Clicking *could* show a tooltip explaining the meaning further, but let's keep it simple.
             // Clicking now just ensures the active state is visible and maybe adds a temporary effect.
             // Let's add a simple pulse effect on click.
             target.classList.add('clicked-pulse');
             setTimeout(() => {
                 target.classList.remove('clicked-pulse');
             }, 500); // Remove pulse after 0.5s
        }

        // Add pulse effect CSS (inline style or add to <style>)
        const styleTag = document.querySelector('style');
        styleTag.innerHTML += `
            .angle-range.clicked-pulse {
                animation: pulse 0.5s ease-out;
            }
            @keyframes pulse {
                0% { transform: scale(1); border-color: #2f8d46; }
                50% { transform: scale(1.03); border-color: #2f8d46; }
                100% { transform: scale(1); border-color: #2f8d46; }
            }
        `;


        // --- Initialization ---
        function init() {
            // Set initial input values to trigger first calculation
            inputX1.value = 2;
            inputX2.value = 3;
            inputY1.value = -3;
            inputY2.value = 2;

            handleInputChange(); // Initial calculation and draw
            resizeCanvas(); // Set initial canvas size and draw

            // Add event listeners
            inputX1.addEventListener('input', handleInputChange);
            inputX2.addEventListener('input', handleInputChange);
            inputY1.addEventListener('input', handleInputChange);
            inputY2.addEventListener('input', handleInputChange);

            // Use a single listener for the calculation breakdown container
            const calcBreakdownContainer = document.getElementById('calculation-breakdown');
            calcBreakdownContainer.addEventListener('mouseover', handleCalculationHover);
            calcBreakdownContainer.addEventListener('mouseout', handleCalculationHover); // Use same handler to remove highlights

            angleRanges.forEach(range => {
                range.addEventListener('click', handleAngleRangeClick);
            });


            // Handle window resize
            window.addEventListener('resize', resizeCanvas);

             // Optional: Guided tooltip on first load (Minimalist version omits this)
             // Could add a simple alert or temporary message: alert("Welcome! Adjust vector values on the left to see how similarity changes.");
        }

        // Run initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
```