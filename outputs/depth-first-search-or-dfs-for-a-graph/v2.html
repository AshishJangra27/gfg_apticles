
<!DOCTYPE html>
<html>
<head>
    <title>Depth First Search (DFS) Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #ffffff;
            color: #222222;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Use full viewport height */
            overflow: hidden; /* Prevent scrolling */
        }

        header {
            background-color: #2f8d46; /* GeeksforGeeks Green */
            color: #ffffff;
            padding: 10px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        header h1 {
            margin: 0;
            font-size: 1.5em;
        }

        .graph-selector button {
            background-color: #ffffff;
            color: #2f8d46;
            border: 1px solid #ffffff;
            padding: 5px 10px;
            margin-left: 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .graph-selector button:hover:not(:disabled) {
            background-color: #f0f0f0;
        }

         .graph-selector button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }


        .main-content {
            flex: 1; /* Take remaining height */
            display: flex;
            padding: 10px;
            gap: 10px; /* Space between panels */
            overflow: hidden; /* Important to prevent canvas/panel overflow */
        }

        .graph-panel {
            flex: 2; /* ~66% */
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9; /* Slightly off-white for canvas area */
            position: relative; /* For positioning canvas */
            overflow: hidden; /* Ensure canvas respects border-radius */
        }

        .graph-panel canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
        }

        .controls-panel {
            flex: 1; /* ~33% */
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto; /* Allow scrolling if content exceeds panel height */
            flex-shrink: 0; /* Prevent controls panel from shrinking */
        }

        .controls button {
            display: block; /* Stack buttons */
            width: 100%;
            padding: 8px;
            margin-bottom: 5px; /* Space between buttons */
            background-color: #2f8d46;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
        }

        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .state-display h3, .output-display h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.1em;
            color: #2f8d46; /* Green titles */
        }
         .state-display p {
             margin-bottom: 5px;
             margin-top: 0;
             font-family: monospace;
         }

        .visited-nodes {
             margin-bottom: 10px;
        }
        .visited-nodes h4 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1em;
            color: #222222;
        }

        .visited-nodes-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .node-representation {
            width: 20px; /* Size of small node circle */
            height: 20px;
            border-radius: 50%;
            border: 2px solid #222222;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            font-weight: bold;
            box-sizing: border-box; /* Include border in size */
             background-color: #ffffff;
             color: #222222;
        }

        .node-representation.visited {
            background-color: #2f8d46; /* Green when visited */
            color: #ffffff;
            border-color: #2f8d46;
        }

        .call-stack h4 {
             margin-top: 0;
            margin-bottom: 5px;
            font-size: 1em;
             color: #222222;
        }
        .call-stack-container {
            border: 1px dashed #ccc;
            padding: 5px;
            min-height: 50px; /* Give it some visual space */
            display: flex;
            flex-direction: column-reverse; /* Stack grows upwards visually */
            gap: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .stack-item {
            background-color: #eee;
            padding: 2px 5px;
            border-radius: 3px;
            text-align: center;
        }

        .traversal-output ol {
            padding-left: 20px; /* Indent list */
            margin-top: 0;
        }

        .traversal-output li {
             margin-bottom: 3px;
             font-family: monospace;
        }

        footer {
            background-color: #f0f0f0; /* Light grey footer */
            padding: 10px;
            text-align: center;
            font-size: 0.9em;
            border-top: 1px solid #ddd;
            flex-shrink: 0; /* Prevent footer from shrinking */
        }

        footer a {
            color: #2f8d46;
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header>
        <h1>Depth First Search (DFS) Explorer</h1>
        <div class="graph-selector">
            <button id="select-connected">Connected Graph Example</button>
            <button id="select-disconnected">Disconnected Graph Example</button>
        </div>
    </header>

    <main class="main-content">
        <div class="graph-panel">
            <canvas id="graphCanvas"></canvas>
        </div>
        <div class="controls-panel">
            <div class="controls">
                <button id="start-dfs">Start DFS</button>
                <button id="step-forward" disabled>Step Forward</button>
                <button id="reset-simulation">Reset</button>
            </div>

            <div class="state-display">
                <h3>Current State</h3>
                <p>Current Node: <span id="current-node">-</span></p>
                <div class="visited-nodes">
                    <h4>Visited Nodes:</h4>
                    <div id="visited-nodes-container" class="visited-nodes-container">
                        <!-- Node representations will be added here by JS -->
                    </div>
                </div>
                 <div class="call-stack">
                    <h4>Call Stack (Simulated):</h4>
                     <div id="call-stack-container" class="call-stack-container">
                        <!-- Stack items added here by JS -->
                     </div>
                </div>
            </div>

            <div class="output-display">
                <h3>Traversal Output</h3>
                <ol id="traversal-output"></ol>
            </div>
        </div>
    </main>

    <footer>
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const graphPanel = document.querySelector('.graph-panel');

        const startButton = document.getElementById('start-dfs');
        const stepButton = document.getElementById('step-forward');
        const resetButton = document.getElementById('reset-simulation');
        const connectedButton = document.getElementById('select-connected');
        const disconnectedButton = document.getElementById('select-disconnected');

        const currentNodeSpan = document.getElementById('current-node');
        const visitedNodesContainer = document.getElementById('visited-nodes-container');
        const callStackContainer = document.getElementById('call-stack-container');
        const traversalOutputList = document.getElementById('traversal-output');

        // --- Graph Data ---
        const graphData = {
            connected: {
                nodes: [
                    { id: 0, x: 250, y: 50, label: '0' },
                    { id: 1, x: 150, y: 150, label: '1' },
                    { id: 2, x: 350, y: 150, label: '2' },
                    { id: 3, x: 150, y: 250, label: '3' },
                    { id: 4, x: 350, y: 250, label: '4' }
                ],
                adjacency: {
                    0: [1, 2],
                    1: [0, 3],
                    2: [0, 3, 4],
                    3: [1, 2, 4],
                    4: [2, 3]
                }
            },
            disconnected: {
                 nodes: [
                    { id: 0, x: 100, y: 100, label: '0' },
                    { id: 1, x: 50, y: 200, label: '1' },
                    { id: 2, x: 150, y: 200, label: '2' },
                    { id: 3, x: 400, y: 150, label: '3' },
                    { id: 4, x: 450, y: 250, label: '4' }
                ],
                adjacency: {
                    0: [1, 2],
                    1: [0, 2],
                    2: [0, 1],
                    3: [4],
                    4: [3]
                }
            }
        };

        // --- Algorithm State ---
        let currentGraph = null;
        let visited = new Set();
        let output = [];
        // Stack stores { nodeId: number, neighborIndex: number }
        // neighborIndex tracks the next adjacent node to explore from nodeId
        let stack = [];
        let nodesToVisit = []; // For complete traversal of disconnected graphs
        let currentNodeId = null;
        let currentEdge = null; // { from: number, to: number }
        let algorithmState = 'idle'; // 'idle', 'ready', 'running', 'finished'

        // --- Constants ---
        const NODE_RADIUS = 18;
        const NODE_COLOR_DEFAULT = '#ffffff';
        const NODE_BORDER_DEFAULT = '#222222';
        const NODE_COLOR_VISITED = '#2f8d46'; // GeeksforGeeks Green
        const NODE_BORDER_CURRENT = '#ff0000'; // Red border for current node
        const EDGE_COLOR_DEFAULT = '#222222';
        const EDGE_COLOR_HIGHLIGHT = '#2f8d46'; // GeeksforGeeks Green
        const TEXT_COLOR = '#222222';

        // --- Drawing Functions ---
        function drawNode(node, isCurrent, isVisited) {
            const x = node.x;
            const y = node.y;
            const radius = NODE_RADIUS;

            // Draw circle
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = isVisited ? NODE_COLOR_VISITED : NODE_COLOR_DEFAULT;
            ctx.fill();

            // Draw border
            ctx.lineWidth = isCurrent ? 3 : 2;
            ctx.strokeStyle = isCurrent ? NODE_BORDER_CURRENT : (isVisited ? NODE_COLOR_VISITED : NODE_BORDER_DEFAULT);
            ctx.stroke();

            // Draw label
            ctx.fillStyle = isVisited ? '#ffffff' : TEXT_COLOR;
            ctx.font = '12px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.label, x, y);
        }

        function drawEdge(node1, node2, isHighlighted) {
            ctx.beginPath();
            ctx.moveTo(node1.x, node1.y);
            ctx.lineTo(node2.x, node2.y);
            ctx.lineWidth = isHighlighted ? 3 : 2;
            ctx.strokeStyle = isHighlighted ? EDGE_COLOR_HIGHLIGHT : EDGE_COLOR_DEFAULT;
            // Ensure edges are drawn *behind* nodes
            ctx.globalCompositeOperation = 'destination-over';
            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over'; // Reset composite mode
        }

        function findNodeById(id) {
            return currentGraph.nodes.find(node => node.id === id);
        }

        function drawGraph() {
            if (!currentGraph) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges first
            for (const sourceId in currentGraph.adjacency) {
                const sourceNode = findNodeById(parseInt(sourceId));
                const neighbors = currentGraph.adjacency[sourceId];
                for (const targetId of neighbors) {
                    const targetNode = findNodeById(targetId);
                     // Avoid drawing the same edge twice in undirected graph visualization
                    if (sourceId < targetId) {
                         const isHighlighted = currentEdge &&
                                               ((currentEdge.from === parseInt(sourceId) && currentEdge.to === targetId) ||
                                                (currentEdge.from === targetId && currentEdge.to === parseInt(sourceId))); // Handle undirected vis
                        drawEdge(sourceNode, targetNode, isHighlighted);
                    }
                }
            }

            // Draw nodes second
            for (const node of currentGraph.nodes) {
                const isVisited = visited.has(node.id);
                const isCurrent = currentNodeId === node.id;
                drawNode(node, isCurrent, isVisited);
            }
        }

        // --- State Update Functions ---
        function updateVisitedNodesDisplay() {
            visitedNodesContainer.innerHTML = '';
            currentGraph.nodes.forEach(node => {
                const nodeRep = document.createElement('div');
                nodeRep.classList.add('node-representation');
                if (visited.has(node.id)) {
                    nodeRep.classList.add('visited');
                }
                nodeRep.textContent = node.label;
                visitedNodesContainer.appendChild(nodeRep);
            });
        }

        function updateCallStackDisplay() {
            callStackContainer.innerHTML = '';
            stack.forEach(item => {
                const stackItem = document.createElement('div');
                stackItem.classList.add('stack-item');
                stackItem.textContent = item.nodeId;
                callStackContainer.appendChild(stackItem);
            });
        }

        function updateTraversalOutputDisplay() {
            traversalOutputList.innerHTML = '';
            output.forEach(nodeId => {
                const listItem = document.createElement('li');
                listItem.textContent = nodeId;
                traversalOutputList.appendChild(listItem);
            });
             // Scroll to bottom
             traversalOutputList.scrollTop = traversalOutputList.scrollHeight;
        }

        function updateCurrentNodeDisplay() {
            currentNodeSpan.textContent = currentNodeId !== null ? currentNodeId : '-';
        }

        function updateDisplay() {
            updateCurrentNodeDisplay();
            updateVisitedNodesDisplay();
            updateCallStackDisplay();
            updateTraversalOutputDisplay();
            drawGraph(); // Redraw canvas based on state
        }

        // --- Algorithm Logic (Step-by-Step Iterative DFS) ---
         // State needed: currentGraph, visited, output, stack [{nodeId, neighborIndex}], nodesToVisit, currentNodeId, currentEdge, algorithmState

        function stepForward() {
            if (algorithmState !== 'running') return;

            currentEdge = null; // Clear edge highlight before new step

            if (stack.length === 0) {
                 // Attempt to start a new component traversal
                let nextStartNode = null;
                 // Find the first unvisited node from the original list of all nodes
                 while(nodesToVisit.length > 0) {
                     const potentialStart = nodesToVisit.shift(); // Get and remove the first from the list
                     if(!visited.has(potentialStart)) {
                         nextStartNode = potentialStart;
                         break;
                     }
                 }

                if (nextStartNode !== null) {
                    // Start DFS from a new unvisited node (new component)
                    visited.add(nextStartNode);
                    output.push(nextStartNode);
                    stack.push({ nodeId: nextStartNode, neighborIndex: 0 });
                    currentNodeId = nextStartNode;
                     // No edge highlighted for starting a new component
                } else {
                    // All nodes visited, DFS finished
                    algorithmState = 'finished';
                    currentNodeId = null; // Clear current node highlight
                    stepButton.disabled = true;
                    console.log("DFS Finished.");
                }
            } else {
                // Continue DFS from the top of the stack
                let stackTop = stack[stack.length - 1];
                let u = stackTop.nodeId;
                let adjListU = currentGraph.adjacency[u] || []; // Get neighbors of u

                let nextNeighborId = null;
                let neighborIdx = stackTop.neighborIndex;

                // Find the next unvisited neighbor of u
                while (neighborIdx < adjListU.length) {
                    const v = adjListU[neighborIdx];
                    stackTop.neighborIndex++; // Increment index for the current node's stack frame
                    if (!visited.has(v)) {
                        nextNeighborId = v;
                        currentEdge = { from: u, to: v }; // Highlight the edge being traversed
                        break; // Found the next node to visit
                    }
                    neighborIdx++;
                }

                if (nextNeighborId !== null) {
                    // Found an unvisited neighbor, traverse to it
                    visited.add(nextNeighborId);
                    output.push(nextNeighborId);
                    // Push the neighbor onto the stack to explore from there
                    stack.push({ nodeId: nextNeighborId, neighborIndex: 0 });
                    currentNodeId = nextNeighborId; // The neighbor is the new current node
                } else {
                    // No unvisited neighbors left for node u (at stack top), backtrack (pop)
                    stack.pop();
                    currentNodeId = stack.length > 0 ? stack[stack.length - 1].nodeId : null; // Current node is now the new stack top
                    // No edge highlighted during backtracking
                }
            }

            updateDisplay();

             if (algorithmState === 'finished') {
                 // Final redraw to ensure no lingering highlights
                 drawGraph();
             }
        }

        // --- Control Handlers ---
        function resetSimulation() {
            visited = new Set();
            output = [];
            stack = [];
            nodesToVisit = currentGraph ? Array.from({ length: currentGraph.nodes.length }, (_, i) => i) : [];
            currentNodeId = null;
            currentEdge = null;
            algorithmState = currentGraph ? 'ready' : 'idle';

            startButton.disabled = currentGraph === null || algorithmState !== 'ready';
            stepButton.disabled = true;
            resetButton.disabled = currentGraph === null;

            updateDisplay();
        }

        function startDFS() {
            if (algorithmState === 'ready') {
                algorithmState = 'running';
                startButton.disabled = true;
                stepButton.disabled = false;
                // Call stepForward once to start the initial push
                 stepForward();
            }
        }

        function loadGraph(graphName) {
            currentGraph = graphData[graphName];
            resetSimulation(); // Reset state and UI for the new graph

             // Set button states
             connectedButton.disabled = graphName === 'connected';
             disconnectedButton.disabled = graphName === 'disconnected';
        }

        // --- Canvas Resizing ---
        function resizeCanvas() {
            canvas.width = graphPanel.clientWidth;
            canvas.height = graphPanel.clientHeight;
            if (currentGraph) {
                 drawGraph(); // Redraw graph if one is loaded
            }
        }

        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);
        startButton.addEventListener('click', startDFS);
        stepButton.addEventListener('click', stepForward);
        resetButton.addEventListener('click', resetSimulation);
        connectedButton.addEventListener('click', () => loadGraph('connected'));
        disconnectedButton.addEventListener('click', () => loadGraph('disconnected'));

        // --- Initialization ---
        resizeCanvas(); // Set initial canvas size
        loadGraph('connected'); // Load the default graph on page load

    </script>
</body>
</html>
