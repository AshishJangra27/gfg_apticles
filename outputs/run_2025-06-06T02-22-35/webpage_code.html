```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree Explorer</title>
    <style>
        :root {
            --gfg-green: #2f8d46;
            --dark-text: #222222;
            --white-bg: #ffffff;
            --highlight-color: #ffda63; /* A visible highlight */
            --error-color: #e74c3c;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--white-bg);
            color: var(--dark-text);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Prevent scrolling */
        }

        header {
            text-align: center;
            padding: 10px;
            background-color: var(--gfg-green);
            color: var(--white-bg);
            font-size: 1.2em;
            font-weight: bold;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .container {
            display: flex;
            flex-grow: 1; /* Allow container to fill remaining height */
            overflow: hidden; /* Prevent scrolling within container */
        }

        .panel {
            padding: 15px;
            border-right: 1px solid #eee;
            overflow-y: auto; /* Allow scrolling within panels if content overflows */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .left-panel {
            width: 30%;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
        }

        .right-panel {
            width: 70%;
            background-color: var(--white-bg);
            display: flex;
            flex-direction: column;
        }

        .tree-builder, .tree-visualizer, .operation-section, .properties-display, .tree-types-explorer {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
            background-color: var(--white-bg); /* Inner sections white */
        }

        .left-panel .tree-visualizer {
            flex-grow: 1; /* Tree visualization fills remaining space */
            position: relative; /* Needed for absolute positioning of nodes/SVG */
            overflow: hidden; /* Hide overflow nodes */
        }

        .right-panel .tree-visualizer {
            height: 300px; /* Fixed height for right panel visualization */
            position: relative;
            overflow: hidden;
        }

        .panel h2 {
            margin-top: 0;
            color: var(--gfg-green);
            font-size: 1.1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .controls {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .controls input[type="number"],
        .controls select,
        .controls button {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .controls button {
            background-color: var(--gfg-green);
            color: var(--white-bg);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .controls button:hover {
            background-color: #287a3b;
        }

        .node {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: var(--gfg-green);
            color: var(--white-bg);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            user-select: none; /* Prevent text selection */
            z-index: 10; /* Ensure nodes are above SVG lines */
        }

        .node.selected {
            background-color: var(--highlight-color);
            color: var(--dark-text);
        }

        .node.highlight {
            background-color: var(--highlight-color);
            color: var(--dark-text);
            transform: scale(1.1);
        }

        .node.deleted {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .tree-visualizer svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5; /* Ensure SVG lines are behind nodes */
            pointer-events: none; /* Allow clicks to pass through SVG to nodes */
        }

        .tree-visualizer line {
            stroke: #ccc;
            stroke-width: 2;
        }

        .traversal-output {
            margin-top: 15px;
            padding: 10px;
            border: 1px dashed #ccc;
            min-height: 30px;
            font-family: monospace;
            background-color: #f0f0f0;
            font-size: 0.9em;
        }

        .properties-display p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        .properties-display p strong {
            color: var(--gfg-green);
        }

        .properties-display span {
            text-decoration: underline dashed;
            cursor: help;
        }

        .tooltip {
            position: absolute;
            background-color: var(--dark-text);
            color: var(--white-bg);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 100;
            pointer-events: none; /* Don't block mouse events */
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .properties-display span:hover + .tooltip {
            opacity: 1;
        }

        .tree-types-explorer .type-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tree-types-explorer .type-buttons button {
             flex-grow: 1; /* Allow buttons to grow */
             min-width: 100px; /* Minimum width for wrapping */
        }

        .tree-type-example {
            border: 1px dashed #ccc;
            padding: 10px;
            min-height: 150px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            color: #666;
        }

         /* Basic Example Structure (can be expanded) */
        .example-tree .node {
            position: static; /* Override absolute positioning for examples */
            margin: 5px;
            box-shadow: none;
        }

        .example-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .example-level {
            display: flex;
            justify-content: center;
        }


        footer {
            padding: 10px;
            text-align: center;
            background-color: var(--gfg-green);
            color: var(--white-bg);
            font-size: 0.9em;
            flex-shrink: 0;
        }

        footer a {
            color: var(--white-bg);
            text-decoration: none;
            margin: 0 10px;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Error/Info Messages */
        .message {
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .message.error {
            background-color: #fdd;
            border: 1px solid var(--error-color);
            color: var(--error-color);
        }

         .message.info {
            background-color: #eef;
            border: 1px solid #3498db;
            color: #3498db;
        }

    </style>
</head>
<body>

    <header>
        Binary Tree Explorer
    </header>

    <div class="container">
        <div class="panel left-panel">
            <h2>Tree Builder</h2>
            <div class="tree-builder controls">
                <input type="number" id="addNodeValue" placeholder="Node Value" min="0">
                <button id="addNodeBtn">Add Node</button>
                <!-- Deletion is handled by clicking node + button in Right Panel -->
            </div>
             <div class="message info" id="builderMessage">Click on a node in the Right Panel to select it for Deletion.</div>
            <div class="tree-visualizer" id="leftTreeViz">
                <!-- Tree visualization goes here -->
                <svg id="leftTreeSvg"></svg>
            </div>
        </div>

        <div class="panel right-panel">
             <h2>Operations & Properties</h2>

            <div class="operation-section">
                <h3>Traversal</h3>
                <div class="controls">
                    <select id="traversalType">
                        <option value="preorder">Preorder</option>
                        <option value="inorder">Inorder</option>
                        <option value="postorder">Postorder</option>
                        <option value="levelorder">Level Order</option>
                    </select>
                    <button id="startTraversalBtn">Start Traversal</button>
                </div>
                <div class="traversal-output" id="traversalOutput"></div>
            </div>

            <div class="operation-section">
                <h3>Insertion</h3>
                <div class="controls">
                    <input type="number" id="insertNodeValue" placeholder="Node Value" min="0">
                    <button id="insertNodeBtn">Insert Node</button>
                </div>
            </div>

             <div class="operation-section">
                <h3>Deletion</h3>
                 <div class="message info" id="deletionMessage">Select a node to delete by clicking it in the tree visualization below.</div>
                <div class="controls">
                    <button id="deleteNodeBtn" disabled>Delete Selected Node</button>
                </div>
            </div>

             <div class="tree-visualizer" id="rightTreeViz">
                <!-- Mirror visualization for operations -->
                 <svg id="rightTreeSvg"></svg>
            </div>


            <div class="properties-display">
                <h3>Properties</h3>
                <p>Height: <strong id="propHeight">0</strong> <span title="Height is the number of edges on the longest downward path between the root and a leaf node.">?</span> <div class="tooltip">Height is the number of edges on the longest downward path from root to leaf.</div></p>
                <p>Number of Nodes: <strong id="propNodeCount">0</strong> <span title="Total number of nodes in the tree.">?</span> <div class="tooltip">Total number of nodes in the tree.</div></p>
                <p>Number of Leaf Nodes: <strong id="propLeafCount">0</strong> <span title="Number of nodes with no children.">?</span> <div class="tooltip">Number of nodes with no children.</div></p>
            </div>

            <div class="tree-types-explorer">
                <h3>Tree Types</h3>
                <div class="type-buttons">
                    <button data-type="full">Full</button>
                    <button data-type="complete">Complete</button>
                    <button data-type="perfect">Perfect</button>
                    <button data-type="balanced">Balanced</button>
                    <button data-type="degenerate">Degenerate</button>
                    <button data-type="skewed">Skewed</button>
                </div>
                <div class="tree-type-example" id="treeTypeExample">
                    Select a tree type to see an example.
                </div>
            </div>

        </div>
    </div>

    <footer>
        Built by Ashish Jangra |
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a> |
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        // --- Data Structure: Node and Binary Tree ---

        class Node {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                // Internal properties for visualization mapping
                this._vizId = null;
                this._selected = false;
            }
        }

        class BinaryTree {
            constructor() {
                this.root = null;
                this._nodeCount = 0;
                this._nextVizId = 1; // Simple unique ID for nodes
            }

            addNode(value) {
                const newNode = new Node(value);
                newNode._vizId = this._nextVizId++;
                this._nodeCount++;

                if (!this.root) {
                    this.root = newNode;
                    return newNode;
                }

                // Level order insertion
                const queue = [this.root];
                while (queue.length > 0) {
                    const current = queue.shift();

                    if (!current.left) {
                        current.left = newNode;
                        return newNode;
                    } else {
                        queue.push(current.left);
                    }

                    if (!current.right) {
                        current.right = newNode;
                        return newNode;
                    } else {
                        queue.push(current.right);
                    }
                }
            }

             // Finds a node by value (returns first match in level order)
            findNodeByValue(value) {
                 if (!this.root) return null;
                 const queue = [this.root];
                 while(queue.length > 0) {
                     const node = queue.shift();
                     if (node.value === value) return node;
                     if(node.left) queue.push(node.left);
                     if(node.right) queue.push(node.right);
                 }
                 return null;
            }

             // Finds a node by its visualization ID
             findNodeByVizId(vizId) {
                if (!this.root) return null;
                 const queue = [this.root];
                 while(queue.length > 0) {
                     const node = queue.shift();
                     if (node._vizId === vizId) return node;
                     if(node.left) queue.push(node.left);
                     if(node.right) queue.push(node.right);
                 }
                 return null;
             }

            // Find the deepest rightmost node (last node in level order traversal)
            findDeepestRightmost() {
                if (!this.root) return null;
                let deepestNode = null;
                const queue = [this.root];
                while (queue.length > 0) {
                    deepestNode = queue.shift(); // Keep updating deepestNode
                    if (deepestNode.left) queue.push(deepestNode.left);
                    if (deepestNode.right) queue.push(deepestNode.right);
                }
                return deepestNode;
            }

             // Helper to remove a specific node (used for deepest rightmost)
             removeNodeReference(nodeToRemove) {
                if (!this.root || !nodeToRemove) return false;

                // Edge case: Removing the root
                if (this.root === nodeToRemove) {
                    this.root = null;
                    this._nodeCount = 0;
                    return true;
                }

                 const queue = [this.root];
                 while(queue.length > 0) {
                     const current = queue.shift();

                     if (current.left === nodeToRemove) {
                         current.left = null;
                         this._nodeCount--;
                         return true;
                     }
                     if (current.right === nodeToRemove) {
                         current.right = null;
                          this._nodeCount--;
                         return true;
                     }

                     if(current.left) queue.push(current.left);
                     if(current.right) queue.push(current.right);
                 }
                 return false; // Node not found (shouldn't happen if called correctly)
             }


            // Simplified deletion: Replace target with deepest rightmost, then remove deepest rightmost
            // Returns the target node value if deleted, null otherwise
            deleteNode(targetNodeValue) {
                if (!this.root) return null;

                let nodeToDelete = null;
                let nodeToDeleteParent = null;

                // Find the node to delete using level order traversal
                const findQueue = [{node: this.root, parent: null}];
                 while(findQueue.length > 0) {
                     const {node, parent} = findQueue.shift();
                     if (node.value === targetNodeValue) {
                         nodeToDelete = node;
                         nodeToDeleteParent = parent;
                         break; // Found the first instance
                     }
                     if(node.left) findQueue.push({node: node.left, parent: node});
                     if(node.right) findQueue.push({node: node.right, parent: node});
                 }

                if (!nodeToDelete) return null; // Node not found

                // Find the deepest rightmost node
                const deepestNode = this.findDeepestRightmost();

                // If the deepest node is the node to delete (i.e., it's the only node)
                if (nodeToDelete === deepestNode) {
                     this.root = null;
                     this._nodeCount = 0;
                     return targetNodeValue;
                }

                // Store value of deepest node
                const deepestValue = deepestNode.value;
                const deletedValue = nodeToDelete.value; // Value we are logically deleting

                // Remove the deepest rightmost node's reference from its parent
                this.removeNodeReference(deepestNode);

                // Replace the value of the node to delete with the deepest rightmost node's value
                // Note: We are only changing the *value* here, not the node object itself
                nodeToDelete.value = deepestValue;
                 this._nodeCount--; // Node count was decremented in removeNodeReference

                return deletedValue; // Return the value that was logically deleted
            }


            // --- Traversals ---

            preorder(node = this.root, result = []) {
                if (node) {
                    result.push(node);
                    this.preorder(node.left, result);
                    this.preorder(node.right, result);
                }
                return result;
            }

            inorder(node = this.root, result = []) {
                if (node) {
                    this.inorder(node.left, result);
                    result.push(node);
                    this.inorder(node.right, result);
                }
                return result;
            }

            postorder(node = this.root, result = []) {
                if (node) {
                    this.postorder(node.left, result);
                    this.postorder(node.right, result);
                    result.push(node);
                }
                return result;
            }

            levelorder() {
                const result = [];
                if (!this.root) return result;
                const queue = [this.root];
                while (queue.length > 0) {
                    const node = queue.shift();
                    result.push(node);
                    if (node.left) queue.push(node.left);
                    if (node.right) queue.push(node.right);
                }
                return result;
            }

            // --- Properties ---

            getHeight(node = this.root) {
                if (!node) {
                    return -1; // Height of an empty tree is -1, single node tree is 0
                }
                const leftHeight = this.getHeight(node.left);
                const rightHeight = this.getHeight(node.right);
                return Math.max(leftHeight, rightHeight) + 1;
            }

            getNodeCount() {
                return this._nodeCount;
            }

            getLeafCount(node = this.root) {
                if (!node) {
                    return 0;
                }
                if (!node.left && !node.right) {
                    return 1; // It's a leaf
                }
                return this.getLeafCount(node.left) + this.getLeafCount(node.right);
            }

             // Create a deep copy of the tree
             clone() {
                 const newTree = new BinaryTree();
                 if (!this.root) return newTree;

                 const queue = [{original: this.root, cloneParent: null, side: null}]; // side: 'left' or 'right'
                 newTree.root = new Node(this.root.value);
                 newTree.root._vizId = this.root._vizId; // Keep original vizId for mapping

                 const cloneQueue = [newTree.root];
                 const originalQueue = [this.root];

                 while(originalQueue.length > 0) {
                     const original = originalQueue.shift();
                     const clone = cloneQueue.shift();

                     if (original.left) {
                         const newNode = new Node(original.left.value);
                         newNode._vizId = original.left._vizId; // Keep original vizId
                         clone.left = newNode;
                         originalQueue.push(original.left);
                         cloneQueue.push(clone.left);
                     }
                      if (original.right) {
                         const newNode = new Node(original.right.value);
                         newNode._vizId = original.right._vizId; // Keep original vizId
                         clone.right = newNode;
                         originalQueue.push(original.right);
                         cloneQueue.push(clone.right);
                     }
                 }
                newTree._nodeCount = this._nodeCount;
                newTree._nextVizId = this._nextVizId; // Keep sync'd vizId counter
                 return newTree;
             }
        }

        // --- Visualization Logic ---

        const leftTree = new BinaryTree();
        let rightTree = new BinaryTree(); // Right panel will be a clone
        const leftTreeVizDiv = document.getElementById('leftTreeViz');
        const rightTreeVizDiv = document.getElementById('rightTreeViz');
        const leftTreeSvg = document.getElementById('leftTreeSvg');
        const rightTreeSvg = document.getElementById('rightTreeSvg');

        const nodeRadius = 15;
        const horizontalNodeSpacing = 40; // Minimum spacing between nodes at the same level
        const verticalLevelSpacing = 60; // Spacing between levels

        // Function to calculate node positions
        function calculateNodePositions(tree) {
            const positions = new Map(); // Map Node object to {x, y}
            if (!tree.root) return positions;

            const levels = [];
            const queue = [{node: tree.root, level: 0, parentIndex: -1}]; // parentIndex isn't strictly needed for this layout but helps structure
            let maxLevel = 0;

            // First pass: Determine levels and structure
            while(queue.length > 0) {
                const {node, level} = queue.shift();
                if (!levels[level]) levels[level] = [];
                levels[level].push(node);
                maxLevel = Math.max(maxLevel, level);

                if(node.left) queue.push({node: node.left, level: level + 1});
                if(node.right) queue.push({node: node.right, level: level + 1});
            }

            const vizWidth = (tree === leftTree ? leftTreeVizDiv : rightTreeVizDiv).clientWidth;
            const vizHeight = (tree === leftTree ? leftTreeVizDiv : rightTreeVizDiv).clientHeight;

            // Second pass: Calculate positions based on level and index within level
            for (let level = 0; level < levels.length; level++) {
                const nodesAtLevel = levels[level];
                const numNodes = nodesAtLevel.length;

                // Calculate total width needed for this level
                // Simple centering: divide width equally
                const levelWidth = (numNodes - 1) * horizontalNodeSpacing + numNodes * (nodeRadius * 2);
                 const startX = (vizWidth / 2) - (levelWidth / 2);


                for (let i = 0; i < numNodes; i++) {
                    const node = nodesAtLevel[i];
                     const x = startX + i * (horizontalNodeSpacing + nodeRadius * 2) + nodeRadius;
                    const y = level * verticalLevelSpacing + nodeRadius; // Add nodeRadius to start position

                    positions.set(node, { x, y });
                }
            }

            return positions;
        }

        // Function to render the tree visualization (nodes and lines)
        function renderTree(tree, vizDiv, svgElement) {
            vizDiv.querySelectorAll('.node').forEach(nodeDiv => nodeDiv.remove());
            svgElement.innerHTML = ''; // Clear previous lines

            const positions = calculateNodePositions(tree);

            if (!tree.root) {
                 // Ensure SVGs are cleared and nodes are gone
                 svgElement.innerHTML = '';
                 vizDiv.querySelectorAll('.node').forEach(nodeDiv => nodeDiv.remove());
                return;
            }

            const nodesToRender = tree.levelorder(); // Get nodes in a stable order

            // Render nodes
            nodesToRender.forEach(node => {
                const pos = positions.get(node);
                if (!pos) return; // Should not happen if in positions map

                const nodeDiv = document.createElement('div');
                nodeDiv.classList.add('node');
                nodeDiv.id = `node-${node._vizId}`; // Use vizId for DOM ID
                nodeDiv.style.left = `${pos.x - nodeRadius}px`; // Center the div
                nodeDiv.style.top = `${pos.y - nodeRadius}px`;   // Center the div
                nodeDiv.style.width = `${nodeRadius * 2}px`;
                nodeDiv.style.height = `${nodeRadius * 2}px`;
                nodeDiv.textContent = node.value;
                 if (node._selected) nodeDiv.classList.add('selected');

                // Add click listener for selection/deletion
                nodeDiv.addEventListener('click', (event) => {
                    handleNodeClick(node._vizId, tree === rightTree); // Pass vizId and isRightPanel flag
                    event.stopPropagation(); // Prevent clicks on container
                });

                vizDiv.appendChild(nodeDiv);
            });

            // Render lines (SVG)
             nodesToRender.forEach(node => {
                 const pos = positions.get(node);
                 if (!pos) return;

                 // Draw line to left child
                 if (node.left) {
                     const childPos = positions.get(node.left);
                     if(childPos) {
                         const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                         line.setAttribute('x1', pos.x);
                         line.setAttribute('y1', pos.y + nodeRadius); // Start from bottom edge of parent
                         line.setAttribute('x2', childPos.x);
                         line.setAttribute('y2', childPos.y - nodeRadius); // End at top edge of child
                         svgElement.appendChild(line);
                     }
                 }

                 // Draw line to right child
                 if (node.right) {
                     const childPos = positions.get(node.right);
                      if(childPos) {
                         const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                         line.setAttribute('x1', pos.x);
                         line.setAttribute('y1', pos.y + nodeRadius); // Start from bottom edge of parent
                         line.setAttribute('x2', childPos.x);
                         line.setAttribute('y2', childPos.y - nodeRadius); // End at top edge of child
                         svgElement.appendChild(line);
                      }
                 }
             });

             // Update properties display if rendering the left tree (main tree)
             if (tree === leftTree) {
                 updatePropertiesDisplay();
             }

        }

         // Handle node click for selection (in Right Panel)
         let selectedNodeVizId = null;
         const deleteNodeBtn = document.getElementById('deleteNodeBtn');

         function handleNodeClick(vizId, isRightPanel) {
             // We only select nodes in the Right Panel for operations (Insert, Delete)
             // Clicks in the Left Panel add nodes (handled by button)

             if (!isRightPanel) {
                 // Left panel click doesn't select for deletion action
                 // but maybe for future features? For now, ignore or add small feedback
                 const nodeDiv = document.getElementById(`node-${vizId}`);
                 if(nodeDiv) {
                      nodeDiv.style.backgroundColor = 'lightblue'; // Temporary feedback
                     setTimeout(() => {
                         nodeDiv.style.backgroundColor = ''; // Reset after brief delay
                          // Reset to original green if not selected
                          if (!rightTree.findNodeByVizId(vizId)?._selected) {
                               nodeDiv.style.backgroundColor = var(--gfg-green);
                          } else {
                               nodeDiv.style.backgroundColor = var(--highlight-color);
                          }
                      }, 200);
                 }
                 showMessage('builderMessage', 'Build the tree using the input/button. Click in the right panel to select for operations.', 'info');
                  return;
             }


            // Deselect previously selected node in the right panel
            if (selectedNodeVizId !== null) {
                const prevNodeDiv = document.getElementById(`node-${selectedNodeVizId}`);
                if (prevNodeDiv) {
                    prevNodeDiv.classList.remove('selected');
                     const prevNode = rightTree.findNodeByVizId(selectedNodeVizId);
                     if(prevNode) prevNode._selected = false; // Update data model
                }
            }

            // Select the new node in the right panel
            const newNodeDiv = document.getElementById(`node-${vizId}`);
            if (newNodeDiv) {
                 const newNode = rightTree.findNodeByVizId(vizId);
                if (newNode) {
                    selectedNodeVizId = vizId;
                    newNodeDiv.classList.add('selected');
                    newNode._selected = true; // Update data model
                    deleteNodeBtn.disabled = false;
                    showMessage('deletionMessage', `Node ${newNode.value} selected for deletion.`, 'info');
                } else {
                     // Node not found in rightTree - this is an error state
                     selectedNodeVizId = null;
                     deleteNodeBtn.disabled = true;
                     showMessage('deletionMessage', 'Error: Selected node not found in the operation tree.', 'error');
                }
            } else {
                 // Node div not found - this is an error state
                selectedNodeVizId = null;
                 deleteNodeBtn.disabled = true;
                showMessage('deletionMessage', 'Error: Node visualization element not found.', 'error');
            }
             if (selectedNodeVizId === null) {
                 deleteNodeBtn.disabled = true;
                 showMessage('deletionMessage', 'Select a node to delete by clicking it in the tree visualization below.', 'info');
             }
        }


        // Helper to render both trees
        function renderAllTrees() {
             renderTree(leftTree, leftTreeVizDiv, leftTreeSvg);
             // Clone the left tree for right panel operations
             rightTree = leftTree.clone();
             renderTree(rightTree, rightTreeVizDiv, rightTreeSvg);
        }

        // Helper to update properties display
        function updatePropertiesDisplay() {
            document.getElementById('propHeight').textContent = leftTree.getHeight();
            document.getElementById('propNodeCount').textContent = leftTree.getNodeCount();
            document.getElementById('propLeafCount').textContent = leftTree.getLeafCount();
        }

        // Helper to show messages
        function showMessage(elementId, message, type) {
            const msgElement = document.getElementById(elementId);
             msgElement.textContent = message;
            msgElement.className = `message ${type}`; // Reset classes
            if (message) {
                 msgElement.style.display = 'block';
             } else {
                 msgElement.style.display = 'none';
             }
        }


        // --- Event Listeners ---

        // Add Node
        document.getElementById('addNodeBtn').addEventListener('click', () => {
            const valueInput = document.getElementById('addNodeValue');
            const value = parseInt(valueInput.value);

            if (isNaN(value)) {
                 showMessage('builderMessage', 'Please enter a valid number.', 'error');
                return;
            }
            if (leftTree.getNodeCount() >= 30) { // Simple limit to prevent overflow
                 showMessage('builderMessage', 'Max 30 nodes for visualization limits.', 'error');
                 return;
            }

            leftTree.addNode(value);
            renderAllTrees();
            valueInput.value = ''; // Clear input
             showMessage('builderMessage', 'Node added. Click in the right panel to select for operations.', 'info');
        });

        // Start Traversal
        document.getElementById('startTraversalBtn').addEventListener('click', async () => {
            const type = document.getElementById('traversalType').value;
            const outputDiv = document.getElementById('traversalOutput');
            outputDiv.textContent = 'Starting...';

            let nodesToVisit = [];
            switch (type) {
                case 'preorder':
                    nodesToVisit = rightTree.preorder();
                    break;
                case 'inorder':
                    nodesToVisit = rightTree.inorder();
                    break;
                case 'postorder':
                    nodesToVisit = rightTree.postorder();
                    break;
                case 'levelorder':
                    nodesToVisit = rightTree.levelorder();
                    break;
            }

            if (nodesToVisit.length === 0) {
                outputDiv.textContent = 'Tree is empty.';
                return;
            }

            outputDiv.textContent = ''; // Clear for animation
            const visitedValues = [];

            for (let i = 0; i < nodesToVisit.length; i++) {
                const node = nodesToVisit[i];
                const nodeElement = document.getElementById(`node-${node._vizId}`);
                if (nodeElement) {
                    nodeElement.classList.add('highlight');
                }

                visitedValues.push(node.value);
                outputDiv.textContent = visitedValues.join(' -> ');

                await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms

                if (nodeElement) {
                    nodeElement.classList.remove('highlight');
                }
            }
             showMessage('builderMessage', 'Traversal complete.', 'info'); // Simple message for feedback
        });

        // Insert Node (in Right Panel)
        document.getElementById('insertNodeBtn').addEventListener('click', async () => {
            const valueInput = document.getElementById('insertNodeValue');
            const value = parseInt(valueInput.value);

            if (isNaN(value)) {
                showMessage('builderMessage', 'Please enter a valid number for insertion.', 'error');
                return;
            }

             if (rightTree.getNodeCount() >= 30) { // Match limit
                 showMessage('builderMessage', 'Max 30 nodes reached.', 'error');
                 return;
            }

            // Simulate insertion animation
            const newNode = new Node(value);
            newNode._vizId = rightTree._nextVizId; // Use the next expected vizId

             showMessage('builderMessage', `Animating insertion of ${value}...`, 'info');
             await simulateInsertion(rightTree, newNode, rightTreeVizDiv, rightTreeSvg);

            rightTree.addNode(value); // Actually add the node to the data structure
             renderAllTrees(); // Re-render both trees to sync and show inserted node

            valueInput.value = ''; // Clear input
            showMessage('builderMessage', `Node ${value} inserted.`, 'info');
        });

         async function simulateInsertion(tree, newNodeToInsert, vizDiv, svgElement) {
             if (!tree.root) {
                 // Simple case: tree is empty, new node becomes root
                 const vizWidth = vizDiv.clientWidth;
                 const vizHeight = vizDiv.clientHeight;
                 const nodeX = vizWidth / 2;
                 const nodeY = nodeRadius;

                 const newNodeDiv = document.createElement('div');
                 newNodeDiv.classList.add('node');
                 newNodeDiv.textContent = newNodeToInsert.value;
                 newNodeDiv.style.left = `${nodeX - nodeRadius}px`;
                 newNodeDiv.style.top = `${nodeY - nodeRadius}px`;
                 newNodeDiv.style.width = `${nodeRadius * 2}px`;
                 newNodeDiv.style.height = `${nodeRadius * 2}px`;
                 newNodeDiv.style.transition = 'none'; // No transition on initial placement off-screen

                 // Start slightly above or off-screen and fade in
                 newNodeDiv.style.top = `${nodeY - nodeRadius - 30}px`; // Start higher
                 newNodeDiv.style.opacity = '0';
                 vizDiv.appendChild(newNodeDiv);

                 // Force reflow to ensure starting styles are applied
                 newNodeDiv.getBoundingClientRect();

                 // Animate to final position and fade in
                 newNodeDiv.style.transition = 'top 0.5s ease, opacity 0.5s ease';
                 newNodeDiv.style.top = `${nodeY - nodeRadius}px`;
                 newNodeDiv.style.opacity = '1';

                 await new Promise(resolve => setTimeout(resolve, 600)); // Wait for animation

                 return;
             }


            const queue = [tree.root];
            let parentNode = null;
            let isLeftChild = true; // Assume left child first

            // Find insertion point (first available spot - level order)
            while(queue.length > 0) {
                const current = queue.shift();
                parentNode = current;

                if (!current.left) {
                    isLeftChild = true;
                    break;
                } else {
                    queue.push(current.left);
                }

                if (!current.right) {
                    isLeftChild = false;
                    break;
                } else {
                    queue.push(current.right);
                }
            }

            if (!parentNode) return; // Should not happen for non-empty tree

            // Temporarily update tree structure to calculate position
            if (isLeftChild) {
                 parentNode.left = newNodeToInsert;
            } else {
                 parentNode.right = newNodeToInsert;
            }

            const tempPositions = calculateNodePositions(tree);
            const targetPos = tempPositions.get(newNodeToInsert);

             // Restore tree structure immediately after calculation
             if (isLeftChild) {
                 parentNode.left = null;
             } else {
                 parentNode.right = null;
             }


            if (!targetPos) {
                 showMessage('builderMessage', 'Could not calculate insertion position.', 'error');
                return;
            }

            // Create and position the new node element off-screen or near parent initially
            const newNodeDiv = document.createElement('div');
            newNodeDiv.classList.add('node');
            newNodeDiv.textContent = newNodeToInsert.value;
            newNodeDiv.style.width = `${nodeRadius * 2}px`;
            newNodeDiv.style.height = `${nodeRadius * 2}px`;

            // Start position - near parent or slightly off-screen
            const parentPos = tempPositions.get(parentNode);
             newNodeDiv.style.left = `${parentPos.x - nodeRadius}px`;
             newNodeDiv.style.top = `${parentPos.y - nodeRadius}px`;
             newNodeDiv.style.opacity = '0'; // Start invisible
            newNodeDiv.style.transition = 'none'; // No initial transition

            vizDiv.appendChild(newNodeDiv);

             // Force reflow
            newNodeDiv.getBoundingClientRect();

            // Animate to target position
            newNodeDiv.style.transition = 'left 0.8s ease-out, top 0.8s ease-out, opacity 0.5s ease';
            newNodeDiv.style.left = `${targetPos.x - nodeRadius}px`;
            newNodeDiv.style.top = `${targetPos.y - nodeRadius}px`;
            newNodeDiv.style.opacity = '1'; // Fade in

            await new Promise(resolve => setTimeout(resolve, 900)); // Wait for animation
         }


        // Delete Node (in Right Panel)
        document.getElementById('deleteNodeBtn').addEventListener('click', async () => {
            if (selectedNodeVizId === null) {
                showMessage('deletionMessage', 'Please select a node to delete first.', 'error');
                return;
            }

            const nodeToDelete = rightTree.findNodeByVizId(selectedNodeVizId);
            if (!nodeToDelete) {
                 showMessage('deletionMessage', 'Selected node not found!', 'error');
                 return;
            }

             const targetValue = nodeToDelete.value; // Value to logically delete

             // Find the deepest rightmost node *before* deletion calculation
             const deepestNodeBeforeDeletion = rightTree.findDeepestRightmost();

             if (!deepestNodeBeforeDeletion) { // Should only happen if tree is empty or has only the root (handled below)
                  showMessage('deletionMessage', 'Tree is empty, cannot delete.', 'error');
                 return;
             }


             showMessage('deletionMessage', `Animating deletion of node with value ${targetValue}...`, 'info');

             // Simulate deletion animation
             await simulateDeletion(rightTree, nodeToDelete, deepestNodeBeforeDeletion, rightTreeVizDiv);


            // Perform the actual deletion in the data structure
             const deletedValue = rightTree.deleteNode(targetValue); // This modifies rightTree

            if (deletedValue !== null) {
                 // Update left tree as well to keep them synced after operation
                 leftTree.deleteNode(deletedValue); // Note: This finds *its own* node with the same value
                 renderAllTrees(); // Re-render both trees
                 showMessage('deletionMessage', `Node with value ${deletedValue} deleted.`, 'info');
             } else {
                 showMessage('deletionMessage', `Could not delete node with value ${targetValue}.`, 'error');
             }

            // Reset selection
            selectedNodeVizId = null;
            deleteNodeBtn.disabled = true;
             showMessage('deletionMessage', 'Select a node to delete by clicking it in the tree visualization below.', 'info'); // Restore default message
        });

         async function simulateDeletion(tree, nodeToDelete, deepestNode, vizDiv) {
            // Highlight the node to delete
            const nodeToDeleteDiv = document.getElementById(`node-${nodeToDelete._vizId}`);
             if (nodeToDeleteDiv) {
                 nodeToDeleteDiv.classList.add('highlight');
             }

             // If the node to delete IS the deepest node (only node in tree)
             if (nodeToDelete === deepestNode) {
                 await new Promise(resolve => setTimeout(resolve, 800)); // Pause
                  if (nodeToDeleteDiv) {
                      nodeToDeleteDiv.classList.add('deleted'); // Animate removal
                  }
                  await new Promise(resolve => setTimeout(resolve, 600)); // Wait for fade out
                  return; // Animation finished
             }

            // Highlight the deepest rightmost node (replacement)
            const deepestNodeDiv = document.getElementById(`node-${deepestNode._vizId}`);
            if (deepestNodeDiv) {
                 deepestNodeDiv.classList.add('highlight');
             }

            await new Promise(resolve => setTimeout(resolve, 800)); // Pause for highlighting

             // Animate value swap (visually)
             if (nodeToDeleteDiv && deepestNodeDiv) {
                  // Swap text content
                  const tempText = nodeToDeleteDiv.textContent;
                 nodeToDeleteDiv.textContent = deepestNodeDiv.textContent;
                 deepestNodeDiv.textContent = tempText; // Optional: animate text swap effect

                 // Add a temporary visual pulse or color change on swap
                 nodeToDeleteDiv.style.backgroundColor = 'orange';
                 deepestNodeDiv.style.backgroundColor = 'orange';
                 await new Promise(resolve => setTimeout(resolve, 500));
                  nodeToDeleteDiv.style.backgroundColor = ''; // Reset CSS class will handle color
                  deepestNodeDiv.style.backgroundColor = '';
                  nodeToDeleteDiv.classList.remove('highlight'); // Remove highlight after swap visual
             }

            // Animate the removal of the deepest rightmost node
             if (deepestNodeDiv) {
                  deepestNodeDiv.classList.remove('highlight'); // Remove highlight
                 deepestNodeDiv.classList.add('deleted'); // Trigger opacity transition
            }

            await new Promise(resolve => setTimeout(resolve, 600)); // Wait for the node to fade out

             // Clean up deleted node div after animation (optional, renderAllTrees will handle)
             if (deepestNodeDiv) {
                 deepestNodeDiv.remove();
             }
        }


        // Tree Types Explorer
        const treeTypeExampleDiv = document.getElementById('treeTypeExample');
        document.querySelectorAll('.tree-types-explorer button').forEach(button => {
            button.addEventListener('click', () => {
                const type = button.getAttribute('data-type');
                displayTreeTypeExample(type);
            });
        });

        function displayTreeTypeExample(type) {
             treeTypeExampleDiv.innerHTML = ''; // Clear previous example

            let exampleHtml = '';
            let description = '';

            // Simple static examples
            switch (type) {
                case 'full':
                    description = 'A binary tree is a Full Binary Tree if every node has 0 or 2 children.';
                    exampleHtml = `
                        <div class="example-tree">
                            <div class="example-level"><div class="node">1</div></div>
                            <div class="example-level"><div class="node">2</div><div class="node">3</div></div>
                             <div class="example-level"><div class="node">4</div><div class="node">5</div><div class="node">6</div><div class="node">7</div></div>
                        </div>
                    `;
                    break;
                case 'complete':
                    description = 'A binary tree is a Complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possible.';
                     exampleHtml = `
                        <div class="example-tree">
                            <div class="example-level"><div class="node">1</div></div>
                            <div class="example-level"><div class="node">2</div><div class="node">3</div></div>
                             <div class="example-level"><div class="node">4</div><div class="node">5</div><div class="node">6</div></div>
                        </div>
                    `; // Level 2 not full, but nodes are left-aligned
                    break;
                case 'perfect':
                    description = 'A binary tree is a Perfect Binary Tree if all internal nodes have two children and all leaves are at the same level.';
                    exampleHtml = `
                        <div class="example-tree">
                            <div class="example-level"><div class="node">1</div></div>
                            <div class="example-level"><div class="node">2</div><div class="node">3</div></div>
                             <div class="example-level"><div class="node">4</div><div class="node">5</div><div class="node">6</div><div class="node">7</div></div>
                        </div>
                    `; // Same as full, but implicitly balanced and leaves same level
                    break;
                case 'balanced':
                    description = 'A binary tree is Balanced if the height difference between the left and right subtrees of every node is not more than 1.';
                    exampleHtml = `
                        <div class="example-tree">
                            <div class="example-level"><div class="node">1</div></div>
                            <div class="example-level"><div class="node">2</div><div class="node">3</div></div>
                             <div class="example-level"><div class="node">4</div><div class="node">5</div></div>
                        </div>
                    `; // Example of AVL-like balance
                    break;
                case 'degenerate':
                    description = 'A Degenerate (or Skewed) Tree is a tree where each parent node has only one child.';
                    exampleHtml = `
                        <div class="example-tree" style="align-items: flex-start;">
                            <div class="example-level"><div class="node" style="margin-left: 0;">1</div></div>
                            <div class="example-level"><div class="node" style="margin-left: 20px;">2</div></div>
                             <div class="example-level"><div class="node" style="margin-left: 40px;">3</div></div>
                              <div class="example-level"><div class="node" style="margin-left: 60px;">4</div></div>
                        </div>
                    `; // Skewed to the right
                    break;
                case 'skewed':
                     description = 'A Skewed Tree (either left or right) is a degenerate tree where each parent node has only one child on the same side.';
                      exampleHtml = `
                        <div class="example-tree" style="align-items: flex-start;">
                            <div class="example-level"><div class="node" style="margin-left: 0;">1</div></div>
                            <div class="example-level"><div class="node" style="margin-left: 20px;">2</div></div>
                             <div class="example-level"><div class="node" style="margin-left: 40px;">3</div></div>
                              <div class="example-level"><div class="node" style="margin-left: 60px;">4</div></div>
                        </div>
                    `; // Right-skewed example
                    break;
                default:
                    description = 'Select a tree type to see an example.';
                    break;
            }

             if (exampleHtml) {
                 treeTypeExampleDiv.innerHTML = exampleHtml + `<p style="font-size:0.8em; margin-top: 10px;">${description}</p>`;
             } else {
                  treeTypeExampleDiv.textContent = description;
             }

        }


        // --- Initial Setup ---

        // Render empty trees initially
        renderAllTrees();
        updatePropertiesDisplay();
        displayTreeTypeExample(''); // Display initial message


         // Ensure panels resize correctly on window resize (optional but good for fixed layout)
         window.addEventListener('resize', renderAllTrees);

    </script>

</body>
</html>
```