```html
<!DOCTYPE html>
<html>
<head>
    <title>Cosine Similarity Explorer</title>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #ffffff; /* GFG Background */
            color: #222222; /* GFG Text */
        }

        #container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        #left-panel {
            width: 30%;
            padding: 20px;
            box-sizing: border-box;
            background-color: #f9f9f9; /* Slightly different shade */
            border-right: 1px solid #eee;
            overflow-y: auto; /* Allow scrolling if panel content exceeds height */
        }

        #main-area {
            width: 70%;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if main content exceeds height */
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #2f8d46; /* GFG Primary */
            margin-top: 0;
            margin-bottom: 20px;
        }

        h2, h3 {
             color: #333;
             border-bottom: 2px solid #2f8d46; /* GFG Primary underline */
             padding-bottom: 5px;
             margin-top: 20px;
             margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .input-group input[type="number"] {
            width: 60px;
            padding: 8px;
            margin-right: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            -moz-appearance: textfield; /* Hide arrows for Firefox */
        }

        /* Hide arrows for Chrome, Safari, Edge, Opera */
        .input-group input[type="number"]::-webkit-outer-spin-button,
        .input-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #calculation p,
        #angle-interpretation p {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        #calculation span,
        #angle-interpretation span {
            font-weight: bold;
            color: #007bff; /* A distinct color for values */
        }
        
        #calculation span[title] {
             cursor: help;
        }

        #vector-space {
            width: 100%; /* Make canvas container fill width */
            flex-grow: 1; /* Allow canvas container to grow */
            min-height: 300px; /* Minimum height for canvas */
            margin-bottom: 20px;
            background-color: #fff;
            border: 1px solid #ccc;
            position: relative; /* Needed for hover text */
        }

        #vector-space canvas {
             display: block;
             width: 100%;
             height: 100%;
        }

        .hover-text {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.9em;
            pointer-events: none; /* Don't interfere with mouse events */
            z-index: 10;
            display: none; /* Initially hidden */
        }


        footer {
            padding: 10px;
            text-align: center;
            background-color: #2f8d46; /* GFG Primary */
            color: white;
            flex-shrink: 0; /* Prevent footer from shrinking */
        }

        footer a {
            color: white;
            margin: 0 10px;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="left-panel">
            <h2>Vector Input (4D)</h2>
            <div class="input-group">
                <label>Vector X (x1, x2, x3, x4):</label>
                <input type="number" id="x1" value="3" step="any">
                <input type="number" id="x2" value="2" step="any">
                <input type="number" id="x3" value="0" step="any">
                <input type="number" id="x4" value="5" step="any">
            </div>
            <div class="input-group">
                <label>Vector Y (y1, y2, y3, y4):</label>
                <input type="number" id="y1" value="1" step="any">
                <input type="number" id="y2" value="0" step="any">
                <input type="number" id="y3" value="0" step="any">
                <input type="number" id="y4" value="0" step="any">
            </div>
        </div>
        <div id="main-area">
             <h1>Cosine Similarity Explorer</h1>

            <div id="calculation">
                <h3>Calculation Breakdown</h3>
                <p>Dot Product (X &middot; Y): <span id="dot-product"></span></p>
                <p>Magnitude of X (|X|): <span id="magnitude-x" title="Formula: sqrt(x1² + x2² + x3² + x4²)"></span></p>
                <p>Magnitude of Y (|Y|): <span id="magnitude-y" title="Formula: sqrt(y1² + y2² + y3² + y4²)"></span></p>
                <p>Cosine Similarity (cos&theta;): <span id="cosine-similarity"></span></p>
            </div>

            <div id="vector-space">
              <h3>Vector Visualization (2D: using x1, x2 and y1, y2)</h3>
              <canvas id="vector-canvas"></canvas>
              <div class="hover-text" id="vector-hover-text"></div>
            </div>

            <div id="angle-interpretation">
                <h3>Angle &amp; Similarity</h3>
                <p>Angle between vectors (&theta;): <span id="angle"></span> degrees</p>
                <p>Similarity: <span id="similarity-label"></span></p>
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2023 Cosine Similarity Explorer</p>
        <p>
            <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a> |
            <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
        </p>
    </footer>

    <script>
        const canvas = document.getElementById("vector-canvas");
        const ctx = canvas.getContext("2d");
        const hoverText = document.getElementById("vector-hover-text");

        let currentVectors = { x: [0, 0, 0, 0], y: [0, 0, 0, 0] };

        function updateCalculations() {
            const x = [
                parseFloat(document.getElementById("x1").value),
                parseFloat(document.getElementById("x2").value),
                parseFloat(document.getElementById("x3").value),
                parseFloat(document.getElementById("x4").value)
            ];
            const y = [
                parseFloat(document.getElementById("y1").value),
                parseFloat(document.getElementById("y2").value),
                parseFloat(document.getElementById("y3").value),
                parseFloat(document.getElementById("y4").value)
            ];

            // Handle potential NaN from input
            for(let i=0; i<4; i++) {
                if (isNaN(x[i])) x[i] = 0;
                if (isNaN(y[i])) y[i] = 0;
            }

            currentVectors.x = x;
            currentVectors.y = y;

            const dotProduct = x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
            const magnitudeX = Math.sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2] + x[3]*x[3]);
            const magnitudeY = Math.sqrt(y[0]*y[0] + y[1]*y[1] + y[2]*y[2] + y[3]*y[3]);

            document.getElementById("dot-product").textContent = dotProduct.toFixed(2);
            document.getElementById("magnitude-x").textContent = magnitudeX.toFixed(2);
            document.getElementById("magnitude-y").textContent = magnitudeY.toFixed(2);

            let cosineSimilarity, angleDegrees, similarityLabel;

            if (magnitudeX === 0 || magnitudeY === 0) {
                cosineSimilarity = NaN; // Undefined when one vector is zero
                angleDegrees = NaN;
                similarityLabel = "Cannot Compare (Zero Vector)";
            } else {
                // Clamp cosine similarity to [-1, 1] to avoid Math.acos returning NaN for floating point errors
                cosineSimilarity = dotProduct / (magnitudeX * magnitudeY);
                cosineSimilarity = Math.max(-1, Math.min(1, cosineSimilarity)); // Clamp

                const angleRadians = Math.acos(cosineSimilarity);
                angleDegrees = angleRadians * (180 / Math.PI);

                if (angleDegrees < 15) { // Adjusted thresholds slightly for clearer steps
                    similarityLabel = "Highly Similar";
                } else if (angleDegrees < 45) {
                    similarityLabel = "Similar";
                } else if (angleDegrees < 135) { // Dissimilar covers a wider range
                    similarityLabel = "Dissimilar";
                } else {
                    similarityLabel = "Highly Dissimilar";
                }
            }


            document.getElementById("cosine-similarity").textContent = isNaN(cosineSimilarity) ? "Undefined" : cosineSimilarity.toFixed(2);
            document.getElementById("angle").textContent = isNaN(angleDegrees) ? "Undefined" : angleDegrees.toFixed(2);
            document.getElementById("similarity-label").textContent = similarityLabel;

            // Update visualization using only the first two components
            updateVectorVisualization(x[0], x[1], y[0], y[1]);
        }

        function updateVectorVisualization(x1, x2, y1, y2) {
            // Adjust canvas size for high DPI screens and make it responsive
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);


            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            const originX = width / 2;
            const originY = height / 2;

            ctx.clearRect(0, 0, width, height);

            // Determine scaling factor
            const maxVal = Math.max(Math.abs(x1), Math.abs(x2), Math.abs(y1), Math.abs(y2), 1); // Ensure maxVal is at least 1
            const scale = Math.min(width, height) / (2.5 * maxVal); // Scale vectors to fit, leave some margin

            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(width, originY); // X-axis
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, height); // Y-axis
            ctx.stroke();

            // Function to draw a vector
            function drawVector(vx, vy, color, label) {
                const scaledVx = vx * scale;
                const scaledVy = -vy * scale; // Y-axis is flipped in canvas

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(originX, originY);
                ctx.lineTo(originX + scaledVx, originY + scaledVy);
                ctx.stroke();

                // Draw arrowhead
                const headlen = 10; // length of head in pixels
                const angle = Math.atan2(scaledVy, scaledVx);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(originX + scaledVx, originY + scaledVy);
                ctx.lineTo(originX + scaledVx - headlen * Math.cos(angle - Math.PI / 6), originY + scaledVy - headlen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(originX + scaledVx - headlen * Math.cos(angle + Math.PI / 6), originY + scaledVy - headlen * Math.sin(angle + Math.PI / 6));
                ctx.fill();

                 // Store vector endpoint for hover detection
                return { endX: originX + scaledVx, endY: originY + scaledVy, color: color, label: label, vx:vx, vy:vy };
            }

            const vectorX = drawVector(x1, x2, '#007bff', `X: (${x1.toFixed(1)}, ${x2.toFixed(1)})`); // Blue for Vector X
            const vectorY = drawVector(y1, y2, '#ff7f0e', `Y: (${y1.toFixed(1)}, ${y2.toFixed(1)})`); // Orange for Vector Y

             // Store vector endpoints for mouse tracking
            canvas.vectorEndpoints = [vectorX, vectorY];
        }

        // Mousemove handler for hover effect
        canvas.addEventListener('mousemove', function(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            let hoveredVector = null;
            const hoverThreshold = 5; // pixels tolerance

            for (const vector of canvas.vectorEndpoints) {
                if (!isNaN(vector.endX) && !isNaN(vector.endY)) { // Check for valid coordinates
                    // Simple check: Is mouse close to the endpoint?
                    // A more robust check would be distance to the line segment
                     const distanceToEnd = Math.sqrt(Math.pow(mouseX - vector.endX, 2) + Math.pow(mouseY - vector.endY, 2));

                     // Check distance to the line segment itself (more accurate)
                     // Line segment from (originX, originY) to (vector.endX, vector.endY)
                     const originX = canvas.width / (2 * window.devicePixelRatio);
                     const originY = canvas.height / (2 * window.devicePixelRatio);

                     const len2 = Math.pow(vector.endX - originX, 2) + Math.pow(vector.endY - originY, 2);
                     let distToLine;
                     if (len2 === 0) { // Handle zero length vector (point)
                         distToLine = Math.sqrt(Math.pow(mouseX - originX, 2) + Math.pow(mouseY - originY, 2));
                     } else {
                        let t = ((mouseX - originX) * (vector.endX - originX) + (mouseY - originY) * (vector.endY - originY)) / len2;
                        t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] to find closest point on segment
                        const projectionX = originX + t * (vector.endX - originX);
                        const projectionY = originY + t * (vector.endY - originY);
                        distToLine = Math.sqrt(Math.pow(mouseX - projectionX, 2) + Math.pow(mouseY - projectionY, 2));
                     }


                    if (distToLine < hoverThreshold) {
                        hoveredVector = vector;
                        break; // Found a hovered vector, stop checking
                    }
                }
            }

            if (hoveredVector) {
                 // Position the tooltip near the mouse or vector end point
                hoverText.style.left = `${mouseX + 10}px`; // Offset from mouse
                hoverText.style.top = `${mouseY + 10}px`;
                hoverText.textContent = hoveredVector.label;
                hoverText.style.display = 'block';
            } else {
                hoverText.style.display = 'none';
            }
        });

         // Hide tooltip when mouse leaves canvas
        canvas.addEventListener('mouseleave', function() {
            hoverText.style.display = 'none';
        });


        // Add event listeners to all input fields to trigger updateCalculations
        const inputs = document.querySelectorAll("#left-panel input[type='number']");
        inputs.forEach(input => {
            input.addEventListener("input", updateCalculations);
            // Also add change listener for step arrows/paste
             input.addEventListener("change", updateCalculations);
        });

        // Listen for window resize to redraw canvas
        window.addEventListener('resize', updateCalculations);

        // Initial calculation and visualization
        updateCalculations();

    </script>
</body>
</html>
```