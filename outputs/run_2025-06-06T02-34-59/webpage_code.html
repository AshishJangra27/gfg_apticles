```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Joins Explorer</title>
    <style>
        /* Basic Reset & Theme */
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: #ffffff;
            color: #222222;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Prevent overall scrolling */
        }

        header {
            background-color: #2f8d46;
            color: #ffffff;
            padding: 15px;
            text-align: center;
            font-size: 1.8em;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Ensure header is above content */
        }

        .content-wrapper {
            flex-grow: 1;
            display: flex;
            position: relative;
            overflow: hidden; /* Keep main content contained */
        }

        main {
            flex-grow: 1;
            display: flex;
            padding: 15px;
            gap: 15px;
            overflow: hidden; /* Hide overflow within main if sections don't handle it */
            box-sizing: border-box;
            /* Adjust width slightly if side panel is open to prevent overlap,
               or just let it overlap for simplicity */
             transition: padding-right 0.3s ease;
        }

         main.panel-open {
             padding-right: 315px; /* Adjust based on side panel width + padding */
         }

        .section {
            background-color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #eee;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Hide overflow in sections */
            flex: 1; /* Distribute space equally */
            min-width: 0; /* Allow flex items to shrink */
        }
        .section h2 {
             margin-top: 0;
             color: #2f8d46;
             font-size: 1.2em;
             border-bottom: 1px solid #eee;
             padding-bottom: 10px;
             margin-bottom: 10px;
             flex-shrink: 0; /* Prevent heading from shrinking */
        }

        /* Content area within sections that should scroll */
        .scrollable-content {
             flex-grow: 1;
             overflow-y: auto; /* Make this content scrollable */
             padding-right: 5px; /* Add space for scrollbar */
         }

          /* Hide scrollbar but keep functionality */
         .scrollable-content::-webkit-scrollbar {
            width: 8px;
         }
         .scrollable-content::-webkit-scrollbar-track {
            background: #f1f1f1;
         }
         .scrollable-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
         }
         .scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #555;
         }


        /* Section 1: Venn Diagram */
        #venn-diagram {
             flex-grow: 1;
             display: flex;
             justify-content: center;
             align-items: center;
             position: relative; /* For tooltips */
        }
        #venn-diagram svg {
            width: 100%; /* Make SVG responsive */
            height: 100%;
            max-width: 400px; /* Limit max size */
            max-height: 300px; /* Limit max size */
            overflow: visible; /* Allow tooltips to show outside SVG bounds if positioned relative to SVG */
        }
        .venn-circle {
            fill: rgba(47, 141, 70, 0.2); /* Semi-transparent green fill for background */
            stroke: #2f8d46;
            stroke-width: 2;
        }
         /* Interactive Areas (transparent) */
        .venn-area {
            fill: transparent;
            cursor: pointer;
            transition: fill 0.3s ease;
            /* Add subtle visual highlight on hover/click to the area itself */
        }
         .venn-area:hover {
            fill: rgba(47, 141, 70, 0.1); /* Light hover effect on the clickable area */
         }
        .venn-area.highlight {
            fill: rgba(47, 141, 70, 0.3); /* Highlight effect on the clickable area */
        }

         /* Tooltip (simple) */
        #venn-tooltip {
            position: absolute;
            background-color: #222;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            pointer-events: none; /* Allow clicks through */
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
            white-space: nowrap;
             /* Position relative to the #venn-diagram container */
        }


        /* Section 2: Tables */
        #table-simulator h3 {
             margin-top: 10px;
             margin-bottom: 5px;
             color: #444;
             font-size: 1em;
        }
        #table-simulator table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            margin-bottom: 10px;
        }
        #table-simulator th, #table-simulator td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
             word-break: break-word;
             vertical-align: top;
             font-size: 0.9em;
        }
         #table-simulator th {
             background-color: #f2f2f2;
             color: #222;
             position: sticky;
             top: 0;
             z-index: 1;
         }
        #table-simulator td[contenteditable="true"] {
            background-color: #fff;
            cursor: text;
        }
         #table-simulator td[contenteditable="true"]:focus {
             outline: 2px solid #2f8d46;
             background-color: #e8f5e9;
         }
         /* Subtle Hover Hint */
        #table-simulator td:hover {
             background-color: #f9f9f9;
        }
        /* Table row highlighting */
        #table-simulator tr.highlight {
            background-color: #e8f5e9 !important; /* Use !important to override hover if needed */
        }

        #table-simulator button {
             padding: 5px 10px;
             background-color: #2f8d46;
             color: white;
             border: none;
             border-radius: 4px;
             cursor: pointer;
             font-size: 0.9em;
             transition: background-color 0.2s ease;
             flex-shrink: 0; /* Prevent button from shrinking */
        }
        #table-simulator button:hover {
             background-color: #25753c;
        }


        /* Section 3: Query & Result */
         #query-result label {
             display: block;
             margin-bottom: 5px;
             font-weight: bold;
             color: #444;
             flex-shrink: 0;
         }
        #query-result select {
             padding: 8px;
             border: 1px solid #ddd;
             border-radius: 4px;
             font-size: 1em;
             margin-bottom: 10px;
             flex-shrink: 0;
             background-color: white;
        }
        #query-result h3 {
            margin-top: 10px;
            margin-bottom: 5px;
             color: #444;
             font-size: 1em;
             flex-shrink: 0;
        }
        #query-result pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: monospace;
            font-size: 0.9em;
            color: #333;
            flex-shrink: 0;
        }
         #query-result table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
         }
         #query-result th, #query-result td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
             word-break: break-word;
              vertical-align: top;
              font-size: 0.9em;
         }
         #query-result th {
             background-color: #f2f2f2;
             color: #222;
             position: sticky;
             top: 0;
             z-index: 1;
         }
         /* Result table row highlighting */
         #query-result tr.highlight {
             background-color: #e8f5e9 !important; /* Use !important */
         }


        /* Side Panel */
        #side-panel {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 300px;
            background-color: #fff;
            border-left: 1px solid #eee;
            box-shadow: -4px 0 8px rgba(0,0,0,0.1);
            transform: translateX(100%); /* Initially hidden */
            transition: transform 0.3s ease;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 5; /* Above main content */
        }
        #side-panel.open {
            transform: translateX(0); /* Slide in */
        }
         #side-panel h3 {
             margin-top: 0;
             color: #2f8d46;
             border-bottom: 1px solid #eee;
             padding-bottom: 10px;
             margin-bottom: 10px;
         }
         #side-panel p {
             font-size: 0.9em;
             line-height: 1.4;
         }

        /* Footer */
        footer {
            background-color: #2f8d46;
            color: #ffffff;
            text-align: center;
            padding: 10px;
            font-size: 0.9em;
            flex-shrink: 0;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Ensure footer is above content */
        }
        footer a {
            color: #ffffff;
            text-decoration: none;
            margin: 0 10px;
        }
        footer a:hover {
            text-decoration: underline;
        }

         /* Media Queries for basic responsiveness */
         @media (max-width: 1000px) {
             main {
                 flex-direction: column; /* Stack sections vertically */
                 overflow-y: auto; /* Allow scrolling main area */
             }
             main.panel-open {
                 padding-right: 15px; /* Don't shrink main area, let panel overlap */
             }
             .section {
                 flex-basis: auto; /* Allow sections to take height based on content */
                 min-height: 300px; /* Ensure sections have some minimum height */
             }
              #side-panel {
                 width: 250px;
             }
         }
         @media (max-width: 600px) {
             header h1 {
                 font-size: 1.4em;
             }
             #side-panel {
                 width: 200px;
             }
             main {
                 padding: 10px;
                 gap: 10px;
             }
             .section {
                 padding: 10px;
                 min-height: 200px;
             }
         }

    </style>
</head>
<body>
    <header>
        <h1>SQL Joins Explorer</h1>
    </header>

    <div class="content-wrapper">
        <main id="main-content">
            <section id="venn-section" class="section">
                <h2>1. Venn Diagram</h2>
                <div id="venn-diagram">
                     <svg viewBox="0 0 400 300">
                        <!-- Visual Circles -->
                        <circle cx="150" cy="150" r="100" class="venn-circle" opacity="0.8"/>
                        <circle cx="250" cy="150" r="100" class="venn-circle" opacity="0.8"/>

                        <!-- Interactive Areas (Approximate Rectangles over regions) -->
                        <!-- Overlap Area -->
                        <rect class="venn-area" x="150" y="50" width="100" height="200" data-region="overlap"></rect>
                        <!-- A-only Area -->
                        <rect class="venn-area" x="50" y="50" width="100" height="200" data-region="a-only"></rect>
                        <!-- B-only Area -->
                        <rect class="venn-area" x="250" y="50" width="100" height="200" data-region="b-only"></rect>

                         <!-- Labels (Optional, static) -->
                          <text x="150" y="150" text-anchor="middle" dy="-5" fill="#222" font-size="1.2em" style="pointer-events: none;">Table A</text>
                         <text x="250" y="150" text-anchor="middle" dy="-5" fill="#222" font-size="1.2em" style="pointer-events: none;">Table B</text>
                         <text x="200" y="150" text-anchor="middle" dy="15" fill="#222" font-size="1.2em" style="pointer-events: none;">Overlap</text>

                    </svg>
                     <!-- Tooltip element -->
                     <div id="venn-tooltip" class="tooltip"></div>
                </div>
            </section>

            <section id="table-section" class="section">
                <h2>2. Table Data Simulator</h2>
                <div class="scrollable-content">
                    <h3>Table A</h3>
                    <table id="table-a">
                        <thead>
                            <tr><th>id</th><th>value_a</th></tr>
                        </thead>
                        <tbody>
                            <!-- Default rows -->
                            <tr><td contenteditable="true">1</td><td contenteditable="true">Apple</td></tr>
                            <tr><td contenteditable="true">2</td><td contenteditable="true">Banana</td></tr>
                            <tr><td contenteditable="true">3</td><td contenteditable="true">Cherry</td></tr>
                            <tr><td contenteditable="true">4</td><td contenteditable="true">Date</td></tr>
                        </tbody>
                    </table>
                     <button onclick="addRow('table-a')">+ Add Row A</button>

                    <h3>Table B</h3>
                    <table id="table-b">
                        <thead>
                            <tr><th>id</th><th>value_b</th></tr>
                        </thead>
                        <tbody>
                            <!-- Default rows -->
                            <tr><td contenteditable="true">3</td><td contenteditable="true">Cherry</td></tr>
                            <tr><td contenteditable="true">4</td><td contenteditable="true">Date</td></tr>
                            <tr><td contenteditable="true">5</td><td contenteditable="true">Elderberry</td></tr>
                            <tr><td contenteditable="true">6</td><td contenteditable="true">Fig</td></tr>
                        </tbody>
                    </table>
                     <button onclick="addRow('table-b')">+ Add Row B</button>
                </div>
            </section>

            <section id="result-section" class="section">
                <h2>3. SQL Query & Result</h2>
                 <label for="join-type">Select JOIN Type:</label>
                <select id="join-type">
                    <option value="INNER">INNER JOIN</option>
                    <option value="LEFT">LEFT JOIN</option>
                    <option value="RIGHT">RIGHT JOIN</option>
                    <option value="FULL">FULL OUTER JOIN</option>
                    <option value="NATURAL">NATURAL JOIN</option>
                </select>

                <h3>Query:</h3>
                <pre id="sql-query">SELECT * FROM TableA INNER JOIN TableB ON TableA.id = TableB.id;</pre>

                <h3>Result:</h3>
                <div class="scrollable-content">
                    <table id="result-table">
                        <thead>
                            <!-- Headers will be generated by JS -->
                             <tr><th>id</th><th>value_a</th><th>value_b</th></tr>
                        </thead>
                        <tbody>
                            <!-- Result rows will be generated by JS -->
                        </tbody>
                    </table>
                </div>
            </section>
        </main>

        <aside id="side-panel">
            <h3>Join Explanation</h3>
            <div id="explanation-content">
                <p>Click on sections of the Venn diagram or select a JOIN type to learn more.</p>
            </div>
        </aside>
    </div>

    <footer>
        <span>&copy; 2023 SQL Joins Explorer</span>
        <a href="https://github.com/AshishJangra27/" target="_blank">GitHub</a>
        <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank">LinkedIn</a>
    </footer>

    <script>
        // Data Model
        let tableAData = [];
        let tableBData = [];
        let currentJoinType = 'INNER'; // Default join type
        let vennHighlightRegion = null; // 'a-only', 'b-only', 'overlap', null

        // DOM Elements
        const tableAEl = document.getElementById('table-a');
        const tableBEl = document.getElementById('table-b');
        const joinTypeSelectEl = document.getElementById('join-type');
        const sqlQueryEl = document.getElementById('sql-query');
        const resultTableEl = document.getElementById('result-table');
        const explanationContentEl = document.getElementById('explanation-content');
        const sidePanelEl = document.getElementById('side-panel');
        const mainContentEl = document.getElementById('main-content');
        const vennAreas = document.querySelectorAll('#venn-diagram .venn-area'); // Clickable SVG areas
        const vennTooltipEl = document.getElementById('venn-tooltip');

        // --- Initialization ---
        function init() {
            // Load initial data from tables
            loadDataFromDOM();
            // Set initial query and result
            updateQueryDisplay();
            updateResultTable(); // This calls applyHighlights internally
            updateExplanation(currentJoinType); // Initial explanation

            // Add event listeners
            setupTableListeners();
            joinTypeSelectEl.addEventListener('change', handleJoinTypeChange);
            setupVennListeners();

            // Initial state for side panel
            sidePanelEl.classList.remove('open');
        }

        // --- Data Handling ---
        function loadDataFromDOM() {
            tableAData = parseTable(tableAEl);
            tableBData = parseTable(tableBEl);
        }

        function parseTable(tableElement) {
            const data = [];
            const rows = tableElement.querySelectorAll('tbody tr');
            const headers = Array.from(tableElement.querySelectorAll('thead th')).map(th => th.textContent.trim());

            rows.forEach(row => {
                const rowData = {};
                const cells = row.querySelectorAll('td[contenteditable="true"]');
                headers.forEach((header, index) => {
                     // Use header text as key, default to col_X if header is missing
                     // Or just use the actual header text always
                     const cell = cells[index];
                    rowData[header] = cell ? cell.textContent.trim() || null : null; // Use null for empty cells or missing cells
                });
                data.push(rowData);
            });
            return data;
        }

         function updateCellDataAndViews() {
             loadDataFromDOM(); // Reload all data after any edit/add
             updateResultTable(); // Recalculate result and re-render
             // applyHighlights is called by updateResultTable
         }


        function setupTableListeners() {
             // Use event delegation on the main sections to handle edits on any table cell
             document.getElementById('table-section').addEventListener('input', function(event) {
                 const target = event.target;
                 if (target.tagName === 'TD' && target.contentEditable === 'true') {
                     // Input event fires frequently, defer the full update
                     // A simple debounce could be added here if needed, but for small tables direct update is fine.
                      updateCellDataAndViews();
                 }
             });

              // Add blur listener as fallback/completeness check
              document.getElementById('table-section').addEventListener('blur', function(event) {
                 const target = event.target;
                 if (target.tagName === 'TD' && target.contentEditable === 'true') {
                     // Always update on blur to ensure data consistency
                      updateCellDataAndViews();
                 }
             }, true); // Use capturing phase for blur
        }

        function addRow(tableId) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const newRow = document.createElement('tr');
            const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());

            headers.forEach(() => {
                const td = document.createElement('td');
                td.setAttribute('contenteditable', 'true');
                td.textContent = ''; // Start with empty cell
                newRow.appendChild(td);
            });

            tbody.appendChild(newRow);

            // Update data model and views
             updateCellDataAndViews();
        }

        // --- Join Logic ---
        function performJoin(type, dataA, dataB) {
            const commonColumn = 'id'; // Assume join is always on 'id' for simplicity

            // Get headers from potential data. Use defaults if tables are empty.
            const headersA = dataA.length > 0 ? Object.keys(dataA[0]) : ['id', 'value_a'];
            const headersB = dataB.length > 0 ? Object.keys(dataB[0]) : ['id', 'value_b'];

            // Build result headers: common first, then unique A, then unique B
            let resultHeaders = [];
            const allKeys = new Set([...headersA, ...headersB]);
             if (allKeys.has(commonColumn)) {
                 resultHeaders.push(commonColumn);
                 allKeys.delete(commonColumn);
             }
             headersA.filter(h => h !== commonColumn).forEach(h => { if(allKeys.has(h)) { resultHeaders.push(h); allKeys.delete(h); } });
             headersB.filter(h => h !== commonColumn).forEach(h => { if(allKeys.has(h)) { resultHeaders.push(h); allKeys.delete(h); } });
             allKeys.forEach(h => resultHeaders.push(h)); // Add any remaining unexpected keys


            const finalResult = [];
            const addedAIndices = new Set();
            const addedBIndices = new Set();

            // Helper to combine rows
            function combineRows(rowA, indexA, rowB, indexB, source) {
                 const newRow = {_source: source, _rowAIndex: indexA, _rowBIndex: indexB};
                 resultHeaders.forEach(header => {
                     if (header === commonColumn) {
                          // Use non-null ID if available, else A's, else B's, else null
                          newRow[header] = (rowA && rowA[commonColumn] !== null && rowA[commonColumn] !== "") ? rowA[commonColumn] :
                                            (rowB && rowB[commonColumn] !== null && rowB[commonColumn] !== "") ? rowB[commonColumn] : null;
                     } else if (rowA && rowA.hasOwnProperty(header)) {
                         newRow[header] = rowA[header];
                     } else if (rowB && rowB.hasOwnProperty(header)) {
                          newRow[header] = rowB[header];
                     } else {
                         newRow[header] = null; // Column not in either row
                     }
                 });
                 return newRow;
            }

            // Process matches (relevant for INNER, LEFT, RIGHT, FULL, NATURAL)
            dataA.forEach((rowA, indexA) => {
                 const keyA = String(rowA[commonColumn]);
                 if (keyA !== null && keyA !== "") {
                     let matchFoundInB = false;
                     dataB.forEach((rowB, indexB) => {
                         const keyB = String(rowB[commonColumn]);
                          if (keyB === keyA && keyB !== null && keyB !== "") {
                             // Match found
                             matchFoundInB = true;
                             // Add to result for INNER, LEFT, RIGHT, FULL
                             if (type !== 'NATURAL') { // Standard join
                                 finalResult.push(combineRows(rowA, indexA, rowB, indexB, 'overlap'));
                                 addedAIndices.add(indexA);
                                 addedBIndices.add(indexB);
                             } else { // Natural Join: check all common columns
                                const commonCols = Object.keys(rowA).filter(k => Object.keys(rowB).includes(k));
                                let allCommonMatch = true;
                                for (const col of commonCols) {
                                    if (String(rowA[col]) !== String(rowB[col])) {
                                        allCommonMatch = false;
                                        break;
                                    }
                                }
                                if (allCommonMatch) {
                                     finalResult.push(combineRows(rowA, indexA, rowB, indexB, 'overlap'));
                                     addedAIndices.add(indexA);
                                     addedBIndices.add(indexB);
                                }
                             }
                         }
                     });

                      // Add A-only rows for LEFT/FULL if no match was found for this specific A row (based on its key)
                     // This requires checking if *this specific rowA index* resulted in an overlap row being added.
                     if ((type === 'LEFT' || type === 'FULL') && !addedAIndices.has(indexA)) {
                         finalResult.push(combineRows(rowA, indexA, null, null, 'a-only'));
                         addedAIndices.add(indexA); // Mark this A row as processed
                     }
                 } else {
                      // Handle A rows with null/empty ID for LEFT/FULL
                      if ((type === 'LEFT' || type === 'FULL') && !addedAIndices.has(indexA)) {
                           finalResult.push(combineRows(rowA, indexA, null, null, 'a-only'));
                           addedAIndices.add(indexA);
                      }
                 }
            });

             // Add B-only rows for RIGHT/FULL
             if (type === 'RIGHT' || type === 'FULL') {
                 dataB.forEach((rowB, indexB) => {
                      // Check if this specific B row index was added as part of an overlap
                     if (!addedBIndices.has(indexB)) {
                          finalResult.push(combineRows(null, null, rowB, indexB, 'b-only'));
                          addedBIndices.add(indexB); // Mark this B row as processed
                     }
                 });
             }

             // Handle Natural Join where commonColumn doesn't exist in one/both tables (acts like CROSS JOIN then?)
             // Or if no matches at all, Natural Join *might* yield empty result.
             // Let's stick to the common case where 'id' exists and is the natural join key.
             // If Natural Join produces no results from overlap (no common ID values), it results in an empty table.


             return { data: finalResult, headers: resultHeaders };
        }


        // --- UI Updates ---
        function updateQueryDisplay() {
            const selectedType = joinTypeSelectEl.value;
            let query = `SELECT * FROM TableA`;

            switch (selectedType) {
                case 'INNER':
                    query += ` INNER JOIN TableB ON TableA.id = TableB.id;`;
                    break;
                case 'LEFT':
                    query += ` LEFT JOIN TableB ON TableA.id = TableB.id;`;
                    break;
                case 'RIGHT':
                    query += ` RIGHT JOIN TableB ON TableA.id = TableB.id;`; // Common convention
                    break;
                case 'FULL':
                    query += ` FULL OUTER JOIN TableB ON TableA.id = TableB.id;`;
                    break;
                case 'NATURAL':
                     // Natural join automatically joins on columns with same name ('id' assumed here)
                    query = `SELECT * FROM TableA NATURAL JOIN TableB;`;
                     break;
                default:
                    query += `;`; // Default or error case
            }
            sqlQueryEl.textContent = query;
        }

        function updateResultTable() {
            const result = performJoin(currentJoinType, tableAData, tableBData);
            const tbody = resultTableEl.querySelector('tbody');
            const thead = resultTableEl.querySelector('thead');

            // Clear current table body and header
            tbody.innerHTML = '';
            thead.innerHTML = '';

             // Add headers
             if (result.headers.length > 0) {
                 const headerRow = document.createElement('tr');
                 result.headers.forEach(header => {
                     const th = document.createElement('th');
                     th.textContent = header;
                     headerRow.appendChild(th);
                 });
                 thead.appendChild(headerRow);
             } else if ((tableAData.length > 0 || tableBData.length > 0) && result.data.length === 0) {
                  // If result is empty but source tables have data, show expected headers
                  const defaultHeaders = [...Object.keys(tableAData.length > 0 ? tableAData[0] : {}), ...Object.keys(tableBData.length > 0 ? tableBData[0] : {})];
                   const uniqueDefaultHeaders = Array.from(new Set(defaultHeaders)).filter(h => h !== 'id');
                    let displayHeaders = ['id', ...uniqueDefaultHeaders];
                    if (!displayHeaders.includes('id')) displayHeaders = uniqueDefaultHeaders; // Handle case where 'id' isn't in data
                  if (displayHeaders.length > 0) {
                       const headerRow = document.createElement('tr');
                       displayHeaders.forEach(header => {
                           const th = document.createElement('th');
                           th.textContent = header;
                           headerRow.appendChild(th);
                       });
                       thead.appendChild(headerRow);
                  }
             }


            // Add data rows
            if (result.data.length > 0) {
                result.data.forEach((rowData) => { // No need for index here for simple display
                    const rowEl = document.createElement('tr');
                    // Add source and index data attributes for highlighting
                    rowEl.dataset.source = rowData._source;
                    rowEl.dataset.rowIndexA = rowData._rowAIndex !== null ? rowData._rowAIndex : '';
                    rowEl.dataset.rowIndexB = rowData._rowBIndex !== null ? rowData._rowBIndex : '';

                    result.headers.forEach(header => {
                        const td = document.createElement('td');
                        // Display null as (null) or empty string
                        td.textContent = rowData.hasOwnProperty(header) && rowData[header] !== null && rowData[header] !== "" ? rowData[header] : '(null)';
                        rowEl.appendChild(td);
                    });
                    tbody.appendChild(rowEl);
                });
            } else {
                 // Display a message if the result is empty
                const rowEl = document.createElement('tr');
                const td = document.createElement('td');
                 td.setAttribute('colspan', result.headers.length > 0 ? result.headers.length : 1);
                td.textContent = '(Empty Result Set)';
                td.style.textAlign = 'center';
                td.style.fontStyle = 'italic';
                rowEl.appendChild(td);
                tbody.appendChild(rowEl);
            }


            // Re-apply highlights after updating the table
            applyHighlights();
        }

         function updateExplanation(typeOrRegion) {
             let title = "Join Explanation";
             let content = "";

             const joinType = joinTypeSelectEl.value; // Get current join type

             if (['INNER', 'LEFT', 'RIGHT', 'FULL', 'NATURAL'].includes(typeOrRegion)) {
                 // Explanation for a selected join type
                 title = `${typeOrRegion.replace('FULL', 'FULL OUTER')} JOIN Explanation`;
                 switch (typeOrRegion) {
                     case 'INNER':
                         content = "<p><b>INNER JOIN</b>: Returns rows when there is a match on the join column ('id') in <u>both</u> tables.</p><p>Corresponds to the <b>Overlap</b> section of the Venn diagram.</p>";
                         break;
                     case 'LEFT':
                         content = "<p><b>LEFT JOIN</b>: Returns all rows from the left table (Table A), and the matched rows from the right table (Table B).</p><p>Results include rows from <b>Table A (matched and unmatched)</b> and <b>Table B (matched only)</b>. Corresponds to the <b>A-only</b> and <b>Overlap</b> sections.</p>";
                         break;
                     case 'RIGHT':
                         content = "<p><b>RIGHT JOIN</b>: Returns all rows from the right table (Table B), and the matched rows from the left table (Table A).</p><p>Results include rows from <b>Table B (matched and unmatched)</b> and <b>Table A (matched only)</b>. Corresponds to the <b>B-only</b> and <b>Overlap</b> sections.</p>";
                         break;
                     case 'FULL':
                         content = "<p><b>FULL OUTER JOIN</b>: Returns all rows when there is a match in one of the tables or no match at all.</p><p>Results include rows from <b>Table A (matched and unmatched)</b> and <b>Table B (matched and unmatched)</b>. Corresponds to the <b>A-only</b>, <b>B-only</b>, and <b>Overlap</b> sections.</p>";
                         break;
                     case 'NATURAL':
                         content = "<p><b>NATURAL JOIN</b>: Joins tables implicitly on all columns with the same name (in this case, 'id'). It behaves like an INNER JOIN if only the common column matches.</p><p>Corresponds to the <b>Overlap</b> section (if 'id' matches).</p>";
                         break;
                 }
             } else if (['a-only', 'b-only', 'overlap'].includes(typeOrRegion)) {
                 // Explanation for a clicked Venn region, relative to the CURRENT join type
                  title = `Venn Region: ${typeOrRegion.replace('-', ' ')}`;
                  content = `<p>This region represents rows that are part of a join result because they originated from:</p>`;
                 switch(typeOrRegion) {
                     case 'a-only':
                          content += `<p><b>Table A only</b> (no match found in Table B on the join column).</p>`;
                          if (joinType === 'LEFT' || joinType === 'FULL') {
                               content += `<p>These rows <u>are included</u> in a <b>${joinType.replace('FULL', 'FULL OUTER')} JOIN</b>.</p>`;
                          } else {
                                content += `<p>These rows are <u>not included</u> in a <b>${joinType.replace('FULL', 'FULL OUTER')} JOIN</b>.</p>`;
                          }
                         break;
                     case 'b-only':
                          content += `<p><b>Table B only</b> (no match found in Table A on the join column).</p>`;
                          if (joinType === 'RIGHT' || joinType === 'FULL') {
                               content += `<p>These rows <u>are included</u> in a <b>${joinType.replace('FULL', 'FULL OUTER')} JOIN</b>.</p>`;
                          } else {
                                content += `<p>These rows are <u>not included</u> in a <b>${joinType.replace('FULL', 'FULL OUTER')} JOIN</b>.</p>`;
                          }
                         break;
                     case 'overlap':
                          content += `<p>Rows where a match was found in <b>both Table A and Table B</b> on the join column.</p>`;
                           content += `<p>These rows <u>are included</u> in <b>${joinType.replace('FULL', 'FULL OUTER')} JOIN</b> (and also INNER, LEFT, RIGHT Joins).</p>`;
                         break;
                 }
             } else {
                 // Default explanation
                 title = "Join Explanation";
                 content = "<p>Click on sections of the Venn diagram or select a JOIN type to learn more.</p>";
             }

             sidePanelEl.querySelector('h3').textContent = title;
             explanationContentEl.innerHTML = content;

              // Open the side panel if it's closed
             if (!sidePanelEl.classList.contains('open')) {
                 sidePanelEl.classList.add('open');
                 mainContentEl.classList.add('panel-open'); // Add class to main for layout adjustment
             }
         }

         function closeSidePanel() {
             sidePanelEl.classList.remove('open');
             mainContentEl.classList.remove('panel-open');
             updateExplanation(currentJoinType); // Revert explanation to join type
         }


        // --- Event Handlers ---
        function handleJoinTypeChange(event) {
            currentJoinType = event.target.value;
            updateQueryDisplay();
            updateResultTable(); // This will call applyHighlights internally
            updateExplanation(currentJoinType); // Update explanation for the join type
            resetVennHighlight(); // Clear Venn highlight when join type changes
             if(sidePanelEl.classList.contains('open')) { // If panel is open, update content, don't close
                 updateExplanation(currentJoinType);
             } else { // If panel is closed, maybe open it with join explanation? Or just update content?
                 // Let's open it for better discoverability
                  updateExplanation(currentJoinType);
             }
        }

         function setupVennListeners() {
             vennAreas.forEach(area => {
                 area.addEventListener('click', handleVennClick);
                 area.addEventListener('mouseover', handleVennHover);
                 area.addEventListener('mouseout', handleVennOut);
             });

             // Optional: Click outside side panel to close it
             document.addEventListener('click', function(event) {
                 const isClickInsidePanel = sidePanelEl.contains(event.target);
                 const isClickInsideVenn = document.getElementById('venn-diagram').contains(event.target);
                 const isSidePanelOpen = sidePanelEl.classList.contains('open');

                 if (isSidePanelOpen && !isClickInsidePanel && !isClickInsideVenn) {
                    closeSidePanel();
                    resetVennHighlight(); // Also clear highlight
                 }
             });
         }

        function handleVennClick(event) {
            const region = event.target.dataset.region;
            if (!region) return;

            // If clicking the already highlighted region, reset
            if (vennHighlightRegion === region) {
                setVennHighlight(null); // De-highlight
                applyHighlights(null); // Clear table highlights
                updateExplanation(currentJoinType); // Revert explanation
                 closeSidePanel(); // Close panel if clicking highlighted area again
            } else {
                 // Update Venn highlight
                setVennHighlight(region);
                // Update side panel explanation based on region
                updateExplanation(region);
                // Apply highlighting to tables
                applyHighlights(region);
            }
        }

         function handleVennHover(event) {
             const region = event.target.dataset.region;
             if (!region) return;

             const vennSvg = event.target.closest('svg');
             const svgRect = vennSvg.getBoundingClientRect();
             const mouseX = event.clientX;
             const mouseY = event.clientY;

             let tooltipText = "";
             switch(region) {
                 case 'a-only': tooltipText = "Table A only (No match in B)"; break;
                 case 'b-only': tooltipText = "Table B only (No match in A)"; break;
                 case 'overlap': tooltipText = "Matched in both tables"; break;
             }

             vennTooltipEl.textContent = tooltipText;
             // Position tooltip relative to the mouse cursor within the Venn container
              const containerRect = document.getElementById('venn-diagram').getBoundingClientRect();
             vennTooltipEl.style.left = `${mouseX - containerRect.left + 10}px`;
             vennTooltipEl.style.top = `${mouseY - containerRect.top + 10}px`;
             vennTooltipEl.style.opacity = 1;
         }

         function handleVennOut() {
             vennTooltipEl.style.opacity = 0;
         }


        function setVennHighlight(region) {
            vennHighlightRegion = region;
            vennAreas.forEach(area => {
                if (area.dataset.region === region) {
                    area.classList.add('highlight');
                } else {
                    area.classList.remove('highlight');
                }
            });
        }

         function resetVennHighlight() {
             vennHighlightRegion = null;
             vennAreas.forEach(area => area.classList.remove('highlight'));
             // Don't change explanation or close panel automatically here
         }


        function applyHighlights(regionToHighlight = vennHighlightRegion) {
            // Clear all previous highlights
            document.querySelectorAll('#table-simulator tr, #result-table tr').forEach(row => {
                row.classList.remove('highlight');
            });

            if (!regionToHighlight) {
                return; // No region selected, just clear highlights
            }

            // Highlight result table rows based on their source tag
            const resultRows = resultTableEl.querySelectorAll('tbody tr');
            resultRows.forEach(row => {
                 const rowSource = row.dataset.source;
                 const joinType = currentJoinType;

                 let shouldHighlight = false;
                 // Determine if the clicked region's rows are included in the current join type AND match the row's source
                 if (rowSource === regionToHighlight) {
                      if (regionToHighlight === 'overlap' && (joinType === 'INNER' || joinType === 'LEFT' || joinType === 'RIGHT' || joinType === 'FULL' || joinType === 'NATURAL')) {
                          shouldHighlight = true;
                      } else if (regionToHighlight === 'a-only' && (joinType === 'LEFT' || joinType === 'FULL')) {
                          shouldHighlight = true;
                      } else if (regionToHighlight === 'b-only' && (joinType === 'RIGHT' || joinType === 'FULL')) {
                          shouldHighlight = true;
                      }
                 }


                 if (shouldHighlight) {
                    row.classList.add('highlight');

                    // Highlight corresponding rows in Table A and Table B
                     const indexA = row.dataset.rowIndexA;
                     const indexB = row.dataset.rowIndexB;

                    if (indexA !== '') {
                        const rowA = tableAEl.querySelectorAll('tbody tr')[parseInt(indexA)];
                         if (rowA) rowA.classList.add('highlight');
                    }
                     if (indexB !== '') {
                         const rowB = tableBEl.querySelectorAll('tbody tr')[parseInt(indexB)];
                         if (rowB) rowB.classList.add('highlight');
                     }
                 }
            });
        }


        // --- Initial Load ---
        init();

    </script>

</body>
</html>
```