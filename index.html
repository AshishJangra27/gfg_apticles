```html
<!DOCTYPE html>
<html>
<head>
    <title>Interactive Depth-First Search (DFS) Visualizer</title>
    <style>
        body {
            font-family: monospace;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            color: #333;
            line-height: 1.5; /* Improve readability */
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
        }

        p {
            text-align: center;
            margin-bottom: 20px;
        }

        #container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            max-width: 1200px;
            margin: 0 auto;
        }

        #controls, #visualization-area {
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 5px;
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        #controls {
            flex: 0 0 280px;
            max-width: 100%;
            display: flex; /* Use flexbox for internal layout */
            flex-direction: column;
        }

        #visualization-area {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }

        h2 {
            margin-top: 10px; /* Space above section headers */
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        #controls h2:first-child,
        #visualization-area h2:first-child {
            margin-top: 0; /* No top margin for first h2 in panels */
        }


        button, select, input[type="range"] {
            font-family: monospace;
            padding: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: #eee;
            box-sizing: border-box; /* Include padding and border */
            width: 100%; /* Make controls full width by default */
            display: block; /* Ensure block display by default */
        }

        button:not(:disabled):hover {
            background-color: #ddd;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

         button.active-mode {
             background-color: #cce; /* Light blue highlight for active mode button */
             border-color: #99c;
         }

        #start-node-selection, #speed-control {
            margin-bottom: 10px;
            width: 100%; /* Full width */
            display: block; /* Ensure block display */
        }
         #start-node-selection label, #speed-control label {
             display: block; /* Label on its own line */
             margin-bottom: 5px;
         }
         #speed-control span {
             vertical-align: middle;
             font-size: 0.9em;
         }
         #speed-control input[type="range"] {
             width: calc(100% - 50px); /* Adjust width for label and text */
             vertical-align: middle;
             margin-bottom: 0; /* No margin below slider */
             display: inline-block; /* Allow label and text next to it */
         }


        #graph-svg {
            width: 100%;
            min-height: 300px;
            border: 1px solid #ccc;
            margin-bottom: 15px;
            background-color: #fff;
            flex-grow: 1;
            overflow: hidden;
            cursor: default; /* Default cursor for SVG area */
        }
         #graph-svg.connecting-mode {
             cursor: crosshair; /* Indicate connecting mode */
         }
         #graph-svg.deleting-mode .node {
             cursor: pointer; /* Indicate nodes are clickable for deletion */
         }
         #graph-svg .node {
             cursor: grab; /* Default node cursor */
         }


        .node {
            fill: #ADD8E6;
            stroke: #333;
            stroke-width: 1.5;
            transition: fill 0.3s ease, stroke 0.3s ease, stroke-width 0.3s ease; /* Smooth color changes */
        }

        .node.visiting { /* Not currently used with 'current' class */
            fill: yellow;
        }

        .node.visited {
            fill: lightgreen;
        }

         .node.current {
            stroke: blue;
            stroke-width: 3;
        }
         .node.dragging {
             cursor: grabbing !important; /* Override grab cursor */
         }


        .node-text {
             font-size: 12px;
             fill: #333;
             pointer-events: none; /* Text doesn't block clicks on node */
             user-select: none; /* Prevent text selection */
             transition: fill 0.3s ease, font-weight 0.3s ease;
        }
         .node.current + .node-text { /* Text immediately following the current node */
            fill: blue;
             font-weight: bold;
         }


        .edge {
            stroke: #555;
            stroke-width: 2;
            marker-end: url(#arrowhead);
            transition: stroke 0.3s ease, stroke-width 0.3s ease; /* Smooth color changes */
        }

         .edge.exploring {
             stroke: purple;
             stroke-width: 3;
             marker-end: url(#arrowhead-exploring); /* Use exploring arrowhead */
         }


        /* SVG arrowhead marker definition */
        #graph-svg marker#arrowhead { fill: #555; }
        #graph-svg marker#arrowhead-exploring { fill: purple; }


        #visited-display {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }
         #visited-display strong {
             display: block; /* Label on its own line */
             margin-bottom: 5px;
         }
         #visited-display ul {
             list-style: none;
             padding: 0;
             margin: 0;
             display: flex; /* Arrange items in a row */
             flex-wrap: wrap; /* Allow wrapping */
             gap: 8px; /* Space between items */
         }
         #visited-display li {
             padding: 3px 6px;
             border: 1px solid #ccc;
             border-radius: 3px;
             font-size: 0.9em;
         }
         #visited-display li.visited-true {
             background-color: lightgreen;
         }
          #visited-display li.visited-false {
             background-color: #eee;
         }
         #visited-display li.visited-current { /* Highlight the visited status being updated */
             border-color: blue;
             box-shadow: 0 0 3px rgba(0, 0, 255, 0.5);
         }


        #traversal-result {
            margin-top: 10px; /* Space above result display */
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }

        #code-snippet {
            display: block;
            background-color: #2b2b2b;
            color: #f8f8f2;
            padding: 10px;
            overflow-x: auto;
            border-radius: 4px;
            margin: 0;
        }
         #code-snippet code {
             display: block; /* Treat code block as block for line breaks */
         }


        #code-snippet .highlighted-line {
            background-color: #4f4f4f;
            display: block;
            padding: 2px 0;
            white-space: pre; /* Preserve leading whitespace */
            line-height: inherit; /* Inherit line height */
        }

        #mode-indicator {
            display: block;
            margin-bottom: 15px;
            font-weight: bold;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9em;
            color: #666;
        }

        footer a {
            color: #666;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

         /* Responsive adjustments */
         @media (max-width: 768px) {
             body {
                 padding: 10px;
             }
             #container {
                 flex-direction: column; /* Stack panels vertically */
                 gap: 10px;
             }
             #controls {
                 flex-basis: auto; /* Remove fixed width */
                 width: 100%; /* Take full width */
             }
             #visualization-area {
                  width: 100%; /* Take full width */
             }
              button, select, input[type="range"] {
                 margin-bottom: 5px;
                 padding: 6px;
             }
             #controls button,
             #controls select,
              #controls input[type="range"],
             #controls div { /* Apply to direct children in controls */
                 width: 100%; /* Full width again in stacked layout */
                 display: block;
             }
             #speed-control input[type="range"] {
                 width: calc(100% - 50px); /* Adjust for label and text */
                 display: inline-block;
             }
              #start-node-selection label, #speed-control label, #speed-control span {
                  display: inline; /* Labels and span can be inline */
              }

             #visited-display ul {
                 gap: 5px; /* Smaller gap on mobile */
             }
         }
    </style>
</head>
<body>
    <h1>Interactive Depth-First Search (DFS) Visualizer</h1>
    <p>Explore the Depth-First Search algorithm step-by-step on a graph.</p>

    <div id="container">
        <div id="controls">
            <h2>Graph Creation</h2>
            <button id="add-node-btn">Add Node (Click SVG)</button>
            <button id="connect-nodes-btn">Connect Nodes</button>
            <button id="delete-node-btn">Delete Node</button>
            <span id="mode-indicator">Mode: Select</span>

            <h2>Algorithm Controls</h2>
            <div id="start-node-selection">
                <label for="start-node-select">Select Start Node:</label> <select id="start-node-select"></select>
            </div>
             <button id="prepare-dfs-btn">Prepare DFS</button>
            <button id="reset-dfs-btn" disabled>Reset</button>
            <button id="step-dfs-btn" disabled>Step</button>
            <button id="run-dfs-btn" disabled>Run</button>
            <div id="speed-control">
                <label for="speed-slider">Speed:</label> <input type="range" id="speed-slider" min="50" max="3000" value="1000"> <span>ms</span>
            </div>

            <h2>Traversal Result</h2>
            <div id="traversal-result">Result: </div>
        </div>

        <div id="visualization-area">
            <h2>Graph Visualization</h2>
             <svg id="graph-svg">
                 <!-- Arrowhead marker definition -->
                 <defs>
                     <marker id="arrowhead" viewBox="0 0 10 10" refX="8" refY="5" markerUnits="strokeWidth" markerWidth="6" markerHeight="6" orient="auto">
                         <path d="M 0 0 L 10 5 L 0 10 z" />
                     </marker>
                      <marker id="arrowhead-exploring" viewBox="0 0 10 10" refX="8" refY="5" markerUnits="strokeWidth" markerWidth="6" markerHeight="6" orient="auto" fill="purple">
                         <path d="M 0 0 L 10 5 L 0 10 z" />
                     </marker>
                 </defs>
             </svg>

            <h2>Visited Nodes</h2>
            <div id="visited-display"></div>

            <h2>DFS Code</h2>
            <pre><code id="code-snippet"></code></pre>
        </div>
    </div>

    <footer>
        <p>GitHub: <a href="https://github.com/ashishmentor">https://github.com/ashishmentor</a></p>
    </footer>

    <script>
        // --- Data Structures ---
        let nodes = []; // Array of { id: number, x: number, y: number }
        let edges = []; // Array of { from: number, to: number }
        let adjList = {}; // Adjacency list: { nodeId: [neighborIds] }
        let nextNodeId = 0;
        let nodeElements = {}; // Map nodeId to SVG circle element
        let edgeElements = {}; // Map edgeId (e.g., "0-1") to SVG line element

        // --- State Variables ---
        const state = {
            mode: 'select', // 'select', 'connecting', 'deleting'
            firstNodeClickedForEdge: null, // ID of the first node clicked in 'connecting' mode
            selectedStartNode: null, // ID of the chosen start node for DFS
            dfsSteps: [], // Sequence of steps for visualization
            currentStepIndex: 0, // Current index in dfsSteps
            visited: new Set(), // Set of visited node IDs during visualization
            traversalOrder: [], // Array storing the DFS traversal order
            animationTimer: null, // Timer ID for run animation
            draggingNodeId: null, // ID of the node currently being dragged
            dragOffsetX: 0, // Mouse X offset from node center
            dragOffsetY: 0, // Mouse Y offset from node center
        };

        // --- DOM Elements ---
        const svg = document.getElementById('graph-svg');
        const addNodeBtn = document.getElementById('add-node-btn');
        const connectNodesBtn = document.getElementById('connect-nodes-btn');
        const deleteNodeBtn = document.getElementById('delete-node-btn');
        const modeIndicator = document.getElementById('mode-indicator');
        const startNodeSelect = document.getElementById('start-node-select');
        const prepareDfsBtn = document.getElementById('prepare-dfs-btn');
        const resetDfsBtn = document.getElementById('reset-dfs-btn');
        const stepDfsBtn = document.getElementById('step-dfs-btn');
        const runDfsBtn = document.getElementById('run-dfs-btn');
        const speedSlider = document.getElementById('speed-slider');
        const traversalResultDiv = document.getElementById('traversal-result');
        const visitedDisplayDiv = document.getElementById('visited-display');
        const codeSnippetPre = document.getElementById('code-snippet');

        // --- Constants ---
        const NODE_RADIUS = 18;
        const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        const CODE_SNIPPET = `
1 function DFS(node, visited):
2   visited[node] = true
3   add node to traversal result
4   for each neighbor in adjacencyList[node]:
5     if not visited[neighbor]:
6       DFS(neighbor, visited)
`.trim();

        // Map step types to code line numbers (1-based)
        const STEP_TO_LINE = {
             'start': 1, // Entering the DFS function call
             'visit': 2, // Marking node as visited
             'add_to_traversal': 3, // Adding node to the result list
             'explore_edge': 4, // Entering/continuing loop to check neighbors
             'check_visited': 5, // Checking if a specific neighbor is visited
             'recursive_call': 6, // Making the recursive call to an unvisited neighbor
             'backtrack': 1 // Returning from a recursive call (conceptually the end of the function call)
        };


        // --- Helper Functions ---
        function updateUIState() {
            modeIndicator.textContent = `Mode: ${state.mode.replace(/([A-Z])/g, ' $1').trim()}`;

             // Update cursor for SVG area based on mode
             svg.classList.remove('connecting-mode', 'deleting-mode');
             if(state.mode === 'connecting') svg.classList.add('connecting-mode');
             if(state.mode === 'deleting') svg.classList.add('deleting-mode');


            const isDfsPrepared = state.dfsSteps.length > 0;
            const isDfsRunning = state.animationTimer !== null;
             const isDfsComplete = isDfsPrepared && state.currentStepIndex >= state.dfsSteps.length;
            const isGraphEditable = !isDfsPrepared || isDfsComplete; // Editable if DFS not prepared or has finished


            addNodeBtn.disabled = !isGraphEditable;
            connectNodesBtn.disabled = !isGraphEditable;
            deleteNodeBtn.disabled = !isGraphEditable;
            startNodeSelect.disabled = !isGraphEditable;
             prepareDfsBtn.disabled = nodes.length === 0 || state.selectedStartNode === null || isDfsPrepared;


            resetDfsBtn.disabled = !isDfsPrepared && state.currentStepIndex === 0; // Enabled if DFS was prepared or ran
            stepDfsBtn.disabled = !isDfsPrepared || isDfsRunning || isDfsComplete;
            runDfsBtn.disabled = !isDfsPrepared || isDfsRunning || isDfsComplete;

             // Update button active states
             addNodeBtn.classList.toggle('active-mode', state.mode === 'select' && isGraphEditable);
             connectNodesBtn.classList.toggle('active-mode', state.mode === 'connecting');
             deleteNodeBtn.classList.toggle('active-mode', state.mode === 'deleting');
        }

        function renderGraph() {
            // Clear SVG content except for markers
            svg.querySelectorAll(':not(defs)').forEach(el => el.remove());

            nodeElements = {}; // Reset map
            edgeElements = {}; // Reset map

            // Draw edges
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.from);
                const targetNode = nodes.find(n => n.id === edge.to);
                if (!sourceNode || !targetNode) return;

                const line = document.createElementNS(SVG_NAMESPACE, 'line');
                line.setAttribute('x1', sourceNode.x);
                line.setAttribute('y1', sourceNode.y);
                line.setAttribute('x2', targetNode.x);
                line.setAttribute('y2', targetNode.y);
                line.setAttribute('class', 'edge');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                const edgeId = `${edge.from}-${edge.to}`;
                line.dataset.id = edgeId;
                line.dataset.from = edge.from;
                line.dataset.to = edge.to;
                svg.appendChild(line);
                edgeElements[edgeId] = line;
            });

            // Draw nodes and text (draw after edges so they are on top)
            nodes.forEach(node => {
                const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', NODE_RADIUS);
                circle.setAttribute('class', 'node');
                circle.dataset.id = node.id;
                svg.appendChild(circle);
                nodeElements[node.id] = circle;

                const text = document.createElementNS(SVG_NAMESPACE, 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y + 5); // Adjust position slightly
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('class', 'node-text');
                text.dataset.id = node.id;
                text.textContent = node.id;
                svg.appendChild(text);
            });

             // Reapply any active DFS visualization styles if they exist (e.g., after window resize)
             applyDfsVisualizationStyles();
        }

        function applyDfsVisualizationStyles() {
            // Apply styles based on current state during visualization
            if (state.dfsSteps.length > 0 && state.currentStepIndex > 0) {
                // Reapply visited styles
                state.visited.forEach(nodeId => {
                    const nodeEl = nodeElements[nodeId];
                    if (nodeEl) nodeEl.classList.add('visited');
                });

                // Reapply current node/edge highlight from the last executed step
                // Re-executing the last step's visual part is the easiest way
                if (state.currentStepIndex > 0) {
                    const lastStep = state.dfsSteps[state.currentStepIndex - 1];
                     // Temporarily set index back to re-run just the executeStep logic
                     const originalIndex = state.currentStepIndex;
                     state.currentStepIndex--; // Decrement so executeStep processes the last step
                     executeStep(lastStep); // Re-apply visual state
                     state.currentStepIndex = originalIndex; // Restore index
                }
            }
             // Ensure visited list and traversal result match current state
             updateVisitedDisplay();
             updateTraversalResult();
        }


        function updateNodeSvgPosition(nodeId, x, y) {
            const nodeCircle = nodeElements[nodeId];
            const nodeText = svg.querySelector(`.node-text[data-id="${nodeId}"]`);
            if (nodeCircle) {
                nodeCircle.setAttribute('cx', x);
                nodeCircle.setAttribute('cy', y);
            }
             if (nodeText) {
                 nodeText.setAttribute('x', x);
                 nodeText.setAttribute('y', y + 5);
             }

            // Update connected edges
            edges.filter(edge => edge.from === nodeId || edge.to === nodeId)
                 .forEach(edge => {
                     const edgeId = `${edge.from}-${edge.to}`;
                     const edgeLine = edgeElements[edgeId];
                     if (edgeLine) {
                         const sourceNode = nodes.find(n => n.id === edge.from);
                         const targetNode = nodes.find(n => n.id === edge.to);
                         if (sourceNode && targetNode) {
                             edgeLine.setAttribute('x1', sourceNode.x);
                             edgeLine.setAttribute('y1', sourceNode.y);
                             edgeLine.setAttribute('x2', targetNode.x);
                             edgeLine.setAttribute('y2', targetNode.y);
                         }
                     }
                 });
        }


        function setMode(mode) {
             // If we are entering a mode that allows graph modification,
             // cancel any pending DFS visualization
             if (mode !== 'select' || state.mode !== 'select') { // Switch mode OR entering connect/delete
                 if (state.dfsSteps.length > 0 && state.currentStepIndex < state.dfsSteps.length) {
                     // If DFS is prepared or running, reset it first
                     resetDFS();
                 }
             }

             // Remove active class from all buttons
             addNodeBtn.classList.remove('active-mode');
             connectNodesBtn.classList.remove('active-mode');
             deleteNodeBtn.classList.remove('active-mode');

             // Remove any temporary visual cues from graph (like first node selection for edge)
             if (state.firstNodeClickedForEdge !== null) {
                 // No specific visual cue implemented for first click, so just reset state var
             }
             state.firstNodeClickedForEdge = null;

             // Update mode state
            state.mode = mode;

            // Add active state to the current button/mode
            switch (mode) {
                case 'select': addNodeBtn.classList.add('active-mode'); break; // "Select" mode's primary action is adding nodes via SVG click
                case 'connecting': connectNodesBtn.classList.add('active-mode'); break;
                case 'deleting': deleteNodeBtn.classList.add('active-mode'); break;
            }

            // Update mode indicator text and button disabled states
            updateUIState();
        }

        function buildAdjacencyList() {
            adjList = {};
            nodes.forEach(node => {
                adjList[node.id] = [];
            });
            edges.forEach(edge => {
                if (adjList[edge.from] && adjList[edge.to]) { // Ensure both 'from' and 'to' nodes exist
                     if (!adjList[edge.from].includes(edge.to)) {
                        adjList[edge.from].push(edge.to);
                    }
                } else {
                     console.warn(`Edge involves deleted node: ${edge.from}-${edge.to}`);
                     // This shouldn't happen if deleteNode cleans up edges correctly
                }
            });
             // Sort adjacency lists numerically for consistent traversal
             Object.keys(adjList).forEach(nodeId => {
                 adjList[nodeId].sort((a, b) => a - b);
             });
        }

        function populateStartNodeSelect() {
             const currentSelection = startNodeSelect.value;
             startNodeSelect.innerHTML = '<option value="">-- Select --</option>';
             nodes.forEach(node => {
                 const option = document.createElement('option');
                 option.value = node.id;
                 option.textContent = node.id;
                 startNodeSelect.appendChild(option);
             });

             // Restore selection if the node still exists
             if (currentSelection !== "" && nodes.some(node => node.id === parseInt(currentSelection, 10))) {
                 startNodeSelect.value = currentSelection;
                 state.selectedStartNode = parseInt(currentSelection, 10);
             } else {
                  state.selectedStartNode = null;
                  startNodeSelect.value = "";
             }

             updateUIState();
        }

         // --- Graph Manipulation ---
        // Node adding via SVG click handled in init() svg click listener
        // Node deleting handled in handleNodeClick()


        function deleteNode(nodeId) {
             if (state.dfsSteps.length > 0 && state.currentStepIndex < state.dfsSteps.length) return;

            // Remove from nodes array
            nodes = nodes.filter(node => node.id !== nodeId);

            // Remove edges connected to this node
            edges = edges.filter(edge => edge.from !== nodeId && edge.to !== nodeId);

            // Remove from SVG and element maps
            const nodeSvgElement = nodeElements[nodeId];
            const textSvgElement = svg.querySelector(`.node-text[data-id="${nodeId}"]`);
            if(nodeSvgElement) nodeSvgElement.remove();
            if(textSvgElement) textSvgElement.remove();
            delete nodeElements[nodeId];

             // Remove edge SVG elements involving the deleted node
             Object.keys(edgeElements).filter(edgeId => {
                 const parts = edgeId.split('-');
                 const fromId = parseInt(parts[0], 10);
                 const toId = parseInt(parts[1], 10);
                 return fromId === nodeId || toId === nodeId;
             }).forEach(edgeId => {
                 edgeElements[edgeId].remove();
                 delete edgeElements[edgeId];
             });


            buildAdjacencyList();
            // renderGraph(); // Can call this instead if element removal logic is complex, but less efficient
            populateStartNodeSelect();
            resetDFS(); // Reset any prepared DFS as graph changed
            updateUIState();
        }

         // --- Interaction Handlers (Delegated) ---

        // Handle clicks on SVG, specifically for adding nodes or interacting with existing nodes
        svg.addEventListener('click', (e) => {
             // If DFS visualization is running, disable direct graph interaction
             if (state.dfsSteps.length > 0 && state.currentStepIndex < state.dfsSteps.length) {
                return;
             }

             // If clicking a node or text element
             if (e.target.classList && (e.target.classList.contains('node') || e.target.classList.contains('node-text'))) {
                 const nodeId = parseInt(e.target.dataset.id, 10);
                 handleNodeClick(nodeId);
             } else if (e.target === svg) {
                 // If clicking the SVG background
                 if (state.mode === 'select') {
                     // Add a node at the clicked position
                    const svgRect = svg.getBoundingClientRect();
                    const x = e.clientX - svgRect.left;
                    const y = e.clientY - svgRect.top;

                     const newNode = {
                         id: nextNodeId++,
                         x: x,
                         y: y
                     };
                     nodes.push(newNode);
                     buildAdjacencyList();
                     renderGraph(); // Re-render graph to add new node/text and update maps
                     populateStartNodeSelect();
                     resetDFS(); // Reset any prepared DFS as graph changed
                     updateUIState();
                 }
                  // Clicks in other modes (connecting, deleting) on background do nothing
             }
             // Clicks on edges can be ignored for now
        });

        // Handle mousedown on SVG, delegated to start dragging
        svg.addEventListener('mousedown', (e) => {
             // If DFS visualization is running, disable direct graph interaction
             if (state.dfsSteps.length > 0 && state.currentStepIndex < state.dfsSteps.length) {
                return;
             }

            if (state.mode === 'select' && e.target.classList && e.target.classList.contains('node')) {
                const circleElement = e.target;
                const nodeId = parseInt(circleElement.dataset.id, 10);
                state.draggingNodeId = nodeId;

                 const svgRect = svg.getBoundingClientRect();
                 const mouseX = e.clientX - svgRect.left;
                 const mouseY = e.clientY - svgRect.top;
                 const node = nodes.find(n => n.id === nodeId);

                 state.dragOffsetX = mouseX - node.x;
                 state.dragOffsetY = mouseY - node.y;

                circleElement.classList.add('dragging');
                // Cursor style handled by CSS .node.dragging

                // Bring the dragged node and its text to the top
                 const textElement = svg.querySelector(`.node-text[data-id="${nodeId}"]`);
                 if(textElement) svg.appendChild(textElement);
                svg.appendChild(circleElement); // Appending moves it to the end (on top)


                e.preventDefault(); // Prevent default browser drag behavior
            }
        });

        // Handle mousemove on SVG for dragging
        svg.addEventListener('mousemove', (e) => {
            if (state.draggingNodeId !== null) {
                const nodeId = state.draggingNodeId;
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                   const svgRect = svg.getBoundingClientRect();
                   const mouseX = e.clientX - svgRect.left;
                   const mouseY = e.clientY - svgRect.top;
                   const newX = mouseX - state.dragOffsetX;
                   const newY = mouseY - state.dragOffsetY;

                   // Update node position in data
                   node.x = newX;
                   node.y = newY;

                   // Update SVG elements for the node and its connected edges
                   updateNodeSvgPosition(nodeId, newX, newY);
                }
            }
        });

        // Handle mouseup on SVG to end dragging
        svg.addEventListener('mouseup', (e) => {
            if (state.draggingNodeId !== null) {
                const nodeId = state.draggingNodeId;
                const nodeElement = nodeElements[nodeId];
                if(nodeElement) nodeElement.classList.remove('dragging');

                state.draggingNodeId = null;
                state.dragOffsetX = 0;
                state.dragOffsetY = 0;
            }
        });


         function handleNodeClick(nodeId) {
            switch (state.mode) {
                case 'connecting':
                    if (state.firstNodeClickedForEdge === null) {
                        state.firstNodeClickedForEdge = nodeId;
                        // Optional: Add highlight class to the first clicked node
                         // const firstNodeEl = nodeElements[nodeId];
                         // if (firstNodeEl) { firstNodeEl.classList.add('connecting-start'); }
                    } else {
                        const from = state.firstNodeClickedForEdge;
                        const to = nodeId;
                        // Remove highlight from the first clicked node if applied
                         // const firstNodeEl = nodeElements[from];
                         // if (firstNodeEl) { firstNodeEl.classList.remove('connecting-start'); }

                        if (from !== to && !edges.some(e => e.from === from && e.to === to)) {
                            edges.push({ from: from, to: to });
                            buildAdjacencyList();
                            renderGraph(); // Re-render graph to add new edge and update maps
                             resetDFS(); // Reset any prepared DFS as graph changed
                        }
                        state.firstNodeClickedForEdge = null;
                        setMode('select'); // Go back to select mode
                    }
                    break;
                case 'deleting':
                    deleteNode(nodeId);
                    setMode('select'); // Go back to select mode
                    break;
                case 'select':
                    // In select mode, clicking a node does nothing currently, drag is handled by mousedown
                    break;
            }
            updateUIState();
        }


        // --- DFS Algorithm Logic (Step Recording) ---

         function recordDfsSteps(startNodeId) {
             state.dfsSteps = [];
             state.currentStepIndex = 0;

             // Use temporary visited set for the dry run
             const visitedDuringRecord = new Set();

             function dfs(nodeId) {
                 // Ensure node exists in the current adjList before proceeding
                 if (adjList[nodeId] === undefined) {
                     console.warn(`Attempted DFS from/to deleted node ${nodeId} during recording.`);
                     return; // Stop exploring this path if node is missing
                 }

                 // Before visiting, record step to enter function/context
                 state.dfsSteps.push({ type: 'start', nodeId: nodeId }); // Conceptual start of call

                 // Visit step
                 visitedDuringRecord.add(nodeId);
                 state.dfsSteps.push({ type: 'visit', nodeId: nodeId });
                 state.dfsSteps.push({ type: 'add_to_traversal', nodeId: nodeId });


                 const neighbors = adjList[nodeId] || [];
                 // Record exploring edges from this node (entering loop)
                 state.dfsSteps.push({ type: 'explore_edge', fromId: nodeId, neighbors: neighbors });

                 // Iterate through neighbors (using a copy in case adjList is modified - not expected here, but good practice)
                 [...neighbors].forEach(neighborId => {
                     // Check if neighbor exists in the graph (could have been deleted)
                     if (nodes.some(n => n.id === neighborId)) {
                          // Record check visited step for the current neighbor
                         state.dfsSteps.push({ type: 'check_visited', fromId: nodeId, toId: neighborId });

                         if (!visitedDuringRecord.has(neighborId)) {
                             // Record step before recursive call
                             state.dfsSteps.push({ type: 'recursive_call', fromId: nodeId, toId: neighborId });
                             dfs(neighborId); // Recursive call
                             // Record step after returning from recursive call
                             state.dfsSteps.push({ type: 'backtrack', fromId: nodeId, toId: neighborId });
                         } else {
                              // Record step for skipping already visited neighbor? Optional
                              // state.dfsSteps.push({ type: 'skip_visited', fromId: nodeId, toId: neighborId });
                         }
                     } else {
                          console.warn(`Neighbor node ${neighborId} of node ${nodeId} not found during recording.`);
                     }
                 });

                 // Record step for exiting function/context after checking all neighbors
                 // state.dfsSteps.push({ type: 'end_node', nodeId: nodeId }); // Optional end step
             }

             // Start DFS from the selected node if it exists
             if (nodes.some(n => n.id === startNodeId)) {
                  dfs(startNodeId);
                  // Add a final step to indicate completion
                  state.dfsSteps.push({ type: 'end' });
             } else {
                 console.warn(`Start node ${startNodeId} not found in graph.`);
                 state.dfsSteps = []; // Clear steps if start node is invalid
                  alert(`Error: Start node ${startNodeId} not found. Add nodes first.`);
             }

             // Reset visited/traversal for the actual step-by-step execution
             state.visited = new Set();
             state.traversalOrder = [];
             updateVisitedDisplay();
             updateTraversalResult(); // Clear displayed result
         }

        function prepareDFS() {
             const startNodeId = parseInt(startNodeSelect.value, 10);
             if (isNaN(startNodeId) || !nodes.some(n => n.id === startNodeId)) {
                 alert("Please select a valid start node.");
                 return;
             }
            state.selectedStartNode = startNodeId;
            buildAdjacencyList(); // Ensure adjacency list is up-to-date
            recordDfsSteps(state.selectedStartNode);

             if (state.dfsSteps.length > 0) {
                 resetGraphVisualization(); // Reset visual state before starting steps
                 // Execute the very first step ('start') immediately after preparing
                 executeStep(state.dfsSteps[state.currentStepIndex]);
                 state.currentStepIndex++;
             }
            updateUIState();
        }

        function resetDFS() {
            stopRun();
             state.dfsSteps = [];
            state.currentStepIndex = 0;
            state.visited = new Set();
            state.traversalOrder = [];
             resetGraphVisualization(); // Clears visual state on graph nodes/edges
             updateVisitedDisplay(); // Resets visited list display
             updateTraversalResult(); // Clears traversal result display
             updateCodeHighlighting(null); // Remove highlighting
            updateUIState(); // Update button states
        }

         function resetGraphVisualization() {
             // Remove all DFS specific classes from nodes and edges and reset styles
             svg.querySelectorAll('.node').forEach(nodeEl => {
                 nodeEl.classList.remove('visiting', 'visited', 'current', 'dragging'); // Ensure dragging class is also removed
             });
              svg.querySelectorAll('.node-text').forEach(textEl => {
                 // Reset inline styles if applied
                 textEl.style.fill = '';
                 textEl.style.fontWeight = '';
              });

             svg.querySelectorAll('.edge').forEach(edgeEl => {
                 edgeEl.classList.remove('exploring');
                  edgeEl.setAttribute('marker-end', 'url(#arrowhead)'); // Reset marker
             });
         }


        function executeStep(step) {
            if (!step) {
                // This happens if stepDFS is called when already finished
                 stopRun(); // Ensure run stops
                 updateUIState(); // Ensure buttons are disabled
                return;
            }

             // Clear previous step's temporary highlights (current node, exploring edge)
             svg.querySelectorAll('.node.current').forEach(el => el.classList.remove('current'));
              svg.querySelectorAll('.node-text').forEach(textEl => {
                  // Reset only if it was highlighted blue
                 if(textEl.style.fill === 'blue') textEl.style.fill = '';
                 if(textEl.style.fontWeight === 'bold') textEl.style.fontWeight = '';
              });

             svg.querySelectorAll('.edge.exploring').forEach(el => {
                  el.classList.remove('exploring');
                   el.setAttribute('marker-end', 'url(#arrowhead)');
             });

            // Remove temporary visited highlight from list item
            visitedDisplayDiv.querySelectorAll('li.visited-current').forEach(li => li.classList.remove('visited-current'));


            let highlightNodeId = null; // Node to highlight as 'current'

            switch (step.type) {
                case 'start':
                    // Starting DFS function call on start node
                    highlightNodeId = step.nodeId;
                    break;
                case 'visit':
                    // Mark node as visited in the state
                    state.visited.add(step.nodeId);
                    updateVisitedDisplay(); // Redraw visited list
                    // Add 'visited' class to the node element
                     const visitedNodeEl = nodeElements[step.nodeId];
                     if (visitedNodeEl) visitedNodeEl.classList.add('visited');
                    // Highlight the node as current
                    highlightNodeId = step.nodeId;
                    // Add temporary highlight to the corresponding visited list item
                    const visitedLi = visitedDisplayDiv.querySelector(`li[data-node-id="${step.nodeId}"]`);
                    if(visitedLi) visitedLi.classList.add('visited-current');
                    break;
                case 'add_to_traversal':
                    // Add node to the traversal result
                    state.traversalOrder.push(step.nodeId);
                    updateTraversalResult();
                    highlightNodeId = step.nodeId; // Keep node highlighted
                    // Visited list highlight removed before switch
                    break;
                case 'explore_edge':
                    // Represents the loop starting or moving to the next neighbor
                     highlightNodeId = step.fromId; // Keep the node whose neighbors are being explored as current
                     break;
                case 'check_visited':
                    // Checking the 'if (!visited[neighbor])' condition
                     highlightNodeId = step.fromId; // Keep parent highlighted
                     const checkEdgeId = `${step.fromId}-${step.toId}`;
                    const checkEdgeElement = edgeElements[checkEdgeId];
                    if (checkEdgeElement) {
                         checkEdgeElement.classList.add('exploring'); // Highlight the edge being considered
                          checkEdgeElement.setAttribute('marker-end', 'url(#arrowhead-exploring)');
                    }
                    break;
                case 'recursive_call':
                    // About to make the recursive call to neighbor
                     highlightNodeId = step.toId; // The neighbor node is about to become current (will be visited next)
                     const callEdgeId = `${step.fromId}-${step.toId}`;
                     const callEdgeElement = edgeElements[callEdgeId];
                     if (callEdgeElement) {
                          callEdgeElement.classList.add('exploring'); // Keep edge highlighted
                           callEdgeElement.setAttribute('marker-end', 'url(#arrowhead-exploring)');
                     }
                    break;
                case 'backtrack':
                    // Returning from a recursive call
                     highlightNodeId = step.fromId; // The node we are returning TO becomes current again (conceptually)
                     break;
                 case 'end':
                    // DFS completed
                    stopRun();
                    updateCodeHighlighting(null); // Remove code highlight
                    alert("DFS Complete!");
                    break;
                default:
                    console.warn("Unknown step type:", step.type, step);
                     break;
            }

            // Apply 'current' node highlighting if a node is specified
            if (highlightNodeId !== null && nodeElements[highlightNodeId]) {
                const nodeElement = nodeElements[highlightNodeId];
                nodeElement.classList.add('current');
                 const textElement = svg.querySelector(`.node-text[data-id="${highlightNodeId}"]`);
                 if(textElement) {
                      textElement.style.fill = 'blue';
                      textElement.style.fontWeight = 'bold';
                 }
            }

             // Apply code highlighting
             if (STEP_TO_LINE[step.type]) {
                 updateCodeHighlighting(STEP_TO_LINE[step.type]);
             } else {
                 // For steps that don't map directly to a line (like 'end'), remove highlight
                 updateCodeHighlighting(null);
             }


             // If this was the last step (the 'end' step), update UI state
             if (step.type === 'end') {
                 updateUIState();
             }
        }

        function stepDFS() {
             if (state.currentStepIndex < state.dfsSteps.length) {
                const step = state.dfsSteps[state.currentStepIndex];
                executeStep(step);
                state.currentStepIndex++;
                // updateUIState will be called by executeStep if it's the 'end' step
                if (step.type !== 'end') {
                   updateUIState(); // Update buttons after non-end step
                }
             } else {
                 // Already finished, ensure UI is updated
                 updateUIState();
             }
        }

        function runDFS() {
            if (state.animationTimer) return;
            if (state.currentStepIndex >= state.dfsSteps.length) {
                 // If already finished, maybe reset or just do nothing?
                 // Let's make run button disabled if finished
                 updateUIState();
                 return;
            }

            const speed = parseInt(speedSlider.value, 10);

             // Disable step and run buttons immediately
             stepDfsBtn.disabled = true;
             runDfsBtn.disabled = true;
             // updateUIState will do this after setting timer, but doing it here feels more responsive

            state.animationTimer = setInterval(() => {
                if (state.currentStepIndex < state.dfsSteps.length) {
                    executeStep(state.dfsSteps[state.currentStepIndex]);
                    state.currentStepIndex++;
                    // updateUIState called by executeStep for the 'end' case.
                } else {
                    stopRun();
                    updateUIState(); // Ensure buttons are updated when loop finishes
                }
            }, speed);

             updateUIState(); // Final state update after setting timer
        }

        function stopRun() {
            clearInterval(state.animationTimer);
            state.animationTimer = null;
             // Buttons will be re-enabled by updateUIState when the run stops
        }

        function updateVisitedDisplay() {
             visitedDisplayDiv.innerHTML = '<strong>Visited:</strong>';
             if (nodes.length === 0) {
                 visitedDisplayDiv.innerHTML += ' <em>No nodes yet.</em>';
                 return;
             }
             const ul = document.createElement('ul');
             nodes.forEach(node => {
                 const li = document.createElement('li');
                 li.dataset.nodeId = node.id; // Add data attribute for lookup
                 const isVisited = state.visited.has(node.id);
                 li.classList.add(isVisited ? 'visited-true' : 'visited-false');
                 li.textContent = `Node ${node.id}: ${isVisited}`;
                 ul.appendChild(li);
            });
             visitedDisplayDiv.appendChild(ul);
        }

        function updateTraversalResult() {
            traversalResultDiv.textContent = `Result: ${state.traversalOrder.join(' ')}`;
        }

         function updateCodeHighlighting(lineNumber) {
             // Store current scroll position
            const scrollTop = codeSnippetPre.scrollTop;

             // Reset to plain text first
             codeSnippetPre.innerHTML = ''; // Clear current content
             const codeElement = document.createElement('code');
             codeElement.textContent = CODE_SNIPPET;
             codeSnippetPre.appendChild(codeElement);


             if (lineNumber === null || lineNumber < 1) {
                 // No line to highlight, reset is done
                // Restore scroll position
                codeSnippetPre.scrollTop = scrollTop;
                 return;
             }

             // Split the code into lines
             const lines = CODE_SNIPPET.split('\n');

             // Check if lineNumber is valid
             if (lineNumber > lines.length) {
                 console.warn(`Line number ${lineNumber} is out of bounds for code snippet (max ${lines.length}).`);
                // Restore scroll position
                codeSnippetPre.scrollTop = scrollTop;
                 return;
             }

             // Rebuild the code block with highlighting for the target line
             let highlightedCodeHtml = '';
             lines.forEach((line, index) => {
                 const currentLineNumber = index + 1;
                 if (currentLineNumber === lineNumber) {
                     // Use span for highlighting, preserve original line breaks/whitespace
                     highlightedCodeHtml += `<span class="highlighted-line">${line}</span>\n`;
                 } else {
                     highlightedCodeHtml += line + '\n';
                 }
             });

             // Set the innerHTML, excluding the final newline added by the loop
             codeSnippetPre.innerHTML = highlightedCodeHtml.trimEnd(); // trimEnd removes only trailing newlines/whitespace

             // Restore scroll position
             codeSnippetPre.scrollTop = scrollTop;
         }


        // --- Initialization ---
        function init() {
            // Set initial code snippet text
            codeSnippetPre.textContent = CODE_SNIPPET;
             updateCodeHighlighting(null); // Apply initial styling without highlight

            // Add event listeners for control buttons
            addNodeBtn.addEventListener('click', () => setMode('select'));
            connectNodesBtn.addEventListener('click', () => setMode('connecting'));
            deleteNodeBtn.addEventListener('click', () => setMode('deleting'));

            // Listener for the start node dropdown
            startNodeSelect.addEventListener('change', (e) => {
                 state.selectedStartNode = e.target.value === "" ? null : parseInt(e.target.value, 10);
                 // Reset any prepared or running DFS when start node changes
                 resetDFS();
                 updateUIState();
            });

            // Listeners for DFS control buttons
            prepareDfsBtn.addEventListener('click', prepareDFS);
            resetDfsBtn.addEventListener('click', resetDFS);
            stepDfsBtn.addEventListener('click', stepDFS);
            runDfsBtn.addEventListener('click', runDFS);

             // Listen for window resize to re-render graph and maintain layout
             window.addEventListener('resize', () => {
                 renderGraph(); // Redraw graph on resize
                 // applyDfsVisualizationStyles(); // Called inside renderGraph now
                 updateUIState(); // Update UI state which might depend on size/flex
             });


             // SVG mouse listeners are delegated to handle node clicks and dragging
             // See mouseup/mousedown/mousemove/click listeners on svg element above


             // Set initial mode and update UI
            setMode('select'); // Start in select mode (which also updates UI)
            updateVisitedDisplay(); // Display initial visited state
            updateTraversalResult(); // Display initial result
        }

        // --- Run Initialization ---
        init();

    </script>
</body>
</html>
```